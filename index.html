<!DOCTYPE html>
<html lang="en">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-17KR2JJYTY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-17KR2JJYTY');
</script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

<meta property="og:title" content="whyARCADE">
    <meta property="og:description" content="Race through the frozen arctic as a polar bear! Collect silver coins and rare gold power-ups. THRILL RIDE experience!">
    <meta property="og:image" content="polar.png">
    <meta property="og:image:alt" content="whyARCADE">
    <meta property="og:url" content="https://why.com">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="whyARCADE">
    <meta property="og:locale" content="en_US">


    <title id="gameTitle">whyARCADE</title>
    <link rel="icon" href='data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">üêª‚Äç‚ùÑÔ∏è</text></svg>' type="image/svg+xml">

    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400..700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">


    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <!-- SPL Token omitted: MIME/block errors in Firefox; game does not use it -->

    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column; /* Allow column layout for header/game/footer */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            /* Arctic Panda - clean white/blue theme */
            background: #ffffff; /* Snow white background */
            color: #0088cc; /* Arctic blue text */
            font-family: 'Orbitron', sans-serif; /* Futuristic font for UI */
            position: relative; /* Needed for background pseudo-element */
        }

        /* Background Video Styling - REMOVED */
        /* Video Overlay - REMOVED */

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            flex-grow: 1; /* Allow canvas to take up available space */
            position: absolute; /* Ensure canvas is part of the layout flow for z-indexing */
            top: 0;
            left: 0;
            z-index: 1; /* Game canvas behind UI overlays but above body background */
            /* GPU layer and containment for smooth rendering (cyphes-style, same 5 as AAA) */
            contain: strict;
            will-change: transform;
            transform: translateZ(0);
        }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
           EPIC CINEMATIC INTRO
           ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        #cinematic-intro {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9999;
            background: #000000; /* Pure black background */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            opacity: 1;
            transition: opacity 1.5s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }
        
        /* Background Video Styling for Intro */
        #intro-background-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -2; /* Behind everything */
            opacity: 0.85; /* High opacity background video */
        }
        
        /* Video Overlay for Better Text Readability */
        #intro-video-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent; /* No overlay, let video show through */
            z-index: -1; /* Above video, behind UI */
            pointer-events: none;
        }
        
        #cinematic-intro.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        
        .intro-logo-container {
            position: relative;
            perspective: 1000px;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
        }
        
        .intro-logo {
            font-family: 'Orbitron', sans-serif;
            font-size: 10vw;
            font-weight: 900;
            color: rgba(255, 255, 255, 0.9); /* Slightly transparent white font */
            animation: introLogoReveal 2s ease-out forwards;
            animation-delay: 0.75s; /* Start 0.75 seconds after video starts */
            opacity: 0;
            transform: scale(0.5) rotateX(90deg);
            position: relative;
            letter-spacing: 0.05em;
            text-align: center;
            margin: 0 auto;
            z-index: 1; /* Above video */
        }
        
        @keyframes introLogoReveal {
            0% {
                opacity: 0;
                transform: scale(0.5) rotateX(90deg);
                /* Removed blur filter for performance */
            }
            60% {
                opacity: 1;
                transform: scale(1.1) rotateX(-5deg);
                /* Removed blur filter for performance */
            }
            100% {
                opacity: 1;
                transform: scale(1) rotateX(0deg);
                filter: blur(0);
            }
        }
        
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        @keyframes fadeInText {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }
        
        .intro-tagline {
            font-family: 'Inter', sans-serif;
            font-size: 1.5vw;
            color: rgba(102, 204, 204, 0.85); /* Slightly transparent */
            letter-spacing: 1em;
            text-transform: uppercase;
            margin-top: 20px;
            opacity: 0;
            animation: taglineReveal 1s ease-out 1.5s forwards;
            z-index: 1; /* Above video */
        }
        
        @keyframes taglineReveal {
            0% { opacity: 0; transform: translateY(20px); letter-spacing: 2em; }
            100% { opacity: 1; transform: translateY(0); letter-spacing: 1em; }
        }
        
        #intro-particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0; /* Above video but below text */
        }
        
        .ice-ring {
            position: absolute;
            width: 60vw;
            height: 60vw;
            border-radius: 50%;
            border: 3px solid transparent;
            background: radial-gradient(circle, transparent 40%, rgba(0, 170, 255, 0.15) 70%, transparent 100%);
            animation: iceRingPulse 3s ease-in-out infinite;
            pointer-events: none;
            z-index: 0; /* Above video but below text */
        }
        
        @keyframes iceRingPulse {
            0%, 100% { 
                transform: scale(1);
                opacity: 0.5;
                box-shadow: 0 0 60px rgba(0, 170, 255, 0.3), inset 0 0 60px rgba(0, 221, 255, 0.1);
            }
            50% { 
                transform: scale(1.1);
                opacity: 0.8;
                box-shadow: 0 0 100px rgba(0, 170, 255, 0.5), inset 0 0 80px rgba(0, 221, 255, 0.2);
            }
        }
        
        .snowflake {
            position: absolute;
            width: 6px;
            height: 6px;
            background: radial-gradient(circle, #ffffff, #00ddff);
            border-radius: 50%;
            animation: snowFloat 4s ease-in-out infinite;
            box-shadow: 0 0 10px #ffffff, 0 0 20px #00aaff;
        }
        
        @keyframes snowFloat {
            0%, 100% { 
                transform: translateY(0) rotate(0deg) scale(1);
                opacity: 1;
            }
            50% { 
                transform: translateY(-80px) rotate(180deg) scale(0.6);
                opacity: 0.6;
            }
        }
        
        .intro-prompt {
            position: absolute;
            bottom: 15%;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2vw;
            color: rgba(0, 221, 255, 0.85); /* Slightly transparent */
            letter-spacing: 0.3em;
            text-transform: uppercase;
            opacity: 0;
            animation: promptPulse 2s ease-in-out infinite, promptReveal 0.5s ease-out 2.5s forwards;
            z-index: 1; /* Above video */
        }
        
        @keyframes promptPulse {
            0%, 100% { opacity: 0.5; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
        }
        
        @keyframes countdownPulse {
            0% { 
                transform: scale(0.5);
                opacity: 0;
            }
            50% {
                transform: scale(1.1);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 0.8;
            }
        }
        
        @keyframes promptReveal {
            to { opacity: 1; }
        }
        
        /* EPIC GOLD COIN FLASH */
        @keyframes flashFade {
            0% { opacity: 0.5; }
            100% { opacity: 0; }
        }
        
        /* Ripple effect for gold coins */
        @keyframes rippleExpand {
            0% {
                width: 0;
                height: 0;
                opacity: 0.8;
            }
            100% {
                width: 200vw;
                height: 200vh;
                opacity: 0;
            }
        }
        
        /* THRILL RIDE speed lines overlay */
        .speed-lines-active {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            background: linear-gradient(180deg, 
                transparent 0%,
                rgba(255,255,255,0.03) 45%,
                rgba(0,200,255,0.05) 50%,
                rgba(255,255,255,0.03) 55%,
                transparent 100%
            );
            animation: speedPulse 0.1s ease-in-out infinite;
        }
        
        @keyframes speedPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.6; }
        }

        /* Full screen overlays for start and game over */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-family: 'Press Start 2P', cursive;
            z-index: 50; /* Above game elements */
            background-color: rgba(0, 0, 0, 0.4); /* More transparent for particle background */
        }

        #start-screen {
            /* Styles for H1 moved for cyberpunk effect */
            padding-bottom: 15vh; /* Pushes content up from the center */
        }

        #start-screen h1 {
            font-family: 'Orbitron', sans-serif; /* Changed from 'Press Start 2P' for a crisper look */
            font-weight: 700;
            font-size: 6.75vw; /* Slightly larger for impact */
            color: #fff; /* Bright white for high contrast */
            text-shadow: 
                0 0 1px #fff, 
                0 0 3px #00aaff, /* Arctic blue glow */
                0 0 8px #00aaff;
            position: relative;
            animation: flicker 8s infinite alternate;
        }

        .blinking-cursor {
            color: #00aaff;
            text-shadow: 0 0 5px #00aaff;
            animation: blink 1s steps(2) infinite;
        }

        @keyframes blink {
            50% {
                opacity: 0;
            }
        }

        #start-screen h1::before,
        #start-screen h1::after,
        #game-over-screen h1::before,
        #game-over-screen h1::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            overflow: hidden;
        }

        #start-screen h1::before,
        #game-over-screen h1::before {
            left: -2px;
            text-shadow: -2px 0 #ff00ff;
            animation: glitch-before 6s infinite linear alternate-reverse;
        }

        #start-screen h1::after,
        #game-over-screen h1::after {
            left: 2px;
            text-shadow: -2px 0 #00c2cb, 2px 2px #ff00ff;
            animation: glitch-after 5s infinite linear alternate-reverse;
        }

        @keyframes glitch-before {
            0% { clip-path: inset(83% 0 1% 0); transform: translateX(-0.05em); }
            10% { clip-path: inset(45% 0 40% 0); }
            20% { clip-path: inset(62% 0 31% 0); }
            30% { clip-path: inset(21% 0 71% 0); }
            40% { clip-path: inset(88% 0 5% 0); }
            50% { clip-path: inset(40% 0 51% 0); transform: translateX(0.05em); }
            60% { clip-path: inset(6% 0 88% 0); }
            70% { clip-path: inset(93% 0 4% 0); }
            80% { clip-path: inset(45% 0 45% 0); }
            90% { clip-path: inset(10% 0 80% 0); }
            100% { clip-path: inset(64% 0 27% 0); transform: translateX(0.05em); }
        }

        @keyframes glitch-after {
            0% { clip-path: inset(84% 0 13% 0); transform: translateX(0.05em); }
            10% { clip-path: inset(59% 0 25% 0); }
            20% { clip-path: inset(4% 0 88% 0); }
            30% { clip-path: inset(67% 0 17% 0); }
            40% { clip-path: inset(36% 0 58% 0); }
            50% { clip-path: inset(20% 0 77% 0); transform: translateX(-0.05em); }
            60% { clip-path: inset(79% 0 1% 0); }
            70% { clip-path: inset(44% 0 47% 0); }
            80% { clip-path: inset(92% 0 2% 0); }
            90% { clip-path: inset(14% 0 76% 0); }
            100% { clip-path: inset(64% 0 27% 0); transform: translateX(0.05em); }
        }

        @keyframes flicker {
            0%, 18%, 22%, 25%, 53%, 57%, 100% {
                text-shadow:
                    0 0 1px #fff, 
                    0 0 4px #00ffff, 
                    0 0 10px #00ffff, 
                    0 0 20px #00ffff, 
                    0 0 40px #ff00ff, /* Keep some magenta for the flicker effect */
                    0 0 50px #ff00ff;
            }
            20%, 24%, 55% {       
                text-shadow: none;
            }
        }

        @keyframes flicker-red {
            0%, 18%, 22%, 25%, 53%, 57%, 100% {
                text-shadow:
                    0 0 1px #fff,
                    0 0 4px #ff0055,
                    0 0 10px #ff0055,
                    0 0 20px #ff0055,
                    0 0 40px #ff0000,
                    0 0 50px #ff0000;
            }
            20%, 24%, 55% {
                text-shadow: none;
            }
        }

        /* Scanline Overlay */
        #start-screen::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 51;
            background-size: 100% 3px, 3px 100%;
            pointer-events: none;
            animation: scanline-anim 12s linear infinite;
        }
        
        @keyframes scanline-anim {
            from { background-position: 0 0; }
            to { background-position: 0 100%; }
        }

        #game-over-screen {
            color: #ff0055; /* Neon Pink */
            text-shadow: none; /* This is now on the h1 */
            display: none; /* Hidden by default */
            padding-bottom: 15vh; /* Pushes content up from the center */
            position: relative; /* For video positioning */
            overflow: hidden; /* Hide video overflow */
        }
        
        /* Background Video Styling for Stats Screen */
        #stats-background-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -1; /* Behind modal content */
            opacity: 0.85; /* High opacity background video */
        }

        #game-over-screen h1 {
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 3.375vw;
            color: #ff2222; /* A bright, crisp red */
            text-shadow:
                0 0 1px #fff,
                0 0 3px #ff0055,
                0 0 8px #ff0055;
            position: relative;
            animation: flicker-red 8s infinite alternate;
        }

        .overlay h1 {
            font-size: 3em;
            margin-bottom: 20px;
        }

        .overlay p {
            font-size: 1em;
            margin-bottom: 10px; /* Reduced margin */
            color: #ffffff; /* White text for info */
            text-shadow: none;
        }

        .overlay button {
            font-family: 'Press Start 2P', cursive;
            font-size: 1em;
            /* Adjusted padding to decrease size by roughly 50% */
            padding: 7.5px 15px; /* Half of 15px 30px */
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-transform: uppercase;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }

        /* Enhanced Start Screen Styling */
        .star-wars-logo {
            margin-bottom: 30px;
            animation: logoGlow 3s ease-in-out infinite alternate;
        }
        
        .logo-text {
            font-size: 3.5em;
            color: #ffff00;
            text-shadow: 0 0 20px rgba(255, 255, 0, 0.8);
            margin: 0;
            letter-spacing: 3px;
        }
        
        .custom-game-name {
            font-size: 2.2em;
            color: #ff3333;
            text-shadow: 0 0 15px rgba(255, 51, 51, 0.8);
            margin: 15px 0 5px 0;
            letter-spacing: 2px;
            font-weight: bold;
            animation: customNameGlow 2s ease-in-out infinite alternate;
        }
        
        @keyframes customNameGlow {
            0% { 
                text-shadow: 0 0 15px rgba(255, 51, 51, 0.8);
                transform: scale(1);
            }
            100% { 
                text-shadow: 0 0 25px rgba(255, 51, 51, 1), 0 0 35px rgba(255, 51, 51, 0.6);
                transform: scale(1.02);
            }
        }
        
        .logo-subtitle {
            font-size: 4em;
            color: #ff3333;
            text-shadow: 0 0 25px rgba(255, 51, 51, 0.8);
            margin: 10px 0 0 0;
            letter-spacing: 5px;
            font-weight: bold;
        }
        
        .game-description {
            margin: 20px 0 30px 0;
        }
        
        .main-desc {
            font-size: 1.4em;
            margin: 0;
            color: #ffffff;
        }
        
        .highlight {
            color: #ff3333;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 51, 51, 0.8);
        }
        
        .sub-desc {
            font-size: 1.1em;
            color: #888;
            margin: 10px 0 0 0;
        }
        
        .controls-section {
            background: rgba(20, 0, 0, 0.7);
            border: 2px solid #ff3333;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            min-width: 300px;
        }
        
        .controls-section h3 {
            color: #ff3333;
            margin: 0 0 15px 0;
            font-size: 1.3em;
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px; /* More padding */
            background: rgba(0, 100, 200, 0.15); /* Softer background */
            border-radius: 10px; /* More rounded */
            border: 1px solid rgba(0, 200, 255, 0.2); /* Subtle border */
            transition: all 0.3s ease;
        }
        
        .control-item:hover {
            background: rgba(0, 100, 200, 0.2);
            transform: translateY(-2px); /* Subtle lift */
        }
        
        .key {
            background: rgba(0, 150, 255, 0.3); /* Softer background */
            color: #ffd700; /* Gold color */
            padding: 6px 12px; /* More padding */
            border-radius: 6px; /* More rounded */
            font-family: 'Orbitron', sans-serif;
            font-weight: 600;
            font-size: 0.95em;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.4); /* Subtle glow */
            border: 1px solid rgba(255, 215, 0, 0.3);
        }
        
        .action {
            color: #b3e5fc; /* Softer white-blue */
            font-size: 1em;
            font-weight: 600;
            text-shadow: 0 0 10px rgba(179, 229, 252, 0.3);
        }
        
        .difficulty-section {
            margin: 20px 0;
        }
        
        .difficulty-section h3 {
            color: #ffff00;
            margin: 0 0 15px 0;
        }
        
        .difficulty-options {
            display: flex;
            gap: 10px;
        }
        
        .difficulty-btn {
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #666;
            color: #fff;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        
        .difficulty-btn:hover {
            border-color: #00ffff;
            background: rgba(0, 255, 255, 0.1);
        }
        
        .difficulty-btn.active {
            border-color: #00ff00;
            background: rgba(0, 255, 0, 0.2);
            color: #00ff00;
        }
        
        .start-btn {
            background: linear-gradient(45deg, #ff4444, #ff8800);
            border: 3px solid #ffff00;
            color: #ffffff;
            padding: 15px 30px;
            font-size: 1.4em;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            margin: 20px 0;
            transition: all 0.3s ease;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }
        
        .start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.8);
        }

        .main-buttons {
            display: flex;
            gap: 30px;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .main-btn {
            min-width: 200px;
            font-size: 1.2em;
        }
        /* JOIN CHAT: identical size/shape to Play Game & Agent Mode, only border is green */
        #join-chat-link {
            display: inline-block;
            box-sizing: border-box;
            padding: 15px 30px;
            min-width: 200px;
            font-size: 1.2em;
            font-weight: bold;
            border-radius: 10px;
            margin: 20px 0;
            transition: all 0.3s ease;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            color: #ffffff;
            text-decoration: none;
            text-align: center;
            cursor: pointer;
            background: linear-gradient(45deg, rgba(0, 255, 255, 0.3), rgba(0, 153, 255, 0.4), rgba(0, 255, 255, 0.3));
            background-size: 200% 200%;
            border: 2px solid #00ff00;
            animation: hyperspacePulse 2s ease-in-out infinite alternate;
        }
        #join-chat-link:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.8);
        }

        #wagmi-button {
            background: linear-gradient(45deg, rgba(0, 255, 255, 0.3), rgba(0, 153, 255, 0.4), rgba(0, 255, 255, 0.3));
            background-size: 200% 200%;
            border: 2px solid #00ffff;
            animation: hyperspacePulse 2s ease-in-out infinite alternate;
        }

        #planet-x-button {
            background: linear-gradient(45deg, rgba(0, 255, 255, 0.3), rgba(0, 153, 255, 0.4), rgba(0, 255, 255, 0.3));
            background-size: 200% 200%;
            border: 2px solid #00ffff;
            animation: hyperspacePulse 2s ease-in-out infinite alternate;
        }
        
        .tips-section {
            margin-top: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid #00ff00;
        }
        
        .tip {
            margin: 5px 0;
            font-size: 0.9em;
            color: #ccc;
        }
        
        @keyframes logoGlow {
            0% { transform: scale(1); }
            100% { transform: scale(1.02); }
        }

        /* Menu Buttons */
        .menu-buttons {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        .menu-btn {
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ffff;
            color: #00ffff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            font-size: 0.9em;
            min-width: 120px;
        }

        .menu-btn:hover {
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            transform: translateY(-2px);
        }

        .current-difficulty {
            margin-top: 15px;
            color: #ffff00;
            font-size: 0.9em;
            text-shadow: 0 0 10px rgba(255, 255, 0, 0.8);
        }

        /* Modal Styling - above intro (intro is 9999) so Bot Setup/Difficulty/Controls/Tips show on top when opened from landing */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3); /* Darker background to show video better */
            backdrop-filter: blur(1px); /* Less blur to show video */
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10050;
        }

        .modal-content {
            background: radial-gradient(circle, rgba(10,30,50,0.75) 0%, rgba(5,15,30,0.8) 100%); /* More transparent to show video */
            border: 2px solid rgba(0, 200, 255, 0.4); /* Softer, more transparent border */
            border-radius: 20px; /* More rounded */
            padding: 35px; /* More padding */
            max-width: 650px; /* Slightly wider */
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            animation: modalSlideIn 0.4s ease-out;
            box-shadow: 0 8px 32px rgba(0, 200, 255, 0.3), inset 0 0 60px rgba(0, 150, 255, 0.1); /* Softer, layered shadow */
            backdrop-filter: blur(5px); /* Less blur to show video better */
            position: relative; /* Ensure it's above video */
            z-index: 1; /* Above video */
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: scale(0.9) translateY(-20px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            border-bottom: 1px solid rgba(0, 200, 255, 0.3); /* Softer border */
            padding-bottom: 18px;
        }

        .modal-header h3 {
            color: #7dd3fc; /* Softer cyan-blue */
            margin: 0;
            font-size: 1.4em;
            font-weight: 600;
            text-shadow: 0 0 20px rgba(125, 211, 252, 0.4); /* Subtle glow */
            letter-spacing: 0.5px;
        }

        .close-btn {
            background: none;
            border: none;
            color: #ff4444;
            font-size: 2em;
            cursor: pointer;
            transition: color 0.3s ease;
            line-height: 1;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            color: #ff0000;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
        }

        /* Modal specific styling */
        .mobile-info {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border-left: 4px solid #00ff00;
        }

        .mobile-info h4 {
            color: #00ff00;
            margin: 0 0 10px 0;
            font-size: 1.1em;
        }

        .mobile-info p {
            margin: 5px 0;
            color: #ccc;
            font-size: 0.9em;
        }

        /* Enhanced difficulty modal */
        .difficulty-btn {
            display: block;
            width: 100%;
            margin: 10px 0;
            padding: 15px;
            text-align: left;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #666;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .difficulty-btn:hover {
            border-color: #00ffff;
            background: rgba(0, 255, 255, 0.1);
        }

        .difficulty-btn.active {
            border-color: #00ff00;
            background: rgba(0, 255, 0, 0.2);
        }

        .diff-name {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .diff-desc {
            font-size: 0.9em;
            color: #ccc;
            line-height: 1.3;
        }

        .difficulty-btn.active .diff-name {
            color: #00ff00;
        }

        /* Tips modal styling */
        .tips-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .tip-item {
            display: flex;
            gap: 18px;
            align-items: flex-start;
            padding: 20px; /* More padding */
            background: rgba(0, 150, 255, 0.08); /* Softer background */
            border-radius: 12px; /* More rounded */
            border-left: 3px solid rgba(0, 200, 255, 0.5); /* Softer border */
            color: #b3e5fc; /* Softer text color */
            margin-bottom: 15px;
            transition: all 0.3s ease; /* Smooth transitions */
        }
        
        .tip-item:hover {
            background: rgba(0, 150, 255, 0.12); /* Slight hover effect */
            transform: translateX(3px); /* Subtle slide */
        }

        .tip-icon {
            font-size: 1.8em;
            min-width: 35px;
            filter: drop-shadow(0 0 8px rgba(125, 211, 252, 0.5)); /* Subtle glow */
        }

        .tip-item strong {
            color: #7dd3fc; /* Softer highlight color */
            text-shadow: 0 0 10px rgba(125, 211, 252, 0.3); /* Subtle glow */
            font-weight: 600;
        }

        /* CYPHES STATS Button Styling - Softer, more appealing */
        .mission-stats-btn {
            padding: 16px 24px; /* More padding */
            background: linear-gradient(135deg, rgba(0, 200, 255, 0.25) 0%, rgba(0, 150, 255, 0.2) 100%); /* Gradient background */
            border: 2px solid rgba(0, 200, 255, 0.5); /* Softer border */
            color: #7dd3fc; /* Softer cyan */
            border-radius: 12px; /* More rounded */
            cursor: pointer;
            font-weight: 600;
            font-size: 1.05em;
            width: 170px;
            height: 55px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); /* Smooth easing */
            text-shadow: 0 0 12px rgba(125, 211, 252, 0.5); /* Softer glow */
            box-sizing: border-box;
            box-shadow: 0 4px 15px rgba(0, 200, 255, 0.2); /* Subtle shadow */
            letter-spacing: 0.5px;
        }

        .mission-stats-btn:hover {
            background: linear-gradient(135deg, rgba(0, 200, 255, 0.35) 0%, rgba(0, 150, 255, 0.3) 100%);
            box-shadow: 0 6px 25px rgba(0, 200, 255, 0.4), 0 0 30px rgba(0, 200, 255, 0.3);
            transform: translateY(-3px) scale(1.02); /* Subtle lift and scale */
            text-shadow: 0 0 20px rgba(125, 211, 252, 0.8);
            border-color: rgba(0, 200, 255, 0.7);
        }
        
        .mission-stats-btn:active {
            transform: translateY(-1px) scale(0.98);
        }

        /* Leaderboard Category Button Styling */
        .leaderboard-category-btn {
            background: rgba(0, 0, 0, 0.8);
            color: #ffffff;
            border: 2px solid #444;
            padding: 8px 15px;
            margin: 5px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9em;
            cursor: pointer;
            border-radius: 20px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            font-weight: bold;
        }

        .leaderboard-category-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #ff3333;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 51, 51, 0.3);
        }

        .leaderboard-category-btn.active {
            background: linear-gradient(45deg, #ff3333, #ff6666);
            color: #ffffff;
            border-color: #ff3333;
            box-shadow: 0 0 20px rgba(255, 51, 51, 0.5);
        }

        /* Leaderboard Entry Styling */
        .leaderboard-entry {
            display: grid;
            grid-template-columns: 60px 1fr 120px 120px;
            padding: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background 0.3s ease;
        }

        .leaderboard-entry:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .leaderboard-entry.current-user {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
        }

        .leaderboard-entry.rank-1 {
            background: linear-gradient(90deg, rgba(255, 215, 0, 0.2), rgba(255, 215, 0, 0.05));
            border-left: 4px solid #ffd700;
        }

        .leaderboard-entry.rank-2 {
            background: linear-gradient(90deg, rgba(192, 192, 192, 0.2), rgba(192, 192, 192, 0.05));
            border-left: 4px solid #c0c0c0;
        }

        .leaderboard-entry.rank-3 {
            background: linear-gradient(90deg, rgba(205, 127, 50, 0.2), rgba(205, 127, 50, 0.05));
            border-left: 4px solid #cd7f32;
        }

        .rank-medal {
            font-size: 1.2em;
            font-weight: bold;
        }

        .rank-1 .rank-medal { color: #ffd700; }
        .rank-2 .rank-medal { color: #c0c0c0; }
        .rank-3 .rank-medal { color: #cd7f32; }

        #start-button {
            background: linear-gradient(45deg, rgba(0, 255, 255, 0.3), rgba(0, 153, 255, 0.4), rgba(0, 255, 255, 0.3));
            background-size: 200% 200%;
            color: #ffffff;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 
                0 0 20px rgba(0, 255, 255, 0.6),
                inset 0 2px 0 rgba(255, 255, 255, 0.3);
            border: 2px solid #00ffff;
            animation: hyperspacePulse 2s ease-in-out infinite alternate;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }
        
        @keyframes hyperspacePulse {
            0% { 
                background-position: 0% 50%;
                box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
            }
            100% { 
                background-position: 100% 50%;
                box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
            }
        }
        
        #start-button:hover {
            background: linear-gradient(45deg, rgba(0, 255, 255, 0.6), rgba(255, 255, 255, 0.4), rgba(0, 255, 255, 0.6));
            transform: scale(1.05);
            box-shadow: 
                0 0 40px rgba(0, 255, 255, 0.8),
                inset 0 2px 0 rgba(255, 255, 255, 0.5);
        }

        #restart-button {
            background-color: #ff00ff; /* Neon Magenta */
            color: #0a0a0a;
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
            margin-top: 20px;
        }
         #restart-button:hover {
            background-color: #cc00cc;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.7);
         }

         /* Footer styles */
         .game-footer {
             position: absolute;
             bottom: 0;
             left: 0;
             width: 100%;
             /* Reduced padding to decrease size */
             padding: 4px 20px; /* Reduced padding, added horizontal padding */
             background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent dark background */
             color: #00ffff; /* Neon Aqua text */
             font-family: 'Orbitron', sans-serif;
             font-size: 0.7em;
             /* Changed to flexbox for alignment */
             display: flex; /* Use flexbox */
             justify-content: space-between; /* Space between copyright and social links */
             align-items: center; /* Vertically center items */
             z-index: 10; /* Above canvas, below overlays */
             box-sizing: border-box; /* Include padding in width */
         }

         .copyright {
             margin-bottom: 0;
         }

         .social-links-container {
             display: flex; /* Use flexbox to arrange icons horizontally */
             gap: 10px; /* Reduced space between icons */
             align-items: center; /* Vertically center icons */
         }

         .social-link {
             color: #00ffff; /* Neon Aqua for link */
             text-decoration: none;
             text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
             transition: color 0.3s ease, text-shadow 0.3s ease;
             display: flex; /* Use flex to center SVG within link */
             justify-content: center;
             align-items: center;
         }

         .social-link:hover {
             color: #ffffff; /* White on hover */
             text-shadow: 0 0 8px rgba(255, 255, 255, 0.7);
         }

         .social-link svg {
             width: 18px; /* Reduced icon size */
             height: 18px; /* Reduced icon size */
             fill: currentColor; /* Use the link's text color for the icon fill */
         }

         /* Social Media Section in Modals */
         .social-media-section {
             margin-top: 20px;
             padding-top: 15px;
             border-top: 1px solid rgba(0, 255, 255, 0.3);
             text-align: center;
         }

         .social-title {
             font-family: 'Orbitron', sans-serif;
             font-size: 0.9em;
             color: #00ffff;
             margin-bottom: 15px;
             text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
         }

         .social-icons {
             display: flex;
             justify-content: center;
             gap: 20px;
             flex-wrap: wrap;
         }

         .social-icons .social-link {
             display: flex;
             align-items: center;
             gap: 8px;
             padding: 8px 12px;
             background: rgba(0, 255, 255, 0.1);
             border: 1px solid rgba(0, 255, 255, 0.3);
             border-radius: 15px;
             transition: all 0.3s ease;
             text-decoration: none;
             color: #00ffff;
             font-family: 'Orbitron', sans-serif;
             font-size: 0.85em;
         }

         .social-icons .social-link:hover {
             background: rgba(0, 255, 255, 0.2);
             border-color: #00ffff;
             transform: translateY(-2px);
             box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3);
         }

         .social-icon {
             font-size: 1.2em;
         }

         .social-text {
             font-weight: 500;
         }


        /* Top Header */
        #game-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            width: 100%;
            padding: 15px 20px;
            background: transparent;
            text-align: center;
            z-index: 100;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 1.2em;
            color: #00ffff;
            text-shadow: 2px 2px #000, 0 0 10px rgba(0, 255, 255, 0.5);
            letter-spacing: 0.1em;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #game-header .header-link {
            color: #00ffff;
            text-decoration: none;
            font-size: 0.9em;
            padding: 8px 16px;
            border: 1px solid rgba(0, 255, 255, 0.5);
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        #game-header .header-link:hover {
            background: rgba(0, 255, 255, 0.2);
            border-color: #00ffff;
        }

        /* CHAT link: top of page/header, green outline for visibility */
        .chat-link {
            position: fixed !important;
            top: 14px !important;
            right: 32px !important;
            left: auto !important;
            border: 2px solid #22c55e !important;
            color: #22c55e !important;
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.5);
        }
        .chat-link:hover {
            border-color: #4ade80 !important;
            color: #4ade80 !important;
            background: rgba(34, 197, 94, 0.15) !important;
        }

        @media (max-width: 768px) {
            #game-header {
                font-size: 0.9em;
                padding: 12px 15px;
            }
            #game-header .header-link {
                font-size: 0.7em;
                padding: 6px 12px;
            }
            .chat-link {
                top: 12px !important;
                right: 28px !important;
            }
            .intro-presents {
                font-size: 4vw !important;
                top: 15% !important;
            }
        }

        /* Game UI elements */
        #score {
            position: absolute;
            top: 70px;
            right: 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.9em;
            color: #00ffff;
            text-shadow: 2px 2px #000, 0 0 10px rgba(0, 255, 255, 0.5);
            z-index: 10;
        }
        
        #combo-display {
            position: absolute;
            top: 130px;
            right: 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7em;
            color: #ffd700;
            text-shadow: 2px 2px #000, 0 0 15px rgba(255, 215, 0, 0.8);
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease;
            animation: comboPulse 0.5s ease-out;
        }
        
        #combo-display.active {
            opacity: 1;
        }
        
        @keyframes comboPulse {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
           FLOATING SCORE TEXT - DOPAMINE FEEDBACK SYSTEM
           ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        .floating-score {
            position: fixed;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            pointer-events: none;
            z-index: 1000;
            text-shadow: 
                0 0 10px currentColor,
                0 0 20px currentColor,
                0 0 30px currentColor,
                2px 2px 4px rgba(0,0,0,0.8);
            animation: floatUp 1.2s ease-out forwards;
            white-space: nowrap;
        }
        
        .floating-score.coin-1 {
            font-size: 2.5em;
            color: #00ffff;
        }
        
        .floating-score.coin-combo {
            font-size: 3em;
            color: #ffd700;
        }
        
        .floating-score.coin-gold {
            font-size: 4em;
            color: #ff6600;
            animation: floatUpGold 1.5s ease-out forwards;
        }
        
        .floating-score.celebration {
            font-size: 3.5em;
            color: #ff00ff;
            animation: floatUpCelebrate 1.5s ease-out forwards;
        }
        
        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0) scale(0.5);
            }
            20% {
                transform: translateY(-20px) scale(1.3);
            }
            100% {
                opacity: 0;
                transform: translateY(-120px) scale(0.8);
            }
        }
        
        @keyframes floatUpGold {
            0% {
                opacity: 1;
                transform: translateY(0) scale(0.3) rotate(-10deg);
            }
            30% {
                transform: translateY(-30px) scale(1.5) rotate(5deg);
            }
            60% {
                transform: translateY(-80px) scale(1.2) rotate(-3deg);
            }
            100% {
                opacity: 0;
                transform: translateY(-150px) scale(0.6) rotate(0deg);
            }
        }
        
        @keyframes floatUpCelebrate {
            0% {
                opacity: 1;
                transform: translateY(0) scale(0.2) rotate(-15deg);
            }
            25% {
                transform: translateY(-25px) scale(1.6) rotate(10deg);
            }
            50% {
                transform: translateY(-60px) scale(1.3) rotate(-5deg);
            }
            100% {
                opacity: 0;
                transform: translateY(-180px) scale(0.5) rotate(0deg);
            }
        }
        
        /* Penguin skin unlock notification */
        .skin-unlock-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(50,0,80,0.95));
            border: 3px solid #ffd700;
            border-radius: 20px;
            padding: 30px 50px;
            z-index: 2000;
            text-align: center;
            animation: skinUnlockPop 3s ease-out forwards;
            box-shadow: 0 0 50px rgba(255,215,0,0.5), inset 0 0 30px rgba(255,215,0,0.1);
        }
        
        .skin-unlock-notification h2 {
            font-family: 'Orbitron', sans-serif;
            color: #ffd700;
            font-size: 2em;
            margin: 0 0 15px 0;
            text-shadow: 0 0 20px #ffd700;
        }
        
        .skin-unlock-notification p {
            font-family: 'Orbitron', sans-serif;
            color: #00ffff;
            font-size: 1.2em;
            margin: 0;
        }
        
        @keyframes skinUnlockPop {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.3); }
            15% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            25% { transform: translate(-50%, -50%) scale(1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }

        #jackpot {
             position: absolute;
             top: 20px;
             left: 20px;
             font-family: 'Press Start 2P', cursive;
             font-size: 0.8em;
             color: #ffffff;
             text-shadow: 2px 2px #000, 0 0 10px rgba(0, 255, 255, 0.7), 0 0 20px rgba(0, 255, 255, 0.5);
             z-index: 10;
             display: flex;
             flex-direction: column;
             align-items: flex-start;
        }

        #jackpot .game-demo-tag {
             font-size: 0.5em;
             color: #ff00ff;
             text-shadow: none;
             margin-top: 5px;
        }

        #jackpot-amount {
            color: #ffff00;
            text-shadow: 2px 2px #000, 0 0 10px rgba(255, 255, 0, 0.7), 0 0 20px rgba(255, 255, 0, 0.5);
            margin-top: 5px;
        }

        #wallet-container {
            margin-top: 10px;
        }

        #wallet-display {
            margin-top: 10px;
            font-size: 0.625em;
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
            word-break: break-all;
            max-width: 300px;
        }

        #wallet-balance {
            margin-top: 5px;
            font-size: 0.625em;
            color: #ffff00;
            text-shadow: 0 0 5px #ffff00;
        }

        #solscan-link {
            margin-top: 5px;
            font-size: 0.625em;
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
            text-decoration: none;
            display: block;
        }

        #solscan-link:hover {
            text-shadow: 0 0 10px #00ffff;
        }

        .animated-pop {
            animation: pop 0.3s ease-out;
        }

        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        #level-display {
            position: absolute;
            top: 90px;
            right: 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.9em;
            color: #ffff00;
            text-shadow: 2px 2px #000, 0 0 10px rgba(255, 255, 0, 0.5);
            z-index: 10;
        }

        #dialogue-box {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7em;
            background-color: rgba(0, 0, 0, 0.7);
            color: #00ffff;
            padding: 10px 15px;
            border: 2px solid #00ffff;
            border-radius: 10px;
            z-index: 15;
            max-width: 80%;
            text-align: center;
            display: none;
            pointer-events: none;
        }

        #boost-button {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Press Start 2P', cursive;
            font-size: 0.32em;
            padding: 10px 15px;
            background-color: #ff00ff;
            color: #0a0a0a;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 10;
            text-transform: uppercase;
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
            transition: background-color 0.3s ease;
        }
        #boost-button:hover:not(:disabled) {
            background-color: #cc00cc;
        }
         #boost-button:disabled {
            background-color: #555555;
            cursor: not-allowed;
            box-shadow: none;
         }

         #blaster-button {
            position: absolute;
            bottom: 20px;
            left: calc(50% + 120px);
            transform: translateX(-50%);
            font-family: 'Press Start 2P', cursive;
            font-size: 0.32em;
            padding: 10px 15px;
            background-color: #0066ff;
            color: #ffffff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 10;
            text-transform: uppercase;
            box-shadow: 0 0 10px rgba(0, 102, 255, 0.5);
            transition: background-color 0.3s ease;
         }

         #blaster-button:hover:not(:disabled) {
            background-color: #0044cc;
            box-shadow: 0 0 15px rgba(0, 102, 255, 0.8);
         }

         #blaster-button:disabled {
            background-color: #555555;
            cursor: not-allowed;
            box-shadow: none;
         }

         #mini-boost-button {
            position: absolute;
            bottom: 20px;
            left: calc(50% - 120px);
            transform: translateX(-50%);
            font-family: 'Press Start 2P', cursive;
            font-size: 0.32em;
            padding: 10px 15px;
            background-color: #00ff00;
            color: #000000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 10;
            text-transform: uppercase;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            transition: background-color 0.3s ease;
         }

         #mini-boost-button:hover:not(:disabled) {
            background-color: #00cc00;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.8);
         }



         #mini-boost-button:disabled {
            background-color: #555555;
            cursor: not-allowed;
            box-shadow: none;
         }

         #lightning-flash {
             position: absolute;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             background-color: rgba(255, 255, 255, 0.8);
             z-index: 30;
             pointer-events: none;
             display: none;
         }

         #level-up-popup {
             position: absolute;
             top: 10%;
             left: 50%;
             transform: translateX(-50%);
             font-family: 'Orbitron', sans-serif;
             font-size: clamp(2.3rem, 5.75vw, 4.6rem);
             font-weight: 900;
             color: #ffff00;
             text-shadow: 
                 0 0 20px #ff6600,
                 0 0 40px #ff6600,
                 0 0 60px #ff3300,
                 0 0 80px #ff3300,
                 0 0 100px rgba(255, 51, 0, 0.5);
             z-index: 25;
             display: none;
             text-align: center;
             line-height: 1.1;
             max-width: min(95vw, 800px);
             padding: 0 20px;
             animation: levelUpFlash 0.8s ease-out forwards;
         }

         @keyframes levelUpFlash {
             0% { 
                 transform: translateX(-50%) scale(0.8);
                 opacity: 0;
             }
             20% {
                 transform: translateX(-50%) scale(1.1);
                 opacity: 1;
             }
             80% {
                 transform: translateX(-50%) scale(1);
                 opacity: 1;
             }
             100% {
                 transform: translateX(-50%) scale(0.9);
                 opacity: 0;
             }
         }

        .mobile-controls {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none; /* Start hidden, will be shown by JS on mobile */
            z-index: 1001;
            pointer-events: none;
            box-sizing: border-box;
        }

        .steer-controls {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 10px;
            pointer-events: none;
        }
        
        .steer-controls button {
            pointer-events: auto;
        }

        .action-controls {
            position: absolute;
            bottom: 30px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            pointer-events: none;
        }
        
        .action-controls button {
            pointer-events: auto;
        }

        .mobile-controls button {
            width: 70px;
            height: 70px;
            font-size: 1.1em;
            background-color: rgba(0, 0, 0, 0.6);
            color: #ffffff;
            border: 3px solid #00ffff;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            transition: all 0.2s ease;
            font-family: 'Press Start 2P', cursive;
            font-weight: bold;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.6);
            pointer-events: auto;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
        }
        
        /* Navigation arrows - positioned middle left and right */
        #steer-left-button {
            width: 65px;
            height: 65px;
            font-size: 1.8em;
        }
        
        #steer-right-button {
            width: 65px;
            height: 65px;
            font-size: 1.8em;
        }

        /* Jump button - 35% smaller, bottom right */
        #jump-button {
            width: 58px;
            height: 58px;
            background-color: rgba(0, 150, 255, 0.6);
            border-color: #ffffff;
            font-size: 0.55em;
        }

        /* Use button - 35% smaller, bottom left */
        #use-power-up-button-mobile {
            width: 45px;
            height: 45px;
            background-color: rgba(255, 0, 100, 0.6);
            border-color: #ff00ff;
            font-size: 0.5em;
            display: none; /* Only show when power-up available */
        }

         .mobile-controls button:hover {
             background-color: rgba(0, 255, 255, 0.4);
             border-color: #ffff00;
             box-shadow: 0 0 25px rgba(0, 255, 255, 0.9);
         }

         .mobile-controls button:active,
         .mobile-controls button.active {
             background-color: rgba(0, 255, 255, 0.6);
             transform: scale(0.95);
             border-color: #ffff00;
             box-shadow: 0 0 30px rgba(0, 255, 255, 1);
         }

         .mobile-controls button:disabled {
             background-color: rgba(85, 85, 85, 0.5);
             border-color: #555555;
             color: #666;
             cursor: not-allowed;
             box-shadow: none;
         }

         /* Hide mobile controls on desktop */
         @media (min-width: 768px) {
             .mobile-controls {
                 display: none !important;
             }
         }

         #use-power-up-button {
             position: fixed;
             bottom: 30px;
             left: 50%;
             transform: translateX(-50%);
             width: 140px;
             height: 70px;
             font-size: 1em;
             background-color: rgba(255, 0, 100, 0.8);
             color: #ffffff;
             padding: 10px 15px;
             border: 3px solid #ff00ff;
             border-radius: 15px;
             display: none;
             justify-content: center;
             align-items: center;
             cursor: pointer;
             z-index: 1001;
             font-family: 'Press Start 2P', cursive;
             text-align: center;
             line-height: 1.2;
             box-sizing: border-box;
             transition: all 0.2s ease;
             font-weight: bold;
             text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
             box-shadow: 0 0 15px rgba(255, 0, 255, 0.6);
             touch-action: manipulation;
             user-select: none;
             -webkit-user-select: none;
         }

         #use-power-up-button:hover {
             background-color: rgba(255, 0, 100, 1);
             border-color: #ffff00;
             box-shadow: 0 0 20px rgba(255, 0, 255, 0.8);
         }

         #use-power-up-button:active {
             background-color: rgba(255, 0, 100, 1);
             transform: scale(0.9);
             border-color: #ffff00;
             box-shadow: 0 0 25px rgba(255, 0, 255, 1);
         }

         #use-power-up-button:disabled {
             background-color: rgba(85, 85, 85, 0.5);
             border-color: #555555;
             color: #b0b0b0;
             cursor: not-allowed;
             box-shadow: none;
         }

         /* Removed welcome-message styles */

         #power-up-display {
             position: absolute;
             top: 60px;
             right: 20px;
             font-family: 'Press Start 2P', cursive;
             font-size: 0.8em;
             color: #00ff00;
             text-shadow: 0 0 5px #00ff00, 0 0 15px #00ff00;
             z-index: 10;
             display: none;
        }

        /* Settings Menu */
        #settings-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.6em;
            color: #00ffff;
            z-index: 100;
            display: none;
            min-width: 400px;
            max-height: 90vh;
            overflow-y: auto;
        }

        #settings-menu h2 {
            text-align: center;
            margin-bottom: 20px;
            color: #ffff00;
            text-shadow: 0 0 10px #ffff00;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 5px;
        }

        .setting-label {
            color: #ffffff;
            min-width: 120px;
        }

        .setting-value {
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
            min-width: 100px;
            text-align: right;
        }

        .setting-controls {
            font-size: 0.5em;
            color: #888888;
            margin-top: 20px;
            line-height: 1.5;
        }

        #social-display {
            position: absolute;
            bottom: 4px;
            right: 20px;
            font-family: 'Inter', sans-serif;
            font-size: 0.8em;
            z-index: 15;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 12px 16px;
            border-radius: 8px;
            display: block;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }

        #social-display a {
            transition: all 0.3s ease;
        }

        #social-display a:hover {
            transform: translateY(-2px);
            text-shadow: 0 0 10px currentColor;
        }

        #pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 50;
            font-family: 'Press Start 2P', cursive;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff;
            font-size: 2em;
        }

        #pause-overlay .pause-text {
            animation: pulse 2s infinite;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0;
            padding: 0;
        }

        @keyframes pausePulse {
            0% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.7; transform: scale(1); }
        }

        @keyframes powerUpPulse {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 0.8; }
        }

        @keyframes powerUpGlow {
            0% { filter: drop-shadow(0 0 5px currentColor); }
            50% { filter: drop-shadow(0 0 15px currentColor); }
            100% { filter: drop-shadow(0 0 5px currentColor); }
        }

        .power-up-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            margin: 5px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
            font-size: 24px;
            animation: powerUpPulse 1.5s infinite, powerUpGlow 2s infinite;
            transition: all 0.3s ease;
        }

        .power-up-icon:hover {
            transform: scale(1.1);
        }

        .power-up-container {
            position: absolute;
            top: 100px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }

        .power-up-row {
            display: flex;
            gap: 5px;
        }



        .share-button {
            background-color: #1DA1F2;
            color: white;
            border: none;
            border-radius: 20px;
            padding: 10px 20px;
            margin-top: 15px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7em;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background-color 0.3s ease;
        }

        .share-button:hover {
            background-color: #1991db;
        }

        .share-button svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        /* --- UI/UX POLISH ANIMATIONS --- */
        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.25); }
            100% { transform: scale(1); }
        }
        @keyframes flash {
            0% { background-color: rgba(255,255,0,0.3); }
            100% { background-color: transparent; }
        }
        @keyframes pulse-glow {
            0% { box-shadow: 0 0 0px #00ff00; }
            50% { box-shadow: 0 0 20px #00ff00; }
            100% { box-shadow: 0 0 0px #00ff00; }
        }
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-4px); }
            50% { transform: translateX(4px); }
            75% { transform: translateX(-4px); }
            100% { transform: translateX(0); }
        }
        .animated-pop { animation: pop 0.3s; }
        .animated-flash { animation: flash 0.4s; }
        .animated-pulse { animation: pulse-glow 0.8s; }
        .animated-shake { animation: shake 0.3s; }

        /* --- CSS for the Particle Background --- */
        #particle-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 25; /* Below overlays (z-index: 50), above main canvas (z-index: 1) */
            pointer-events: none;
            display: none; /* Only show when overlays are visible */
        }
    </style>
</head>
<body>
    <!-- Background Video Layer - REMOVED CYPHES.mp4 -->
    <!-- Video Overlay - REMOVED -->
    
    <!-- Single landing screen: intro video + setup (like planetx ‚Äì one page, click Play Game or use Bot/Agent) -->
    <div id="cinematic-intro" class="overlay">
        <video id="intro-background-video" autoplay muted loop playsinline style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: -2; opacity: 0.85;">
            <source src="Penchase.mp4" type="video/mp4">
            Your browser does not support the video tag.
        </video>
        <div id="intro-video-overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; pointer-events: none;"></div>
        <canvas id="intro-particles" style="position: absolute; top: 0; left: 0; z-index: 0; pointer-events: none;"></canvas>
        <div class="intro-presents" style="position: relative; z-index: 2; font-family: 'Orbitron', sans-serif; font-size: 2.5vw; font-weight: 700; color: rgba(255, 255, 255, 0.95); text-shadow: 0 0 20px rgba(0, 180, 216, 0.8); letter-spacing: 0.2em; text-transform: uppercase; margin-bottom: 0.5em;">Why.com Presents</div>
        <div class="intro-tagline" style="position: relative; z-index: 2; margin-bottom: 1.5em;">RACE THROUGH THE FROZEN WILD</div>
        <div class="main-buttons" style="position: relative; z-index: 2;">
            <button id="wagmi-button" class="start-btn main-btn">üêª‚Äç‚ùÑÔ∏è Play Game üêª‚Äç‚ùÑÔ∏è</button>
            <button id="planet-x-button" class="start-btn main-btn">ü§ñ Agent Mode</button>
            <a id="join-chat-link" href="chat.html" class="start-btn main-btn">üí¨ JOIN CHAT</a>
        </div>
        <div class="menu-buttons" style="position: relative; z-index: 2; margin-top: 1em;">
            <button class="menu-btn" id="difficulty-btn">‚ö° Difficulty</button>
            <button class="menu-btn" id="controls-btn">üéÆ Controls</button>
            <button class="menu-btn" id="tips-btn">üí° Tips</button>
        </div>
        <div id="intro-countdown" style="display: none;"></div>
    </div>

    <!-- Agent Mode: single modal = connect form + link to full guide -->
    <div id="agent-mode-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 520px;">
            <div class="modal-header">
                <h3>ü§ñ Agent Mode</h3>
                <button class="close-btn" type="button" onclick="closeAgentModal()">&times;</button>
            </div>
            <p style="color: #94a3b8; font-size: 0.9rem; margin-bottom: 16px;">Connect this game to your bot. Get credentials and build your strategy using the full guide.</p>
            <div id="simple-registration">
                <div class="control-item" style="margin: 15px 0;">
                    <span class="key">Agent ID</span>
                    <input type="text" id="agent-id" placeholder="Enter agent identifier" style="background: rgba(0,0,0,0.5); border: 1px solid #00ffff; color: #00ffff; padding: 8px; border-radius: 5px; width: 200px;">
                </div>
                <div class="control-item" style="margin: 15px 0;">
                    <span class="key">Access Key</span>
                    <input type="password" id="agent-key" placeholder="Agent access key" style="background: rgba(0,0,0,0.5); border: 1px solid #00ffff; color: #00ffff; padding: 8px; border-radius: 5px; width: 200px;">
                </div>
                <div class="control-item" style="margin: 15px 0;">
                    <span class="key">Endpoint (Optional)</span>
                    <input type="text" id="agent-endpoint" placeholder="ws://localhost:8080" value="ws://localhost:8080" style="background: rgba(0,0,0,0.5); border: 1px solid #666; color: #00ffff; padding: 8px; border-radius: 5px; width: 200px;">
                </div>
                <button type="button" onclick="registerAgent()" class="mission-stats-btn" style="width: 100%; margin-top: 12px;">ü§ñ Connect Agent</button>
            </div>
            <div id="agent-status" style="margin-top: 20px; padding: 15px; background: rgba(0,200,255,0.1); border-radius: 10px; display: none;">
                <div style="color: #7dd3fc; font-weight: 600;"><span id="status-icon">üü°</span> <span id="status-text">Connecting...</span></div>
                <div id="agent-stats" style="margin-top: 10px; font-size: 0.9em; color: #b3e5fc;">Latency: <span id="agent-latency">--</span>ms | Actions/sec: <span id="agent-actions">--</span></div>
                <div style="margin-top: 8px; font-size: 0.8em; color: #94a3b8;">Run your bot, then click <strong>Play Game</strong> to start.</div>
            </div>
            <div style="margin-top: 24px; padding-top: 16px; border-top: 1px solid rgba(0,200,255,0.2);">
                <a href="guide.html" target="_blank" rel="noopener noreferrer" style="color: #7dd3fc; font-weight: 600; text-decoration: none; display: inline-flex; align-items: center; gap: 6px;">üìò Full setup &amp; strategy guide ‚Üí</a>
                <p style="font-size: 0.85rem; color: #94a3b8; margin-top: 6px;">Credentials, protocol, examples, deployment, GitHub &amp; community links.</p>
            </div>
        </div>
    </div>

    <!-- Agent brain viz: inputs (state we send) ‚Üí remote ‚Üí outputs (actions we receive). Shown only in Agent mode during game. -->
    <div id="brain-viz-container" style="display: none; position: fixed; bottom: 60px; left: 12px; z-index: 100; background: rgba(0,0,0,0.75); border: 1px solid rgba(0,200,255,0.4); border-radius: 8px; padding: 6px; box-shadow: 0 0 12px rgba(0,180,216,0.2);">
        <div style="font-size: 10px; color: #7dd3fc; margin-bottom: 4px;">Agent I/O</div>
        <canvas id="brain-viz" width="200" height="140" style="display: block; border-radius: 4px;"></canvas>
    </div>

    <!-- Controls Modal -->
    <div id="controls-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üéÆ Controls</h3>
                <button class="close-btn" data-modal="controls-modal">&times;</button>
            </div>
            <div class="controls-grid">
                <div class="control-item">
                    <span class="key">ARROWS</span>
                    <span class="action">Steer your panda through the arctic</span>
                </div>
                <div class="control-item">
                    <span class="key">SPACE</span>
                    <span class="action">Jump over obstacles</span>
                </div>
                <div class="control-item">
                    <span class="key">E</span>
                    <span class="action">Use power-up</span>
                </div>
                <div class="control-item">
                    <span class="key">M</span>
                    <span class="action">Toggle audio</span>
                </div>
                <div class="control-item">
                    <span class="key">P</span>
                    <span class="action">Pause game</span>
                </div>
                <div class="control-item">
                    <span class="key">‚Üë</span>
                    <span class="action">Boost (Level 5+)</span>
                </div>
                <div class="control-item">
                    <span class="key">S</span>
                    <span class="action">Speed boost (+25%)</span>
                </div>
                <div class="control-item">
                    <span class="key">F</span>
                    <span class="action">Ice blast (Level 10+)</span>
                </div>
                <div class="control-item">
                    <span class="key">H</span>
                    <span class="action">Toggle headlight</span>
                </div>
                <div class="control-item">
                    <span class="key">B</span>
                    <span class="action">Brakes (-50% speed, once per run)</span>
                </div>
            </div>
            <div class="mobile-info">
                <h4>üì± Mobile Controls</h4>
                <p>‚Ä¢ Touch buttons for steering</p>
                <p>‚Ä¢ Swipe left/right to steer</p>
                <p>‚Ä¢ Dedicated power-up button</p>
            </div>
        </div>
    </div>

    <!-- Difficulty Modal -->
    <div id="difficulty-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>‚ö° Difficulty Selection</h3>
                <button class="close-btn" data-modal="difficulty-modal">&times;</button>
            </div>
            <div class="difficulty-options">
                <button class="difficulty-btn active" data-difficulty="normal">
                    <div class="diff-name">Normal</div>
                    <div class="diff-desc">Balanced gameplay for all heroes</div>
                </button>
                <button class="difficulty-btn" data-difficulty="hard">
                    <div class="diff-name">Hard</div>
                    <div class="diff-desc">50% faster criminals, less margin for error</div>
                </button>
                <button class="difficulty-btn" data-difficulty="insane">
                    <div class="diff-name">Insane</div>
                    <div class="diff-desc">Double-speed chaos, only for Fair Play Masters</div>
                </button>
            </div>
        </div>
    </div>

    <!-- Tips Modal -->
    <div id="tips-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üêª‚Äç‚ùÑÔ∏è whyARCADE Guide</h3>
                <button class="close-btn" data-modal="tips-modal">&times;</button>
            </div>
            <div class="tips-content">
                <div class="tip-item">
                    <span class="tip-icon">üéØ</span>
                    <div>
                        <strong>Objective:</strong><br>
                        Race through the frozen arctic and collect as many silver coins as possible!
                    </div>
                </div>
                <div class="tip-item">
                    <span class="tip-icon">ü™ô</span>
                    <div>
                        <strong>Silver Coins:</strong><br>
                        Collect bright silver coins for +1 point each. They're everywhere - grab them all!
                    </div>
                </div>
                <div class="tip-item">
                    <span class="tip-icon">‚≠ê</span>
                    <div>
                        <strong>Gold Coins (Rare!):</strong><br>
                        Find rare golden coins for +100 points and a 5-second speed boost!
                    </div>
                </div>
                <div class="tip-item">
                    <span class="tip-icon">‚ùÑÔ∏è</span>
                    <div>
                        <strong>Arctic Hazards:</strong><br>
                        Avoid ice obstacles and navigate around towering icebergs!
                    </div>
                </div>
                <div class="tip-item">
                    <span class="tip-icon">üêª‚Äç‚ùÑÔ∏è</span>
                    <div>
                        <strong>Your Polar Bear:</strong><br>
                        You're a mighty polar bear racing through the frozen arctic! Feel the THRILL of 75% faster speed!
                    </div>
                </div>
                <div class="tip-item">
                    <span class="tip-icon">üéµ</span>
                    <div>
                        <strong>Audio Control:</strong><br>
                        Press 'M' anytime to toggle immersive arctic sounds.
                    </div>
                </div>
                <div class="tip-item">
                    <span class="tip-icon">‚ö°</span>
                    <div>
                        <strong>Speed Boost:</strong><br>
                        Use 'S' for speed boost (+25%). Collect gold coins for extra boosts!
                    </div>
                </div>
                <div class="tip-item">
                    <span class="tip-icon">üõë</span>
                    <div>
                        <strong>Brakes:</strong><br>
                        Press 'B' to reduce speed by 50%. One-time use per run!
                    </div>
                </div>
                <div class="tip-item">
                    <span class="tip-icon">üî¶</span>
                    <div>
                        <strong>Headlight:</strong><br>
                        Press 'H' to activate headlight for better visibility in blizzards!
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="game-over-screen" class="modal-overlay" style="display: none;">
        <!-- Background Video for Stats Screen -->
        <video id="stats-background-video" autoplay muted loop playsinline>
            <source src="Penchase.mp4" type="video/mp4">
            Your browser does not support the video tag.
        </video>
        
        <div class="modal-content">
            <div class="modal-header">
                <h3 style="font-size: 1.6em;">üêª‚Äç‚ùÑÔ∏è whyARCADE STATS üêª‚Äç‚ùÑÔ∏è</h3>
            </div>
            
            <!-- Mission Stats Section -->
            <div class="tips-content">
                <div class="tip-item">
                    <div>
                        <div class="controls-grid" style="margin-top: 20px; gap: 18px; display: flex; justify-content: space-between;">
                            <div class="control-item" style="padding: 16px; font-size: 1.15em; border: 2px solid rgba(0, 200, 255, 0.4); background: rgba(0, 150, 255, 0.12); flex: 1; margin-right: 10px;">
                                <span class="key" style="font-size: 1.05em; padding: 6px 12px;">ü™ô Total Coins</span>
                                <span class="action" id="stat-total-swag" style="font-size: 1.4em; font-weight: 700; color: #7dd3fc; text-shadow: 0 0 15px rgba(125, 211, 252, 0.5);">0</span>
                            </div>
                            <div class="control-item" style="padding: 16px; font-size: 1.15em; border: 2px solid rgba(0, 255, 0, 0.4); background: rgba(0, 255, 0, 0.12); flex: 1; margin-left: 10px; display: flex; align-items: center; justify-content: center; animation: chatPulse 2s ease-in-out infinite;">
                                <a href="https://why.com/chat" target="_blank" style="color: #00ff00; text-decoration: none; display: flex; align-items: center; gap: 8px; font-size: 1.1em;">
                                    <span style="font-size: 1.5em;">üí¨</span>
                                    <span style="font-weight: bold;">CHAT</span>
                                </a>
                            </div>
                            <style>
                                @keyframes chatPulse {
                                    0%, 100% {
                                        box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
                                        transform: scale(1);
                                    }
                                    50% {
                                        box-shadow: 0 0 25px rgba(0, 255, 0, 0.8), 0 0 40px rgba(0, 255, 0, 0.5);
                                        transform: scale(1.05);
                                    }
                                }
                            </style>
                        </div>
                        <div style="margin-top: 15px; text-align: center;">
                            <!-- Arctic Panda Progress -->
                            <div class="control-item" style="padding: 20px; font-size: 1.1em; background: rgba(0, 150, 255, 0.12); border: 2px solid rgba(0, 200, 255, 0.4); border-radius: 12px;">
                                <div style="text-align: center; color: #7dd3fc; font-size: 1.05em; font-family: 'Orbitron', sans-serif; margin-bottom: 15px; text-shadow: 0 0 12px rgba(125, 211, 252, 0.4); font-weight: 600;">
                                    üêº GLOBAL PANDA COINS
                                </div>
                                <div id="mission-progress-bar" style="width: 100%; height: 28px; background: rgba(0, 50, 100, 0.4); border-radius: 14px; overflow: hidden; position: relative; margin-bottom: 12px; border: 1px solid rgba(0, 200, 255, 0.2);">
                                    <div id="mission-progress-fill" style="height: 100%; background: linear-gradient(90deg, rgba(0, 200, 255, 0.8), rgba(255, 215, 0, 0.9)); width: 0%; transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1); border-radius: 14px; box-shadow: 0 0 20px rgba(0, 200, 255, 0.5);"></div>
                                </div>
                                <div id="mission-progress-text" style="text-align: center; color: #b3e5fc; font-size: 1em; font-family: 'Orbitron', sans-serif; font-weight: 600; text-shadow: 0 0 10px rgba(179, 229, 252, 0.3);">
                                    Global: 0 / 1,000,000,000 Coins
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="tip-item">
                    <span class="tip-icon" style="font-size: 2em;">üèÜ</span>
                    <div style="display: flex; align-items: flex-start; gap: 30px;">
                        <div style="flex: 1;">
                            <strong style="font-size: 1.3em; color: #7dd3fc; text-shadow: 0 0 12px rgba(125, 211, 252, 0.4); font-weight: 600;">Final Results</strong><br>
                            <div style="margin-top: 18px;">
                                <p id="final-score" style="margin: 12px 0; color: #7dd3fc; font-size: 1.25em; font-weight: 700; text-shadow: 0 0 15px rgba(125, 211, 252, 0.5);">Final Coins: 0</p>
                                <p id="final-level" style="margin: 12px 0; color: #ffa726; font-size: 1.25em; font-weight: 700; text-shadow: 0 0 15px rgba(255, 167, 38, 0.5);">ICEBERG Reached: 1</p>

                            </div>
                        </div>
                        <!-- Action Buttons Column -->
                        <div style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                            <!-- Buttons Row -->
                            <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap; justify-content: center;">
                                <button id="restart-button" class="mission-stats-btn">üöÄ New Mission</button>
                            </div>

                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="jackpot">
                            <span style="color: #ffffff;">whyARCADE</span> <span class="game-demo-tag">(beta)</span>
        <div id="jackpot-amount">Jackpot: 1.06 SOL</div>
        <div id="wallet-container">
            <div id="wallet-display"></div>
            <div id="wallet-balance"></div>
            <a id="solscan-link" href="#" target="_blank" rel="noopener noreferrer"></a>
        </div>
    </div>

    <div id="game-header">
        <div style="width: 80px;"></div>
        <a href="chat.html" class="header-link chat-link">CHAT</a>
    </div>
                <div id="score">Coins: 0</div>
    <div id="level-display">ICEBERG: 1</div>
    <div id="combo-display"></div>
    <div id="dialogue-box"></div>
                <button id="boost-button">BLAST</button>
            <button id="blaster-button">VIBES</button>
    <button id="mini-boost-button">BOOST</button>
    <div id="lightning-flash"></div>
    <div id="level-up-popup">LEVEL UP!</div>
    <div class="mobile-controls">
        <!-- Steering arrows in the middle left/right -->
        <div class="steer-controls">
            <button id="steer-left-button">‚Üê</button>
            <button id="steer-right-button">‚Üí</button>
        </div>
        <!-- Action buttons: USE bottom-left, JUMP bottom-right -->
        <div class="action-controls">
            <button id="use-power-up-button-mobile">USE</button>
            <button id="jump-button">JUMP</button>
        </div>
    </div>
    
    <!-- Tap to pause overlay for mobile -->
    <div id="mobile-pause-area" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100px; height: 100px; z-index: 1000; pointer-events: auto;"></div>
    <div id="power-up-display"></div>

    <div id="settings-menu">
        <h2>Customization Settings</h2>
        
        <div class="setting-row">
            <span class="setting-label">Bike Skin:</span>
            <span class="setting-value" id="current-skin">Default</span>
        </div>
        
        <div class="setting-row">
            <span class="setting-label">Trail Effect:</span>
            <span class="setting-value" id="current-trail">Default</span>
        </div>
        
        <div class="setting-row">
            <span class="setting-label">Rider Outfit:</span>
            <span class="setting-value" id="current-outfit">Classic</span>
        </div>
        
        <!-- PENGUIN SKIN SELECTOR -->
        <div class="setting-row" style="margin-top: 15px; border-top: 1px solid #00ffff; padding-top: 15px;">
            <span class="setting-label" style="color: #ffd700;">üêß Penguin Skin:</span>
            <span class="setting-value" id="current-penguin-skin">Emperor</span>
        </div>
        <div id="penguin-skin-grid" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin: 10px 0; padding: 10px; background: rgba(0,0,0,0.5); border-radius: 8px;">
            <!-- Skins will be populated by JavaScript -->
        </div>
        
                    <div class="setting-controls">
                CONTROLS:<br/>
                [1/2] - Change Bike Skin<br/>
                [3/4] - Change Trail Effect<br/>
                [5/6] - Change Rider Outfit<br/>
                [S] - BOOST (+25% speed)<br/>
                [B] - Brakes (-50% speed, once per run)<br/>
                [F] - VIBES (Level 10+)<br/>
                [H] - Toggle Headlight<br/>
                [I] - Toggle Game Instructions<br/>
                [TAB] - Toggle Settings Menu<br/>
                [ESC] - Close Settings
            </div>
        
        <div id="game-instructions" style="display: none; margin-top: 20px; padding: 15px; background: rgba(0,0,0,0.7); border-radius: 8px; max-height: 38vh; overflow-y: scroll; overflow-x: hidden; -webkit-overflow-scrolling: touch;">
                            <h3 style="color: #00aaff; margin-top: 0;">ARCTIC PANDA - ADVENTURE GUIDE</h3>
            
            <div style="color: #ffffff; font-size: 0.85em; line-height: 1.4;">
                <p><strong style="color: #00ddff;">OBJECTIVE:</strong><br/>
                Race through the frozen arctic as a brave panda! Collect silver coins to boost your score and find rare gold coins for power-ups!</p>
                
                <p><strong style="color: #00ddff;">BASIC CONTROLS:</strong><br/>
                ‚Ä¢ Arrow Keys - Steer your panda through the arctic<br/>
                ‚Ä¢ SPACE - Jump over obstacles<br/>
                ‚Ä¢ E - Use power-up (when available)<br/>
                ‚Ä¢ ‚Üë - Speed Boost (level 5+)<br/>
                ‚Ä¢ S - Quick Boost (+25% speed)<br/>
                ‚Ä¢ B - Brakes (reduce speed by 50%, once per run)<br/>
                ‚Ä¢ F - Ice Blast (level 10+)<br/>
                ‚Ä¢ P / Tap Screen - Pause game<br/>
                ‚Ä¢ M - Toggle audio on/off<br/>
                ‚Ä¢ H - Toggle headlight</p>
                
                <p><strong style="color: #ffd700;">COIN SYSTEM:</strong><br/>
                ‚Ä¢ ü™ô Silver Coins: +1 coin each (main collectibles)<br/>
                ‚Ä¢ ‚≠ê Gold Coins: +100 coins + 5-second speed boost (RARE!)<br/>
                ‚Ä¢ Every 5 coins = next level</p>
                
                <p><strong style="color: #00ddff;">HAZARDS TO AVOID:</strong><br/>
                ‚Ä¢ Ice obstacles on the road<br/>
                ‚Ä¢ Other pandas racing past<br/>
                ‚Ä¢ Falling ice chunks<br/>
                ‚Ä¢ Slippery patches</p>
                
                <p><strong style="color: #00ddff;">SPECIAL FEATURES:</strong><br/>
                ‚Ä¢ Beautiful arctic scenery with towering icebergs<br/>
                ‚Ä¢ Black road with white snow banks<br/>
                ‚Ä¢ Dynamic snow effects<br/>
                ‚Ä¢ Collectible coin bursts<br/>
                ‚Ä¢ Real-time global leaderboards</p>
                
                <p><strong style="color: #ffd700;">GOAL:</strong> Collect as many coins as possible and see how far you can go!</p>
            </div>
        </div>
    </div>



    <div id="social-display" style="opacity: 0.6;">
        <div style="display: flex; align-items: center; gap: 15px; font-size: 0.9em;">
            <div id="lifetime-swag-display" style="color: #ff6600; font-weight: bold; display: flex; align-items: center; gap: 5px; background: rgba(255, 102, 0, 0.1); padding: 5px 10px; border-radius: 15px; border: 1px solid #ff6600;">
                <span style="font-size: 1.1em;">üî•</span>
                <span>Lifetime: <span id="lifetime-swag-value">0</span> Coins</span>
            </div>


            <a href="https://discord.gg/wTTmrqNBBs" target="_blank" style="color: #5865f2; text-decoration: none; display: flex; align-items: center; gap: 5px;">
                <span style="font-size: 1.2em;">üí¨</span>
                <span>Discord</span>
            </a>

            <a href="https://x.com/ockams" target="_blank" style="color: #1DA1F2; text-decoration: none; display: flex; align-items: center; gap: 5px;">
                <span style="font-size: 1.2em;">üê¶</span>
                <span>Twitter @ockams</span>
            </a>

            <a href="https://t.me/ockams" target="_blank" style="color: #0088cc; text-decoration: none; display: flex; align-items: center; gap: 5px;">
                <span style="font-size: 1.2em;">‚úàÔ∏è</span>
                <span>Telegram</span>
            </a>
        </div>
    </div>

    <!-- Power-up Display in Top Right -->
    <div id="power-up-display"></div>

    <div id="pause-overlay">
        <div class="pause-text">
            NORTH POLE<br/>
            <div style="font-size: 0.5em; margin-top: 20px;">
                Tap/Click to Resume
            </div>
        </div>
    </div>

    <div class="game-footer">
        <div>
            <a href="#" id="how-to-play-link" style="color: yellow; text-decoration: none; display: block; margin-bottom: 5px;">How to Play</a>
            <p class="copyright" style="margin: 0;">&copy; 2026 Ockams Inc.</p>
        </div>
    </div>






    <!-- <audio id="boost-sound" src="https://assets.mixkit.co/sfx/preview/mixkit-sci-fi-rocket-engine-1320.mp3" loop></audio> -->
    <!-- Enhanced Audio System -->
    <audio id="coin-pickup-sound" preload="auto">
        <source src="https://freesound.org/data/previews/316/316847_5260863-lq.mp3" type="audio/mpeg">
    </audio>
    <audio id="background-music" loop preload="auto">
        <source src="https://incompetech.com/music/royalty-free/mp3-royaltyfree/Arctic%20Winds.mp3" type="audio/mpeg">
    </audio>
    <audio id="bass-thump-sound" preload="auto">
        <source src="https://freesound.org/data/previews/316/316847_5260863-lq.mp3" type="audio/mpeg">
    </audio>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

    <script>
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // EARLY VARIABLE DECLARATIONS - Must be declared before any functions use them
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        let isGameRunning = false;
        let isGameOver = false;
        let gamePaused = false;

        // Mobile detection and quality flag (cyphes-style, same 5 as AAA.html)
        const isMobileDevice = () => /Android|iPhone|iPad|iPod|webOS|BlackBerry|IEMobile|Opera Mini|Mobi/i.test(navigator.userAgent) || ('ontouchstart' in window);
        const isMobile = isMobileDevice();
        const isFirefox = /Firefox|FxiOS/i.test(navigator.userAgent);
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PENGUIN SKIN SYSTEM - Must be defined early before createMotorcycle
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const penguinSkins = {
            emperor: {
                name: 'Emperor Penguin',
                unlockScore: 0,
                bodyColor: 0xf5f5f5,
                backColor: 0x1a1a1a,
                chestColor: 0xff8800,
                beakColor: 0xff8800,
                feetColor: 0xff8800,
                unlocked: true,
                description: 'Classic Emperor - ice.html exact'
            },
            rockhopper: {
                name: 'Rockhopper Penguin',
                unlockScore: 1000,
                bodyColor: 0xfafafa,
                backColor: 0x1a1a1a,
                chestColor: 0xff4444,
                beakColor: 0xff6600,
                feetColor: 0xff6699,
                unlocked: false,
                description: 'Wild & Punk - Score 1,000 to unlock!'
            },
            fairy: {
                name: 'Little Blue (Fairy) Penguin',
                unlockScore: 5000,
                bodyColor: 0xe8f4fc,
                backColor: 0x4a90d9,
                chestColor: 0xf0f8ff,
                beakColor: 0x2c3e50,
                feetColor: 0xffc0cb,
                unlocked: false,
                description: 'Smallest & Cutest - Score 5,000 to unlock!'
            },
            golden: {
                name: 'Golden Emperor',
                unlockScore: 10000,
                bodyColor: 0xffd700,
                backColor: 0xb8860b,
                chestColor: 0xffff00,
                beakColor: 0xff8c00,
                feetColor: 0xffd700,
                unlocked: false,
                description: 'Legendary Gold - Score 10,000 to unlock!'
            }
        };
        
        let currentPenguinSkin = 'emperor';
        let highestScoreEver = 0;
        
        // Load unlocked skins from localStorage (early init)
        try {
            highestScoreEver = parseInt(localStorage.getItem('penchase_highest_score') || '0');
            const savedSkins = localStorage.getItem('penchase_unlocked_skins');
            if (savedSkins) {
                const unlockedList = JSON.parse(savedSkins);
                unlockedList.forEach(skinId => {
                    if (penguinSkins[skinId]) {
                        penguinSkins[skinId].unlocked = true;
                    }
                });
            }
            const savedSkin = localStorage.getItem('penchase_selected_skin');
            if (savedSkin && penguinSkins[savedSkin] && penguinSkins[savedSkin].unlocked) {
                currentPenguinSkin = savedSkin;
            }
        } catch(e) {
            console.log('Error loading skin data:', e);
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // EPIC CINEMATIC INTRO - Snowstorm particles (OPTIMIZED)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        (function initIntroParticles() {
            const canvas = document.getElementById('intro-particles');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            let animationId = null;
            let isIntroActive = true;
            
            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            resize();
            const resizeHandler = () => resize();
            window.addEventListener('resize', resizeHandler);
            
            // OPTIMIZED: Reduced particle count for better performance
            const particles = [];
            const particleCount = 60; // Reduced from 150 to 60
            
            for (let i = 0; i < particleCount; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 2,
                    vy: Math.random() * 2 + 1,
                    size: Math.random() * 3 + 1, // Slightly smaller
                    opacity: Math.random() * 0.6 + 0.3,
                    twinkle: Math.random() * Math.PI * 2
                });
            }
            
            // OPTIMIZED: Frame rate limiting (30 FPS instead of 60)
            let lastFrameTime = 0;
            const targetFPS = 30;
            const frameInterval = 1000 / targetFPS;
            
            function animate(currentTime) {
                if (!isIntroActive) return; // Stop if intro dismissed
                
                // Frame rate limiting
                const elapsed = currentTime - lastFrameTime;
                if (elapsed < frameInterval) {
                    animationId = requestAnimationFrame(animate);
                    return;
                }
                lastFrameTime = currentTime - (elapsed % frameInterval);
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // OPTIMIZED: Simplified particle rendering (no expensive gradients)
                particles.forEach(p => {
                    p.x += p.vx + Math.sin(p.twinkle) * 0.3; // Reduced movement
                    p.y += p.vy;
                    p.twinkle += 0.015; // Slower twinkle
                    
                    // Reset particle when it goes off screen
                    if (p.y > canvas.height) {
                        p.y = -10;
                        p.x = Math.random() * canvas.width;
                    }
                    if (p.x > canvas.width) p.x = 0;
                    if (p.x < 0) p.x = canvas.width;
                    
                    // OPTIMIZED: Simple solid circles instead of expensive gradients
                    ctx.fillStyle = `rgba(255, 255, 255, ${p.opacity * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // REMOVED: Connection lines (O(n¬≤) performance killer - removed for optimization)
                
                animationId = requestAnimationFrame(animate);
            }
            animate(0);
            
            // Cleanup function
            window.cleanupIntroParticles = function() {
                isIntroActive = false;
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                window.removeEventListener('resize', resizeHandler);
                if (canvas && canvas.parentNode) {
                    canvas.parentNode.removeChild(canvas);
                }
            };
            
            // Single landing screen (like planetx): no countdown, no click-to-begin. Play Game starts the game.
            const intro = document.getElementById('cinematic-intro');
            let introTapOnce = false;
            function handleIntroTap(e) {
                if (introTapOnce) return;
                introTapOnce = true;
                var introVid = document.getElementById('intro-background-video');
                if (introVid) {
                    introVid.muted = false;
                    introVid.volume = 0.8;
                    introVid.play().catch(function() {});
                }
                if (window.__onFirstTap) window.__onFirstTap();
                try {
                    if (typeof Tone !== 'undefined' && Tone.start) Tone.start().catch(function(){});
                    else if (typeof Tone !== 'undefined' && Tone.context && Tone.context.resume) Tone.context.resume().catch(function(){});
                } catch (_) {}
                // Don't start countdown or game ‚Äì only buttons do that. Stop propagation so button clicks still work.
            }
            intro.addEventListener('click', function(e) {
                if (e.target.closest('button')) return;
                handleIntroTap(e);
            }, true);
            intro.addEventListener('touchstart', function(e) {
                if (e.target.closest('button')) return;
                e.preventDefault();
                handleIntroTap(e);
            }, { passive: false });
            
            function dismissIntro() {
                try {
                    if (typeof Tone !== 'undefined') {
                        if (Tone.start) Tone.start().then(function(){}).catch(function(){});
                        else if (Tone.context && Tone.context.resume) Tone.context.resume().then(function(){}).catch(function(){});
                    }
                } catch (e) {}
                var introVid = document.getElementById('intro-background-video');
                if (introVid) { introVid.muted = true; introVid.pause(); }
                if (window.cleanupIntroParticles) window.cleanupIntroParticles();
                const el = document.getElementById('cinematic-intro');
                if (el) {
                    el.style.display = 'none';
                    el.style.opacity = '0';
                    el.style.visibility = 'hidden';
                    el.remove();
                }
            }
            window.dismissIntro = dismissIntro;
        })();
        
        // Read URL parameters for customization
        const urlParams = new URLSearchParams(window.location.search);
        const isCustomized = urlParams.get('customized') === 'true';
        
        // Apply customizations if parameters are present
        if (isCustomized) {
            // Update title
            const gameName = urlParams.get('name') || 'Terrific Quest';
            document.title = gameName;
            const titleElement = document.getElementById('gameTitle');
            if (titleElement) titleElement.textContent = gameName;
            
            // Display custom game name instead of JEDAII
            const logoSubtitleElement = document.getElementById('logo-subtitle');
            if (logoSubtitleElement && gameName && gameName.trim() !== '') {
                logoSubtitleElement.textContent = gameName;
                logoSubtitleElement.setAttribute('data-text', gameName);
            }
            
            // Store customization parameters globally
            window.gameCustomizations = {
                name: gameName,
                theme: urlParams.get('theme') || 'cyberpunk',
                weather: urlParams.get('weather') || 'dynamic',
                starDensity: parseInt(urlParams.get('starDensity')) || 1000,
                helmetColor: parseInt(urlParams.get('helmetColor') || '00ff00', 16),
                helmetGlow: urlParams.get('helmetGlow') === 'true',
                bodyColor: parseInt(urlParams.get('bodyColor') || '000000', 16),
                bodyGlow: urlParams.get('bodyGlow') === 'true',
                bikeColor: parseInt(urlParams.get('bikeColor') || '000000', 16),
                bikeGlow: urlParams.get('bikeGlow') === 'true',
                baseSpeed: parseFloat(urlParams.get('baseSpeed')) || 0.8,
                aiCount: parseInt(urlParams.get('aiCount')) || 3,
                aiDifficulty: urlParams.get('aiDifficulty') || 'normal',
                enablePowerups: urlParams.get('enablePowerups') !== 'false',
                enableObstacles: urlParams.get('enableObstacles') !== 'false',
                enableJumping: urlParams.get('enableJumping') !== 'false',
                enableEnemies: urlParams.get('enableEnemies') !== 'false',
                gameLength: urlParams.get('gameLength') || 'medium'
            };
        }

        // Theme configurations - Updated for NYC city setting
        const themes = {
            cyberpunk: {
                backgroundColor: 0x1a1a2e, // Dark city night sky
                primaryColor: 0x00f0ff,
                accentColor: 0xff00ff,
                starColor: 0x00ffff
            },
            space: {
                backgroundColor: 0x2c3e50, // City twilight
                primaryColor: 0xffffff,
                accentColor: 0xffd60a,
                starColor: 0xffffff
            },
            neon: {
                backgroundColor: 0x16213e, // City night with neon glow
                primaryColor: 0xff0080,
                accentColor: 0x00ff80,
                starColor: 0xff80ff
            },
            matrix: {
                backgroundColor: 0x0f3460, // Deep city blue
                primaryColor: 0x00ff00,
                accentColor: 0x008000,
                starColor: 0x00ff00
            }
        };

        // Get current theme
        const currentTheme = (isCustomized && window.gameCustomizations) ? window.gameCustomizations.theme : 'cyberpunk';
        const themeConfig = themes[currentTheme] || themes.cyberpunk;

        // Set up the scene, camera, and renderer
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xfafcff);
        scene.fog = new THREE.Fog(0xfafcff, 100, 450);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000); // Increased far plane for starfield
        const renderer = new THREE.WebGLRenderer({ 
            antialias: !isMobile,
            powerPreference: isFirefox ? "default" : "high-performance",
            preserveDrawingBuffer: isFirefox
        });

        // Set renderer size and append to body
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xfafcff);
        document.body.appendChild(renderer.domElement);
        
        // Optimize renderer for better performance (mobile-aware, same 5 as AAA)
        renderer.setPixelRatio(isMobile ? 1.5 : Math.min(window.devicePixelRatio, 2));
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.78;
        
        // FPS counter variables
        let fpsFrameCount = 0;
        let fpsLastTime = performance.now();
        let currentFPS = 60;

        // Get the canvas element
        const gameCanvas = renderer.domElement;
        gameCanvas.style.zIndex = 1; // Ensure game canvas is above body background but below UI

        // Store player rider parts globally for easy access
        let playerRiderBody;
        let playerRiderHead;
        let originalRiderMaterials = {}; // To store materials during shield effect
        
        // Global neon lights for lens flares (declared early)
        let neonLight1, neonLight2, neonLight3, lightningLight;
        
        // Headlight system
        let bikeHeadlight = null;
        let bikeFloodlight = null;
        let headlightActive = false;

        // NYC City Buildings - Infinite Generation System
        let cityBuildings;
        let buildingSegments = [];
        const segmentLength = 200;
        const buildingsPerSegment = 3; // Much fewer icebergs for more immersive, less cluttered view
        
        function createCityscape() {
            cityBuildings = new THREE.Group();
            scene.add(cityBuildings);
            
            // Create initial segments
            for (let segment = 0; segment < 5; segment++) {
                createBuildingSegment(segment * segmentLength);
            }
        }
        
        function createBuildingSegment(startZ) {
            const segment = new THREE.Group();
            segment.userData.startZ = startZ;
            segment.userData.endZ = startZ - segmentLength;
            
            for (let i = 0; i < buildingsPerSegment; i++) {
                const buildingZ = startZ - (i * (segmentLength / buildingsPerSegment));
                
                // Left side icebergs - MINIMAL VISIBILITY for immersive feel
                const leftBuilding = createBuilding();
                const leftScale = 0.3 + Math.random() * 0.3; // Much smaller scale
                leftBuilding.scale.set(leftScale, leftScale, leftScale);
                leftBuilding.position.set(
                    -30 - Math.random() * 12, // Even further from road for minimal visibility
                    -2, // Lowered to ground level - no levitation gap
                    buildingZ + (Math.random() - 0.5) * 20
                );
                segment.add(leftBuilding);
                
                // Right side icebergs - MINIMAL VISIBILITY
                const rightBuilding = createBuilding();
                const rightScale = 0.3 + Math.random() * 0.3; // Much smaller scale
                rightBuilding.scale.set(rightScale, rightScale, rightScale);
                rightBuilding.position.set(
                    30 + Math.random() * 12, // Even further from road for minimal visibility
                    -2, // Lowered to ground level - no levitation gap
                    buildingZ + (Math.random() - 0.5) * 20
                );
                segment.add(rightBuilding);
            }
            
            // Ensure cityBuildings exists before adding
            if (!cityBuildings) {
                cityBuildings = new THREE.Group();
                scene.add(cityBuildings);
            }
            cityBuildings.add(segment);
            buildingSegments.push(segment);
        }
        
        // Optimized city update with reduced frequency
        let cityUpdateCounter = 0;
        function updateInfiniteCity() {
            // Only update city every 5th frame for better performance
            cityUpdateCounter++;
            if (cityUpdateCounter % 5 !== 0) return;
            
            const playerZ = playerMotorcycle.position.z;
            
            const buildingBehind = buildingSegments.length > 12 ? 50 : 100;
            for (let i = buildingSegments.length - 1; i >= 0; i--) {
                const segment = buildingSegments[i];
                if (segment.userData.endZ > playerZ + buildingBehind) {
                    cityBuildings.remove(segment);
                    buildingSegments.splice(i, 1);
                    segment.traverse((child) => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                }
            }
            
            // Add new segments ahead
            if (buildingSegments.length > 0) {
                const frontMostSegment = buildingSegments.reduce((front, segment) => 
                    segment.userData.startZ < front.userData.startZ ? segment : front
                );
                
                if (frontMostSegment.userData.startZ > playerZ - 500) {
                    createBuildingSegment(frontMostSegment.userData.startZ - segmentLength);
                }
            } else {
                // If no segments exist, create initial segment
                createBuildingSegment(playerZ);
            }
        }
        
        function createBuilding() {
            // GIANT MASSIVE ICEBERGS - Wide, imposing, like real icebergs!
            const iceberg = new THREE.Group();
            
            // ICEBERG dimensions - WIDE and MASSIVE, not tall and slim! - 40% BIGGER (15% increase from previous)
            const sizeVariation = Math.random();
            // Base width - MUCH WIDER for iceberg feel - 40% BIGGER
            const baseWidth = sizeVariation < 0.3 ? (12 + Math.random() * 8) * 1.4375 : // Medium (30%)
                           sizeVariation < 0.7 ? (18 + Math.random() * 12) * 1.4375 : // Large (40%)
                           (25 + Math.random() * 15) * 1.4375; // Giant (30%)
            const baseDepth = baseWidth * (0.7 + Math.random() * 0.4); // Varied depth
            // Height - MUCH LOWER relative to width (icebergs are wide, not tall!) - 40% BIGGER
            const height = sizeVariation < 0.3 ? (20 + Math.random() * 15) * 1.4375 : // Low (30%)
                          sizeVariation < 0.7 ? (30 + Math.random() * 20) * 1.4375 : // Medium (40%)
                          (40 + Math.random() * 25) * 1.4375; // Tall (30%) - but still wide relative to height
            
            const iceColorPalettes = [
                [0xfefefe, 0xfcfcff, 0xfafcff, 0xf8fcff, 0xf0f8fc],
                [0xfefefe, 0xfafcff, 0xf8fcff, 0xf4f8fc, 0xeef4f8]
            ];
            const palette = iceColorPalettes[Math.floor(Math.random() * iceColorPalettes.length)];
            const mainColor = palette[Math.floor(Math.random() * Math.min(3, palette.length))];
            
            // MASSIVE GROUNDED BASE - Wide foundation like real icebergs - 40% BIGGER
            const foundationHeight = (2 + Math.random() * 3) * 1.4375;
            const foundationWidth = baseWidth * 1.2; // Wider base
            const foundationDepth = baseDepth * 1.2;
            const foundationGeometry = new THREE.CylinderGeometry(foundationWidth / 2, foundationWidth * 0.9, foundationHeight, 24); // More segments for definition
            const foundationMaterial = new THREE.MeshStandardMaterial({
                color: 0xe8f0f8,
                metalness: 0.05,
                roughness: 0.7,
            });
            const foundation = new THREE.Mesh(foundationGeometry, foundationMaterial);
            foundation.position.y = foundationHeight / 2; // Grounded at y=0
            foundation.castShadow = true;
            foundation.receiveShadow = true;
            iceberg.add(foundation);
            
            // MAIN ICEBERG BODY - WIDE and MASSIVE, organic shape
            // Use multiple overlapping shapes for organic iceberg look
            const mainBodyHeight = height;
            
            // Primary mass - wide and low with enhanced definition
            const primaryWidth = baseWidth * 0.9;
            const primaryDepth = baseDepth * 0.9;
            const primaryGeometry = new THREE.ConeGeometry(primaryWidth / 2, mainBodyHeight, 16); // More segments for smoother definition
            const primaryMaterial = new THREE.MeshStandardMaterial({
                color: mainColor,
                metalness: 0.1, // Subtle ice reflection
                roughness: 0.4, // Natural ice surface texture
                flatShading: false // Smooth shading for definition
            });
            const primaryMass = new THREE.Mesh(primaryGeometry, primaryMaterial);
            primaryMass.position.y = foundationHeight + mainBodyHeight / 2;
            primaryMass.rotation.y = Math.random() * Math.PI;
            primaryMass.castShadow = true;
            primaryMass.receiveShadow = true;
            iceberg.add(primaryMass);
            
            // Secondary masses - add bulk and organic shape with better contrast
            const numSecondaryMasses = 2 + Math.floor(Math.random() * 4);
            for (let i = 0; i < numSecondaryMasses; i++) {
                const massSize = baseWidth * (0.4 + Math.random() * 0.3);
                const massHeight = mainBodyHeight * (0.5 + Math.random() * 0.4);
                const massGeometry = new THREE.ConeGeometry(massSize / 2, massHeight, 12); // More segments
                // Use darker colors for secondary masses to create depth
                const colorIndex = Math.floor(Math.random() * (palette.length - 1)) + 1; // Skip brightest
                const massColor = palette[colorIndex];
                const massMaterial = new THREE.MeshStandardMaterial({
                    color: massColor,
                    metalness: 0.08, // Subtle reflection
                    roughness: 0.5, // Natural ice texture
                });
                const secondaryMass = new THREE.Mesh(massGeometry, massMaterial);
                secondaryMass.position.set(
                    (Math.random() - 0.5) * baseWidth * 0.7,
                    foundationHeight + massHeight / 2 + Math.random() * mainBodyHeight * 0.3,
                    (Math.random() - 0.5) * baseDepth * 0.7
                );
                secondaryMass.rotation.set(
                    (Math.random() - 0.5) * 0.3,
                    Math.random() * Math.PI,
                    (Math.random() - 0.5) * 0.3
                );
                secondaryMass.castShadow = true;
                secondaryMass.receiveShadow = true;
                iceberg.add(secondaryMass);
            }
            
            // ICEBERG CHARACTERISTICS: Large ice chunks/formations with enhanced definition - 40% BIGGER
            if (Math.random() > 0.3) {
                const numChunks = 1 + Math.floor(Math.random() * 5);
                for (let i = 0; i < numChunks; i++) {
                    const chunkSize = (2 + Math.random() * 4) * 1.4375;
                    const chunkGeometry = new THREE.OctahedronGeometry(chunkSize, 1); // More detail
                    // Vary chunk colors for more contrast
                    const chunkColorIndex = Math.random() > 0.5 ? 0 : Math.floor(Math.random() * 2) + 1;
                    const chunkMaterial = new THREE.MeshStandardMaterial({
                        color: palette[chunkColorIndex],
                        metalness: 0.15, // Slight crystalline reflection
                        roughness: 0.35, // Smooth but natural ice
                    });
                    const chunk = new THREE.Mesh(chunkGeometry, chunkMaterial);
                    chunk.position.set(
                        (Math.random() - 0.5) * baseWidth * 0.8,
                        foundationHeight + mainBodyHeight * (0.3 + Math.random() * 0.6),
                        (Math.random() - 0.5) * baseDepth * 0.8
                    );
                    chunk.rotation.set(
                        Math.random() * Math.PI,
                        Math.random() * Math.PI,
                        Math.random() * Math.PI
                    );
                    chunk.castShadow = true;
                    chunk.receiveShadow = true;
                    iceberg.add(chunk);
                }
            }
            
            // ICEBERG TOP - Rounded/irregular top like real icebergs with enhanced contrast
            const topType = Math.random();
            if (topType < 0.5) {
                // Rounded dome top with bright highlights
                const domeRadius = baseWidth * 0.3;
                const domeGeometry = new THREE.SphereGeometry(domeRadius, 16, 12); // More segments for smoother definition
                const domeMaterial = new THREE.MeshStandardMaterial({
                    color: 0xfefefe,
                    metalness: 0.1,
                    roughness: 0.45,
                });
                const dome = new THREE.Mesh(domeGeometry, domeMaterial);
                dome.scale.y = 0.6; // Flatten the sphere
                dome.position.y = foundationHeight + mainBodyHeight + domeRadius * 0.6;
                dome.castShadow = true;
                dome.receiveShadow = true;
                iceberg.add(dome);
            } else {
                // Irregular peaks with sharp definition
                const numPeaks = 1 + Math.floor(Math.random() * 3);
                for (let i = 0; i < numPeaks; i++) {
                    const peakHeight = 5 + Math.random() * 10;
                    const peakWidth = 2 + Math.random() * 4;
                    const peakGeometry = new THREE.ConeGeometry(peakWidth / 2, peakHeight, 12); // More segments
                    const peakMaterial = new THREE.MeshStandardMaterial({
                        color: 0xfefefe,
                        metalness: 0.08,
                        roughness: 0.5,
                    });
                    const peak = new THREE.Mesh(peakGeometry, peakMaterial);
                    peak.position.set(
                        (Math.random() - 0.5) * baseWidth * 0.6,
                        foundationHeight + mainBodyHeight + peakHeight / 2,
                        (Math.random() - 0.5) * baseDepth * 0.6
                    );
                    peak.rotation.set(
                        (Math.random() - 0.5) * 0.2,
                        Math.random() * Math.PI,
                        (Math.random() - 0.5) * 0.2
                    );
                    peak.castShadow = true;
                    peak.receiveShadow = true;
                    iceberg.add(peak);
                }
            }
            
            return iceberg;
        }

        // Colored bears (brown/black/red) use bear.html design; returns group + riderBody/riderHead refs. Bear faces +z so visualGroup flip shows back of head.
        // opts.pepe: all green, 4x size of colored bear.
        function createColoredBearFromBearHtml(furColor, opts = {}) {
            const isPepe = !!opts.pepe;
            const green = 0x00ff00;
            const greenDark = 0x008833;
            const bearGroup = new THREE.Group();
            const snoutColor = isPepe ? green : (furColor === 0x8B4513 ? 0xa0522d : (furColor === 0x1a1a1a ? 0x2a2a2a : 0x992222));
            const baseFur = isPepe ? green : furColor;
            const furMaterial = new THREE.MeshStandardMaterial({
                color: baseFur,
                roughness: 0.85,
                metalness: 0.0,
                emissive: isPepe ? green : (furColor === 0xcc2222 ? 0x330808 : 0x000000),
                emissiveIntensity: isPepe ? 0.15 : (furColor === 0xcc2222 ? 0.1 : 0)
            });
            const snoutMaterial = new THREE.MeshStandardMaterial({ color: snoutColor, roughness: 0.6, metalness: 0.0 });
            const pawMaterial = new THREE.MeshStandardMaterial({ color: snoutColor, roughness: 0.7, metalness: 0.0 });

            const bearHead = new THREE.Group();
            const headGeo = new THREE.SphereGeometry(0.35, 24, 20);
            headGeo.scale(1, 0.9, 1.2);
            const head = new THREE.Mesh(headGeo, furMaterial);
            head.position.set(0, 0.5, 0.1);
            bearHead.add(head);
            const snoutGeo = new THREE.SphereGeometry(0.15, 14, 10);
            snoutGeo.scale(1, 0.8, 1.8);
            const snout = new THREE.Mesh(snoutGeo, snoutMaterial);
            snout.position.set(0, 0.4, 0.25);
            bearHead.add(snout);
            const nose = new THREE.Mesh(new THREE.SphereGeometry(0.04, 10, 6), new THREE.MeshStandardMaterial({ color: isPepe ? greenDark : 0x1a1a1a, roughness: 0.2, metalness: 0.1 }));
            nose.position.set(0, 0.42, 0.36);
            bearHead.add(nose);
            const mouth = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 4), new THREE.MeshStandardMaterial({ color: isPepe ? greenDark : 0x1a0000, roughness: 0.9 }));
            mouth.geometry.scale(2, 0.5, 1);
            mouth.position.set(0, 0.38, 0.34);
            bearHead.add(mouth);
            const earGeo = new THREE.SphereGeometry(0.12, 14, 10);
            earGeo.scale(1.2, 0.8, 0.6);
            const leftEar = new THREE.Mesh(earGeo, furMaterial);
            leftEar.position.set(-0.25, 0.7, 0.05);
            leftEar.rotation.z = 0.3;
            bearHead.add(leftEar);
            const rightEar = new THREE.Mesh(earGeo, furMaterial);
            rightEar.position.set(0.25, 0.7, 0.05);
            rightEar.rotation.z = -0.3;
            bearHead.add(rightEar);
            const innerEarMat = new THREE.MeshStandardMaterial({ color: isPepe ? greenDark : 0x4a2c2a, roughness: 0.9 });
            const leftInner = new THREE.Mesh(new THREE.SphereGeometry(0.06, 10, 6), innerEarMat);
            leftInner.position.set(-0.23, 0.68, 0.08);
            bearHead.add(leftInner);
            const rightInner = new THREE.Mesh(new THREE.SphereGeometry(0.06, 10, 6), innerEarMat);
            rightInner.position.set(0.23, 0.68, 0.08);
            bearHead.add(rightInner);
            const eyeballMat = new THREE.MeshStandardMaterial({ color: isPepe ? green : 0xffffff, roughness: 0.1, metalness: 0.1 });
            const eyeballGeo = new THREE.SphereGeometry(0.06, 12, 8);
            const leftEyeball = new THREE.Mesh(eyeballGeo, eyeballMat);
            leftEyeball.position.set(-0.12, 0.55, 0.25);
            bearHead.add(leftEyeball);
            const rightEyeball = new THREE.Mesh(eyeballGeo, eyeballMat);
            rightEyeball.position.set(0.12, 0.55, 0.25);
            bearHead.add(rightEyeball);
            const pupilMat = new THREE.MeshStandardMaterial({ color: isPepe ? greenDark : 0x000000, roughness: 0.8 });
            const pupilGeo = new THREE.SphereGeometry(0.035, 8, 6);
            const leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
            leftPupil.position.set(-0.12, 0.55, 0.28);
            bearHead.add(leftPupil);
            const rightPupil = new THREE.Mesh(pupilGeo, pupilMat);
            rightPupil.position.set(0.12, 0.55, 0.28);
            bearHead.add(rightPupil);
            bearHead.position.set(0, 0.25, 0.1);
            bearGroup.add(bearHead);

            const bodyGeo = new THREE.SphereGeometry(0.4, 20, 14);
            bodyGeo.scale(1, 1.2, 0.8);
            const body = new THREE.Mesh(bodyGeo, furMaterial);
            body.position.set(0, 0, 0);
            bearGroup.add(body);
            const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.22, 0.25, 10), furMaterial);
            neck.position.set(0, 0.1, 0.05);
            neck.rotation.x = 0.1;
            bearGroup.add(neck);
            const armGeo = new THREE.CylinderGeometry(0.08, 0.12, 0.6, 10);
            const leftArm = new THREE.Mesh(armGeo, furMaterial);
            leftArm.position.set(-0.3, 0.2, 0.4);
            leftArm.rotation.set(-0.3, 0, 0.5);
            bearGroup.add(leftArm);
            const rightArm = new THREE.Mesh(armGeo, furMaterial);
            rightArm.position.set(0.3, 0.2, 0.4);
            rightArm.rotation.set(-0.3, 0, -0.5);
            bearGroup.add(rightArm);
            const pawGeo = new THREE.SphereGeometry(0.1, 12, 10);
            pawGeo.scale(1.2, 0.8, 1.4);
            const leftPaw = new THREE.Mesh(pawGeo, pawMaterial);
            leftPaw.position.set(-0.45, 0.35, 0.7);
            bearGroup.add(leftPaw);
            const rightPaw = new THREE.Mesh(pawGeo, pawMaterial);
            rightPaw.position.set(0.45, 0.35, 0.7);
            bearGroup.add(rightPaw);
            const clawMat = new THREE.MeshStandardMaterial({ color: isPepe ? greenDark : 0x2a2a2a, roughness: 0.3, metalness: 0.4 });
            const clawGeo = new THREE.CylinderGeometry(0.005, 0.01, 0.04, 4);
            for (let i = 0; i < 4; i++) {
                const c = new THREE.Mesh(clawGeo, clawMat);
                c.position.set(-0.45 + (i - 1.5) * 0.02, 0.36, 0.72);
                c.rotation.x = -0.3;
                bearGroup.add(c);
            }
            for (let i = 0; i < 4; i++) {
                const c = new THREE.Mesh(clawGeo, clawMat);
                c.position.set(0.45 + (i - 1.5) * 0.02, 0.36, 0.72);
                c.rotation.x = -0.3;
                bearGroup.add(c);
            }

            const sx = 1.6, sy = 1.6 * 0.65 * 1.175, sz = 1.6;
            const scale = isPepe ? 4 : 1; // Pepe 4x size of colored bear
            bearGroup.scale.set(sx * scale, sy * scale, sz * scale);
            bearGroup.position.set(0, 0.5, 0);
            return { group: bearGroup, riderBody: body, riderHead: bearHead };
        }

        // Create the Motorcycle and Rider - Updated for futuristic look
        function createMotorcycle(bikeColor = 0x222222, riderColor = 0x333333, isPlayer = false, bearType = null) {
            const motorcycle = new THREE.Group();
            
            // Choose a random motorcycle style
            const style = Math.floor(Math.random() * 4); // 4 different styles
            
            // Base materials
            const bikeBodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000, // Pure black for ALL bikes
                metalness: 0.9,
                roughness: 0.1,
                emissive: 0x000000, // No glow - removed permashield
                emissiveIntensity: 0.0
            });

            const wheelMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000, // All wheels are black
                metalness: 0.9,
                roughness: 0.1,
                emissive: 0x000000, // No glow - removed permashield
                emissiveIntensity: 0.0
            });

            // Common wheel geometry
            const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 24);

            // Style-specific body parts
            switch(style) {
                case 0: // Sport Bike
                    const sportBodyGeometry = new THREE.BoxGeometry(0.5, 0.4, 1.5);
                    const sportBody = new THREE.Mesh(sportBodyGeometry, bikeBodyMaterial);
                    sportBody.position.y = 0.2;
                    motorcycle.add(sportBody);

                    // Add sport fairing
                    const fairingGeometry = new THREE.BoxGeometry(0.6, 0.5, 0.8);
                    const fairingMaterial = new THREE.MeshStandardMaterial({
                        color: 0x000000,
                        metalness: 0.7,
                        roughness: 0.3,
                        emissive: 0x000000, // No glow - removed permashield
                        emissiveIntensity: 0.0
                    });
                    const fairing = new THREE.Mesh(fairingGeometry, fairingMaterial);
                    fairing.position.set(0, 0.4, 0.3);
                    motorcycle.add(fairing);
                    break;

                case 1: // Cruiser
                    const cruiserBodyGeometry = new THREE.BoxGeometry(0.6, 0.3, 1.8);
                    const cruiserBody = new THREE.Mesh(cruiserBodyGeometry, bikeBodyMaterial);
                    cruiserBody.position.y = 0.15;
                    motorcycle.add(cruiserBody);

                    // Add cruiser handlebars
                    const handlebarGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1.2);
                    const handlebarMaterial = new THREE.MeshStandardMaterial({
                        color: 0x888888,
                        metalness: 0.9,
                        roughness: 0.1
                    });
                    const handlebars = new THREE.Mesh(handlebarGeometry, handlebarMaterial);
                    handlebars.position.set(0, 0.6, 0.4);
                    handlebars.rotation.x = Math.PI / 2;
                    motorcycle.add(handlebars);
                    break;

                case 2: // Super Bike
                    const superBodyGeometry = new THREE.BoxGeometry(0.45, 0.35, 1.6);
                    const superBody = new THREE.Mesh(superBodyGeometry, bikeBodyMaterial);
                    superBody.position.y = 0.25;
                    motorcycle.add(superBody);

                    // Add aerodynamic wings
                    const wingGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.4);
                    const wingMaterial = new THREE.MeshStandardMaterial({
                        color: 0x000000,
                        metalness: 0.8,
                        roughness: 0.2,
                        emissive: 0x000000, // No glow - removed permashield
                        emissiveIntensity: 0.0
                    });
                    const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                    leftWing.position.set(-0.4, 0.3, 0);
                    motorcycle.add(leftWing);
                    const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                    rightWing.position.set(0.4, 0.3, 0);
                    motorcycle.add(rightWing);
                    break;

                case 3: // Future Bike
                    const futureBodyGeometry = new THREE.BoxGeometry(0.5, 0.4, 1.5);
                    const futureBody = new THREE.Mesh(futureBodyGeometry, bikeBodyMaterial);
                    futureBody.position.y = 0.2;
                    motorcycle.add(futureBody);

                    // Add hover elements
                    const hoverGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 16);
                    const hoverMaterial = new THREE.MeshStandardMaterial({
                        color: 0x00ffff,
                        metalness: 0.5,
                        roughness: 0.5,
                        emissive: isPlayer ? 0x000000 : 0x00ffff, // No glow for player - removed shield/aura
                        emissiveIntensity: isPlayer ? 0.0 : 0.8
                    });
                    const leftHover = new THREE.Mesh(hoverGeometry, hoverMaterial);
                    leftHover.position.set(-0.3, 0.1, 0);
                    motorcycle.add(leftHover);
                    const rightHover = new THREE.Mesh(hoverGeometry, hoverMaterial);
                    rightHover.position.set(0.3, 0.1, 0);
                    motorcycle.add(rightHover);
                    break;
            }

            // Add wheels for all styles
            const frontWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            frontWheel.position.set(0, 0, 0.7);
            frontWheel.rotation.x = Math.PI / 2;
            motorcycle.add(frontWheel);

            const rearWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            rearWheel.position.set(0, 0, -0.7);
            rearWheel.rotation.x = Math.PI / 2;
            motorcycle.add(rearWheel);

            // Declare riderBody and riderHead outside if/else for proper scope
            let riderBody, riderHead;
            
            if (isPlayer) {
                // PEPE THE FROG RIDER (identical to ape.html main character)
                const pepeGreen = new THREE.MeshStandardMaterial({
                    color: 0x7cb342, roughness: 0.7, metalness: 0.0
                });
                const pepeEyeWhite = new THREE.MeshStandardMaterial({
                    color: 0xffffff, roughness: 0.3, metalness: 0.0
                });
                const pepeEyeBlack = new THREE.MeshStandardMaterial({
                    color: 0x000000, roughness: 0.2, metalness: 0.0
                });
                
                const bodyGroup = new THREE.Group();
                
                // Main frog body - wide and squat (25% shorter overall for swamp scale)
                const mainBody = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5, 32, 32),
                    pepeGreen
                );
                mainBody.scale.set(1.3, 0.675, 1.1);  // Y: 0.9 * 0.75
                mainBody.position.set(0, 0.4125, 0);  // 0.55 * 0.75
                bodyGroup.add(mainBody);
                
                // Frog head
                const head = new THREE.Mesh(
                    new THREE.SphereGeometry(0.45, 32, 32),
                    pepeGreen
                );
                head.scale.set(1.2, 0.75, 1.0);  // Y: 1.0 * 0.75
                head.position.set(0, 0.825, 0.1);  // 1.1 * 0.75
                bodyGroup.add(head);
                
                // ICONIC PEPE EYES - Large bulging eyes
                const leftEyeBall = new THREE.Mesh(
                    new THREE.SphereGeometry(0.22, 24, 24),
                    pepeEyeWhite
                );
                leftEyeBall.position.set(-0.25, 1.05, 0.25);  // 1.4 * 0.75
                leftEyeBall.scale.set(1.0, 0.9, 0.8);  // Y: 1.2 * 0.75
                bodyGroup.add(leftEyeBall);
                
                const rightEyeBall = new THREE.Mesh(
                    new THREE.SphereGeometry(0.22, 24, 24),
                    pepeEyeWhite
                );
                rightEyeBall.position.set(0.25, 1.05, 0.25);
                rightEyeBall.scale.set(1.0, 0.9, 0.8);
                bodyGroup.add(rightEyeBall);
                
                // Eye pupils
                const leftPupil = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 16, 16),
                    pepeEyeBlack
                );
                leftPupil.position.set(-0.25, 1.0125, 0.4);  // 1.35 * 0.75
                bodyGroup.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 16, 16),
                    pepeEyeBlack
                );
                rightPupil.position.set(0.25, 1.0125, 0.4);
                bodyGroup.add(rightPupil);
                
                // Wide frog mouth
                const frogMouth = new THREE.MeshStandardMaterial({
                    color: 0x4caf50, roughness: 0.8, metalness: 0.0
                });
                const mouth = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 0.08, 0.15),
                    frogMouth
                );
                mouth.position.set(0, 0.7125, 0.42);  // 0.95 * 0.75
                bodyGroup.add(mouth);
                
                // Arms
                const leftArm = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.12, 0.15, 0.45, 16),  // 0.6 * 0.75
                    pepeGreen
                );
                leftArm.position.set(-0.4, 0.45, 0.2);  // 0.6 * 0.75
                leftArm.rotation.z = Math.PI / 6;
                bodyGroup.add(leftArm);
                
                const rightArm = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.12, 0.15, 0.45, 16),
                    pepeGreen
                );
                rightArm.position.set(0.4, 0.45, 0.2);
                rightArm.rotation.z = -Math.PI / 6;
                bodyGroup.add(rightArm);
                
                // Webbed hands
                const leftHand = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 12, 12),
                    pepeGreen
                );
                leftHand.scale.set(1.3, 0.375, 1.2);  // Y: 0.5 * 0.75
                leftHand.position.set(-0.55, 0.2625, 0.25);  // 0.35 * 0.75
                bodyGroup.add(leftHand);
                
                const rightHand = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 12, 12),
                    pepeGreen
                );
                rightHand.scale.set(1.3, 0.375, 1.2);
                rightHand.position.set(0.55, 0.2625, 0.25);
                bodyGroup.add(rightHand);
                
                // Legs
                const leftLeg = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.15, 0.12, 0.375, 16),  // 0.5 * 0.75
                    pepeGreen
                );
                leftLeg.position.set(-0.3, 0.1875, -0.2);  // 0.25 * 0.75
                leftLeg.rotation.x = Math.PI / 4;
                bodyGroup.add(leftLeg);
                
                const rightLeg = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.15, 0.12, 0.375, 16),
                    pepeGreen
                );
                rightLeg.position.set(0.3, 0.1875, -0.2);
                rightLeg.rotation.x = Math.PI / 4;
                bodyGroup.add(rightLeg);
                
                // Large webbed feet
                const leftFoot = new THREE.Mesh(
                    new THREE.SphereGeometry(0.18, 12, 12),
                    pepeGreen
                );
                leftFoot.scale.set(1.5, 0.3, 1.3);  // Y: 0.4 * 0.75
                leftFoot.position.set(-0.3, 0.0375, -0.4);  // 0.05 * 0.75
                bodyGroup.add(leftFoot);
                
                const rightFoot = new THREE.Mesh(
                    new THREE.SphereGeometry(0.18, 12, 12),
                    pepeGreen
                );
                rightFoot.scale.set(1.5, 0.3, 1.3);
                rightFoot.position.set(0.3, 0.0375, -0.4);
                bodyGroup.add(rightFoot);
                
                bodyGroup.position.set(0, 0.45, 0);  // 0.6 * 0.75 - lower on bike
                motorcycle.add(bodyGroup);
                riderBody = bodyGroup;
                riderHead = head;
            } else {
                // 50% PENGUIN (scape.html design), 50% BEAR competitors
                const usePenguinCompetitor = Math.random() < 0.5;
                if (usePenguinCompetitor) {
                    // AI PENGUIN - same design as scape.html main character, fixed Emperor-style colors
                    const selectedSkin = { bodyColor: 0xf5f5f5, backColor: 0x1a1a1a, chestColor: 0xff8800, beakColor: 0xff8800, feetColor: 0xff8800 };
                    const featherWhite = new THREE.MeshStandardMaterial({ color: selectedSkin.bodyColor, roughness: 0.8, metalness: 0.0 });
                    const featherBlack = new THREE.MeshStandardMaterial({ color: selectedSkin.backColor, roughness: 0.7, metalness: 0.0 });
                    const beakMaterial = new THREE.MeshStandardMaterial({ color: selectedSkin.beakColor, roughness: 0.4, metalness: 0.1 });
                    const penguinOrange = new THREE.MeshStandardMaterial({ color: selectedSkin.chestColor, roughness: 0.4, metalness: 0.1, emissive: 0x000000, emissiveIntensity: 0.0 });
                    const bodyGroup = new THREE.Group();
                    const mainBody = new THREE.Mesh(new THREE.SphereGeometry(0.42, 32, 32), featherWhite);
                    mainBody.scale.set(1, 1.5, 0.85);
                    mainBody.position.set(0, 0.65, 0);
                    bodyGroup.add(mainBody);
                    const bellyContour = new THREE.Mesh(new THREE.SphereGeometry(0.36, 24, 24), featherWhite);
                    bellyContour.scale.set(1, 1.2, 0.75);
                    bellyContour.position.set(0, 0.55, 0.22);
                    bodyGroup.add(bellyContour);
                    const backCoat = new THREE.Mesh(new THREE.SphereGeometry(0.43, 32, 32), featherBlack);
                    backCoat.scale.set(1.02, 1.52, 0.6);
                    backCoat.position.set(0, 0.66, -0.15);
                    bodyGroup.add(backCoat);
                    const tail = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.18, 10), featherBlack);
                    tail.rotation.x = -Math.PI / 2;
                    tail.position.set(0, 0.45, -0.55);
                    bodyGroup.add(tail);
                    const chestPatch = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16), penguinOrange);
                    chestPatch.scale.set(1.2, 0.8, 0.5);
                    chestPatch.position.set(0, 1.05, 0.25);
                    bodyGroup.add(chestPatch);
                    motorcycle.add(bodyGroup);
                    const headGroup = new THREE.Group();
                    headGroup.position.set(0, 1.25, 0);
                    const penguinHead = new THREE.Mesh(new THREE.SphereGeometry(0.25, 24, 24), featherBlack);
                    penguinHead.scale.set(0.9, 1.0, 1.1);
                    headGroup.add(penguinHead);
                    const leftCheek = new THREE.Mesh(new THREE.SphereGeometry(0.13, 16, 16), featherWhite);
                    leftCheek.scale.set(0.8, 0.6, 0.6);
                    leftCheek.position.set(-0.12, -0.02, 0.12);
                    headGroup.add(leftCheek);
                    const rightCheek = new THREE.Mesh(new THREE.SphereGeometry(0.13, 16, 16), featherWhite);
                    rightCheek.scale.set(0.8, 0.6, 0.6);
                    rightCheek.position.set(0.12, -0.02, 0.12);
                    headGroup.add(rightCheek);
                    const beakGroup = new THREE.Group();
                    const upperBeak = new THREE.Mesh(new THREE.ConeGeometry(0.06, 0.25, 12), beakMaterial);
                    upperBeak.rotation.x = Math.PI / 2;
                    upperBeak.scale.set(1, 1, 0.5);
                    upperBeak.position.set(0, -0.05, 0.3);
                    beakGroup.add(upperBeak);
                    const lowerBeak = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.2, 12), beakMaterial);
                    lowerBeak.rotation.x = Math.PI / 2;
                    lowerBeak.scale.set(1, 1, 0.45);
                    lowerBeak.position.set(0, -0.09, 0.27);
                    beakGroup.add(lowerBeak);
                    const beakAccent = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.08, 0.15), penguinOrange);
                    beakAccent.position.set(0, -0.05, 0.25);
                    beakGroup.add(beakAccent);
                    headGroup.add(beakGroup);
                    const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.025, 8, 8), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                    leftEye.position.set(-0.1, 0.05, 0.15);
                    headGroup.add(leftEye);
                    const leftEyeHighlight = new THREE.Mesh(new THREE.SphereGeometry(0.01, 6, 6), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                    leftEyeHighlight.position.set(-0.09, 0.06, 0.17);
                    headGroup.add(leftEyeHighlight);
                    const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.025, 8, 8), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                    rightEye.position.set(0.1, 0.05, 0.15);
                    headGroup.add(rightEye);
                    const rightEyeHighlight = new THREE.Mesh(new THREE.SphereGeometry(0.01, 6, 6), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                    rightEyeHighlight.position.set(0.09, 0.06, 0.17);
                    headGroup.add(rightEyeHighlight);
                    motorcycle.add(headGroup);
                    const flipperGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                    const leftFlipper = new THREE.Mesh(flipperGeometry, featherBlack);
                    leftFlipper.scale.set(0.3, 1.8, 0.6);
                    leftFlipper.position.set(-0.42, 0.7, -0.05);
                    leftFlipper.rotation.z = Math.PI / 8;
                    leftFlipper.rotation.x = -0.2;
                    motorcycle.add(leftFlipper);
                    const rightFlipper = new THREE.Mesh(flipperGeometry, featherBlack);
                    rightFlipper.scale.set(0.3, 1.8, 0.6);
                    rightFlipper.position.set(0.42, 0.7, -0.05);
                    rightFlipper.rotation.z = -Math.PI / 8;
                    rightFlipper.rotation.x = -0.2;
                    motorcycle.add(rightFlipper);
                    const footMaterial = new THREE.MeshStandardMaterial({ color: selectedSkin.feetColor, roughness: 0.9 });
                    const footGeometry = new THREE.BoxGeometry(0.14, 0.06, 0.22);
                    const leftFoot = new THREE.Mesh(footGeometry, footMaterial);
                    leftFoot.position.set(-0.22, 0.32, 0.15);
                    motorcycle.add(leftFoot);
                    const rightFoot = new THREE.Mesh(footGeometry, footMaterial);
                    rightFoot.position.set(0.22, 0.32, 0.15);
                    motorcycle.add(rightFoot);
                    riderBody = mainBody;
                    riderHead = penguinHead;
                } else {
                    // BEAR RIDER - AI competitors: white = polar bear; brown/black/red = bear.html design
                    const furColor = riderColor || 0xfafafa;
                    if (furColor === 0xfafafa) {
                        const whiteFurMaterial = new THREE.MeshStandardMaterial({
                            color: 0xfafafa,
                            metalness: 0.05,
                            roughness: 0.85,
                            emissive: 0xffffff,
                            emissiveIntensity: 0.1
                        });
                        const creamFurMaterial = new THREE.MeshStandardMaterial({ color: 0xf5f5dc, metalness: 0.0, roughness: 0.9 });
                        const bearBody = new THREE.Mesh(new THREE.SphereGeometry(0.45, 16, 16), whiteFurMaterial);
                        bearBody.scale.set(1.1, 1.3, 0.9);
                        bearBody.position.set(0, 0.7, 0);
                        motorcycle.add(bearBody);
                        const bearHead = new THREE.Mesh(new THREE.SphereGeometry(0.32, 16, 16), whiteFurMaterial);
                        bearHead.scale.set(1, 0.9, 1.1);
                        bearHead.position.set(0, 1.15, 0.1);
                        motorcycle.add(bearHead);
                        const snout = new THREE.Mesh(new THREE.SphereGeometry(0.15, 12, 12), creamFurMaterial);
                        snout.scale.set(0.8, 0.7, 1.2);
                        snout.position.set(0, 1.05, 0.35);
                        motorcycle.add(snout);
                        const earGeo = new THREE.SphereGeometry(0.08, 12, 12);
                        const leftEar = new THREE.Mesh(earGeo, whiteFurMaterial);
                        leftEar.position.set(-0.2, 1.35, -0.1);
                        motorcycle.add(leftEar);
                        const rightEar = new THREE.Mesh(earGeo, whiteFurMaterial);
                        rightEar.position.set(0.2, 1.35, -0.1);
                        motorcycle.add(rightEar);
                        const nose = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), new THREE.MeshBasicMaterial({ color: 0x1a1a1a }));
                        nose.position.set(0, 1.08, 0.48);
                        motorcycle.add(nose);
                        const eyeGeo = new THREE.SphereGeometry(0.035, 8, 8);
                        const eyeMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
                        const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                        leftEye.position.set(-0.1, 1.18, 0.28);
                        motorcycle.add(leftEye);
                        const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                        rightEye.position.set(0.1, 1.18, 0.28);
                        motorcycle.add(rightEye);
                        const armGeo = new THREE.CylinderGeometry(0.1, 0.12, 0.4, 8);
                        const leftArm = new THREE.Mesh(armGeo, whiteFurMaterial);
                        leftArm.position.set(-0.35, 0.6, 0.15);
                        leftArm.rotation.z = Math.PI / 3.5;
                        leftArm.rotation.x = -0.2;
                        motorcycle.add(leftArm);
                        const rightArm = new THREE.Mesh(armGeo, whiteFurMaterial);
                        rightArm.position.set(0.35, 0.6, 0.15);
                        rightArm.rotation.z = -Math.PI / 3.5;
                        rightArm.rotation.x = -0.2;
                        motorcycle.add(rightArm);
                        const pawGeo = new THREE.SphereGeometry(0.1, 8, 8);
                        const leftPaw = new THREE.Mesh(pawGeo, whiteFurMaterial);
                        leftPaw.position.set(-0.45, 0.45, 0.3);
                        motorcycle.add(leftPaw);
                        const rightPaw = new THREE.Mesh(pawGeo, whiteFurMaterial);
                        rightPaw.position.set(0.45, 0.45, 0.3);
                        motorcycle.add(rightPaw);
                        const backFluff = new THREE.Mesh(new THREE.SphereGeometry(0.25, 12, 12), whiteFurMaterial);
                        backFluff.scale.set(1.5, 0.8, 0.6);
                        backFluff.position.set(0, 0.95, -0.15);
                        motorcycle.add(backFluff);
                        riderBody = bearBody;
                        riderHead = bearHead;
                    } else {
                        const { group, riderBody: rb, riderHead: rh } = createColoredBearFromBearHtml(furColor, { pepe: bearType === 'pepe' });
                        motorcycle.add(group);
                        riderBody = rb;
                        riderHead = rh;
                    }
                }
            }

            // Engine glow removed - no shield/aura
            
            // Bike light removed for player - no visible shield/aura effect
            // Only add light for AI bikes (not player)
            let bikeLight = null;
            if (!isPlayer) {
                bikeLight = new THREE.PointLight(0xffffff, 0.8, 15);
                bikeLight.position.y = 1;
                motorcycle.add(bikeLight);
            }
            
            // Store reference to player's headlight and create floodlight
            if (isPlayer) {
                // Player doesn't get bikeLight - no shield/aura
                bikeHeadlight = null; // No headlight for player
                
                // Create a powerful SpotLight for floodlight effect (initially off)
                bikeFloodlight = new THREE.SpotLight(0xffffff, 0, 100, Math.PI / 6, 0.2, 2);
                bikeFloodlight.position.set(0, 1.5, 1); // Position in front of bike
                bikeFloodlight.target.position.set(0, 0, -50); // Point far ahead
                motorcycle.add(bikeFloodlight);
                motorcycle.add(bikeFloodlight.target);
                
                // Enable shadow casting for dramatic effect (mobile: smaller map, same 5 as AAA)
                bikeFloodlight.castShadow = true;
                const shadowSize = isMobile ? 512 : 1024;
                bikeFloodlight.shadow.mapSize.width = shadowSize;
                bikeFloodlight.shadow.mapSize.height = shadowSize;
            }

            // Ensure riders face forward (match movement direction)
            const visualGroup = new THREE.Group();
            visualGroup.rotation.y = Math.PI;
            const preservedChildren = new Set([
                bikeLight,
                bikeFloodlight,
                bikeFloodlight ? bikeFloodlight.target : null
            ]);
            motorcycle.children.slice().forEach(child => {
                if (!preservedChildren.has(child) && child !== visualGroup) {
                    visualGroup.add(child);
                }
            });
            motorcycle.add(visualGroup);
            motorcycle.userData.visualGroup = visualGroup;

            return { motorcycle, riderBody, riderHead };
        }


        // Player Motorcycle and Rider ‚Äî index.html main character colors (black body, pink head, black bike)
        const ICE_BIKE = 0x000000, ICE_BODY = 0x000000, ICE_HELMET = 0xffb6c1;
        const playerBikeColor = (isCustomized && window.gameCustomizations) ? window.gameCustomizations.bikeColor : ICE_BIKE;
        const playerBodyColor = (isCustomized && window.gameCustomizations) ? window.gameCustomizations.bodyColor : ICE_BODY;
        const playerMotorcycleParts = createMotorcycle(playerBikeColor, playerBodyColor, true);
        let playerMotorcycle = playerMotorcycleParts.motorcycle;
        playerRiderBody = playerMotorcycleParts.riderBody;
        playerRiderHead = playerMotorcycleParts.riderHead;
        
        // Apply custom rider body color and glow
        if (playerRiderBody) {
            const customBodyColor = (isCustomized && window.gameCustomizations) ? window.gameCustomizations.bodyColor : ICE_BODY;
            const customBodyGlow = false; // Always disable glow - removed shield/aura
            
            playerRiderBody.material = new THREE.MeshStandardMaterial({
                color: customBodyColor,
                metalness: 0.3,
                roughness: 0.7,
                emissive: 0x000000, // No glow - removed shield/aura
                emissiveIntensity: 0.0
            });
        }
        
        // Main rider head ‚Äî index.html pink helmet
        if (playerRiderHead) {
            const headColor = ICE_HELMET;
            playerRiderHead.material = new THREE.MeshStandardMaterial({
                color: headColor,
                metalness: 0.3,
                roughness: 0.7,
                emissive: 0x000000,
                emissiveIntensity: 0.0,
                transparent: true,
                opacity: 0.95
            });
        }
        
        // Apply custom bike color and glow if specified
        const customBikeColor = (isCustomized && window.gameCustomizations) ? window.gameCustomizations.bikeColor : ICE_BIKE;
        const customBikeGlow = (isCustomized && window.gameCustomizations) ? window.gameCustomizations.bikeGlow : false;
        
        playerMotorcycle.traverse((child) => {
            if (child.isMesh && child.material && child !== playerRiderBody && child !== playerRiderHead) {
                // Apply custom bike color to all motorcycle parts (but not rider parts)
                // ALWAYS set emissive to 0 - no glow effects
                child.material = new THREE.MeshStandardMaterial({
                    color: customBikeColor,
                    metalness: 0.0,
                    roughness: 1.0,
                    emissive: 0x000000, // Always black - no glow
                    emissiveIntensity: 0.0 // Always 0 - no glow
                });
            }
        });
        
        scene.add(playerMotorcycle);

        // AI Competitor Motorcycles
        const aiMotorcycles = [];
        let numAIMotorcycles = (isCustomized && window.gameCustomizations) ? window.gameCustomizations.aiCount : 3; // Restore for 25+ visibility (was 4, then 2)
        // VIBRANT COLORS for AI competitors - More variety for mayhem!
        const aiColors = [
            0x00ffff,  // Cyan
            0xff00ff,  // Magenta
            0x00ff00,  // Green
            0xffff00,  // Yellow
            0xff6600,  // Orange
            0x6600ff,  // Purple
            0xff0080,  // Hot Pink
            0x00ff80,  // Mint Green
            0xff8000,  // Bright Orange
            0x8000ff,  // Violet
            0xff4000,  // Red Orange
            0x00ffff,  // Aqua
            0xff00aa,  // Pink
            0xaa00ff   // Lavender
        ];
        const initialAiBikes = 4; // Reduced by 25% (was 5)
        let lastCompetitorSpawnTime = 0;
        const competitorSpawnInterval = 5500;
        let lastObstacleClusterTime = 0;
        let obstacleClusterCooldown = 0;
        // Only 1 colored bear per spawn batch; color rotates brown->black; red is rare (5x target)
        let nextColoredBearColorIndex = 0; // 0=brown, 1=black
        const BEAR_WHITE = 0xfafafa, BEAR_BROWN = 0x8B4513, BEAR_BLACK = 0x1a1a1a, BEAR_RED = 0xcc2222, PEPE_GREEN = 0x00ff00;
        function pickRiderForSpawn(isColoredSlot) {
            if (!isColoredSlot) return { riderColor: BEAR_WHITE, bearType: 'white' };
            if (Math.random() >= 0.20) return { riderColor: BEAR_WHITE, bearType: 'white' }; // 80% reduction: only 20% of colored slots get a color
            if (Math.random() < 0.10) return { riderColor: BEAR_RED, bearType: 'red' }; // Red most scarce
            const idx = nextColoredBearColorIndex;
            nextColoredBearColorIndex = (nextColoredBearColorIndex + 1) % 2;
            return idx === 0 ? { riderColor: BEAR_BROWN, bearType: 'brown' } : { riderColor: BEAR_BLACK, bearType: 'black' };
        }

        function createInitialAIMotorcycles() {
             const coloredSlot = 0; // Only first bike in initial batch gets a color
             for (let i = 0; i < numAIMotorcycles; i++) {
                 const { riderColor, bearType } = pickRiderForSpawn(i === coloredSlot);
                 const aiBikeParts = createMotorcycle(aiColors[i % aiColors.length], riderColor, false, bearType);
                 const aiBike = aiBikeParts.motorcycle;
                 aiBike.userData.bearType = bearType;
                 aiBike.position.set((i - (numAIMotorcycles - 1) / 2) * 2, 0, playerMotorcycle.position.z - 10 - i * 8); // Stagger spawn positions more
                 aiBike.userData.targetX = aiBike.position.x;
                 aiBike.userData.targetTimer = 0;
                 aiBike.userData.steerSpeed = bearType === 'pepe' ? 0.03 : 0.02;
                 const baseSpd = baseMoveSpeed * (0.85 + Math.random() * 0.2);
                 aiBike.userData.moveSpeed = bearType === 'pepe' ? baseSpd * 1.5 : baseSpd;
                 aiBike.userData.canMove = true; // Add canMove flag
                 scene.add(aiBike);
                 aiMotorcycles.push(aiBike);
             }
        }


        const roadWidth = 14; // Wider road for better visibility and maneuvering
        const roadLength = 200; // Shorter segments for infinite tiling
        const roadSegments = [];

        function createRoadSegment(zPosition) {
            const roadSegment = new THREE.Mesh(sharedRoadGeometry, sharedRoadMaterials[currentRoadTextureIndex]);
            roadSegment.rotation.x = Math.PI / 2;
            roadSegment.position.set(0, -0.5, zPosition);
            roadSegment.userData.zPosition = zPosition;
            scene.add(roadSegment);
            roadSegments.push(roadSegment);
            return roadSegment;
        }
        
        function updateInfiniteRoad() {
            const playerZ = playerMotorcycle.position.z;
            
            // Only update road segments every 200ms for better performance (doubled from 100ms)
            if (Math.floor(getAdjustedTime() / 200) !== updateInfiniteRoad.lastUpdate) {
                updateInfiniteRoad.lastUpdate = Math.floor(getAdjustedTime() / 200);
                
                // Remove road segments that are far behind
                for (let i = roadSegments.length - 1; i >= 0; i--) {
                    const segment = roadSegments[i];
                    if (segment.userData.zPosition > playerZ + roadLength * 2) {
                        scene.remove(segment);
                        // Don't dispose shared geometry and materials
                        roadSegments.splice(i, 1);
                    }
                }
                
                // Add new road segments ahead
                const frontMostZ = roadSegments.length > 0 ? 
                    Math.min(...roadSegments.map(s => s.userData.zPosition)) : 0;
                
                if (frontMostZ > playerZ - roadLength * 4) {
                    createRoadSegment(frontMostZ - roadLength);
                }
            }
        }

        function createRoadHtmlTexture() {
            const roadCanvas = document.createElement('canvas');
            roadCanvas.width = 256;
            roadCanvas.height = 1024;
            const ctx = roadCanvas.getContext('2d');
            const gradient = ctx.createLinearGradient(0, 0, roadCanvas.width, 0);
            gradient.addColorStop(0, '#5a8aa8');
            gradient.addColorStop(0.1, '#3a6a88');
            gradient.addColorStop(0.5, '#2a5a78');
            gradient.addColorStop(0.9, '#3a6a88');
            gradient.addColorStop(1, '#5a8aa8');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, roadCanvas.width, roadCanvas.height);
            ctx.strokeStyle = 'rgba(180, 220, 255, 0.3)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 30; i++) {
                ctx.beginPath();
                const x = Math.random() * roadCanvas.width;
                const y = Math.random() * roadCanvas.height;
                ctx.moveTo(x, y);
                for (let j = 0; j < 5; j++) {
                    ctx.lineTo(x + (Math.random() - 0.5) * 100, y + Math.random() * 80);
                }
                ctx.stroke();
            }
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 10;
            const lx1 = Math.floor(roadCanvas.width * (1 / 3)) - 4;
            const lx2 = Math.floor(roadCanvas.width * (2 / 3)) - 4;
            for (let y = 0; y < roadCanvas.height; y += 60) {
                ctx.fillRect(lx1, y, 8, 30);
                ctx.fillRect(lx2, y, 8, 30);
            }
            ctx.shadowBlur = 0;
            const snowWidth = 15;
            ctx.fillStyle = '#eef6fa';
            ctx.fillRect(0, 0, snowWidth, roadCanvas.height);
            ctx.fillRect(roadCanvas.width - snowWidth, 0, snowWidth, roadCanvas.height);
            const texture = new THREE.CanvasTexture(roadCanvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(1, roadLength / roadCanvas.height * 2);
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            return texture;
        }

        const roadTextures = [
            createRoadHtmlTexture(),
            createRoadHtmlTexture(),
            createRoadHtmlTexture()
        ];

        // Shared geometries and materials ‚Äî ice.html uses MeshStandardMaterial (roughness 0.4, metalness 0.1)
        const sharedRoadGeometry = new THREE.PlaneGeometry(roadWidth, roadLength);
        const sharedRoadMaterials = roadTextures.map(texture =>
            new THREE.MeshStandardMaterial({
                map: texture,
                side: THREE.DoubleSide,
                roughness: 0.4,
                metalness: 0.1
            })
        );

        let currentRoadTextureIndex = 0;
        
        // Initialize infinite road system
        for (let i = 0; i < 5; i++) {
            createRoadSegment(-i * roadLength);
        }

        // ARCTIC WHITE INVARIANT: Snow/ice brightest; blue only in shadow, distant fog, cracks.
        // Base snow = 0xfefefe. Shadow = hemi ground. No global blue/grey on white surfaces.
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.15);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
        directionalLight.position.set(30, 50, 40);
        directionalLight.castShadow = false;
        scene.add(directionalLight);
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.08);
        fillLight.position.set(-40, 30, -20);
        scene.add(fillLight);
        const rimLight = new THREE.DirectionalLight(0xffffff, 0.06);
        rimLight.position.set(0, 15, -50);
        scene.add(rimLight);
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x7088a0, 0.12);
        scene.add(hemiLight);
        neonLight1 = new THREE.PointLight(0xffffff, 0.08, 80);
        neonLight1.position.set(-25, 15, 0);
        scene.add(neonLight1);
        neonLight2 = new THREE.PointLight(0xffffff, 0.08, 70);
        neonLight2.position.set(25, 12, -25);
        scene.add(neonLight2);
        neonLight3 = new THREE.PointLight(0xffffff, 0.08, 60);
        neonLight3.position.set(0, 20, -50);
        scene.add(neonLight3);

        let lightAnimationCounter = 0;
        function animateNeonLights() {
            lightAnimationCounter++;
            if (lightAnimationCounter % 3 !== 0) return;
            const time = Date.now() * 0.001;
            neonLight1.intensity = 0.32 + Math.sin(time) * 0.04;
            neonLight2.intensity = 0.25 + Math.sin(time + 1) * 0.04;
            neonLight3.intensity = 0.2 + Math.sin(time + 2) * 0.05;
        }

        lightningLight = new THREE.PointLight(0xffffff, 0, 200);
        lightningLight.position.set(0, 50, 0);
        scene.add(lightningLight);


        // Memory Management System
        const objectPools = {
            coins: [],
            obstacles: [],
            projectiles: [],
            particles: [],
            sparkles: []
        };

        const sharedGeometries = {
            coin: new THREE.CylinderGeometry(0.4, 0.4, 0.1, 24), // Round coin shape
            sphere: new THREE.SphereGeometry(0.15, 8, 8),
            box: new THREE.BoxGeometry(1.5, 1, 1.5),
            particle: new THREE.SphereGeometry(0.05, 8, 8)
        };

        const sharedMaterials = {
            coin: new THREE.MeshStandardMaterial({
                color: 0xe8e8e8, metalness: 0.95, roughness: 0.1, emissive: 0xffffff, emissiveIntensity: 0.3
            }),
            particle: new THREE.MeshBasicMaterial({
                color: 0xffffff, transparent: true, opacity: 1.0
            }),
            sparkle: new THREE.MeshStandardMaterial({
                color: 0xc0c0c0, emissive: 0xc0c0c0, emissiveIntensity: 1.0, metalness: 0, roughness: 1, transparent: true, opacity: 1.0
            })
        };

        const burstMaterialPool = (() => {
            const colors = [0xffffff, 0xc0c0c0, 0x00ddff, 0xe8e8e8, 0x87ceeb, 0xb0e0e6, 0xd3d3d3, 0xe0ffff,
                0xffd700, 0xffff00, 0xffaa00, 0xfff8dc, 0xf0e68c, 0xddd0b8, 0xc0c0c0, 0xffffff];
            return colors.map(c => new THREE.MeshStandardMaterial({
                color: c, emissive: c, emissiveIntensity: 0.9, transparent: true, opacity: 1.0
            }));
        })();

        function getPooledObject(type, createFn) {
            const pool = objectPools[type];
            if (pool && pool.length > 0) {
                return pool.pop();
            }
            return createFn();
        }

        function returnToPool(type, object) {
            if (object && objectPools[type]) {
                // Reset object state
                object.position.set(0, 0, 0);
                object.rotation.set(0, 0, 0);
                object.scale.set(1, 1, 1);
                object.visible = true;
                if (object.material && object.material.opacity !== undefined) {
                    object.material.opacity = 1.0;
                }
                objectPools[type].push(object);
            }
        }

        function disposeObject(object) {
            if (!object) return;
            object.traverse((child) => {
                if (child.isMesh || child.isLine || child.isLineSegments) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => { if (m.map) m.map.dispose(); m.dispose(); });
                        } else {
                            if (child.material.map) child.material.map.dispose();
                            child.material.dispose();
                        }
                    }
                }
            });
        }

        function cleanupScene() {
            // Only dispose renderer lists when game is paused or not running to avoid visual interruption
            if (!isGameRunning || gamePaused) {
                renderer.renderLists.dispose();
            }
            
            if (window.performance && window.performance.memory) {
                const mb = window.performance.memory.usedJSHeapSize / 1048576;
                if (mb > 150) forceCleanup();
            }
        }

        function forceCleanup() {
            console.log("Forcing memory cleanup...");
            objectPools.particles.length = 0;
            Object.keys(objectPools).forEach(key => {
                if (key === 'particles') return;
                objectPools[key].forEach(obj => disposeObject(obj));
                objectPools[key].length = 0;
            });
            if (window.gc) window.gc();
        }

        // Enhanced cleanup with power-up specific optimization
        function cleanupPowerUps() {
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                if (powerUp.position.z > (playerMotorcycle ? playerMotorcycle.position.z : 0) + 50) {
                    scene.remove(powerUp);
                    disposeObject(powerUp);
                    powerUps.splice(i, 1);
                }
            }
        }

        // Performance intervals ‚Äî reduced frequency to avoid periodic hitches (was 2‚Äì5s, caused crawl)
        let cleanupPowerUpsInterval = setInterval(cleanupPowerUps, 8000);
        let cleanupSceneInterval = setInterval(cleanupScene, 20000);
        let memoryMonitorInterval = setInterval(monitorPerformance, 15000);
        let aggressiveCleanupInterval = setInterval(aggressiveCleanup, 20000);
        
        // SCENE OBJECT LIMITER ‚Äî run less often so it doesn‚Äôt pile on top of other cleanups
        let sceneObjectLimiterInterval = setInterval(() => {
            if (!isGameRunning || gamePaused) return;
            const maxSceneObjects = level >= 28 ? 350 : 450;
            if (scene.children.length > maxSceneObjects) {
                console.warn(`Scene objects exceeded limit: ${scene.children.length}/${maxSceneObjects}. Forcing cleanup...`);
                aggressiveCleanup();
                if (scene.children.length > maxSceneObjects + 100) forceCleanup();
            }
        }, 10000);
        
        // INVARIANTS (ENFORCED):
        // (1) Max work per frame is bounded and does NOT increase with level.
        // (2) Total active game logic (AI count, AI-entity checks) remains constant after level 10.
        // (3) Visual brightness hierarchy: snow/ice brightest; blue only in shadow, fog, cracks.
        const INVARIANT_MAX_AI_AFTER_L10 = 8;
        const INVARIANT_MAX_OBSTACLE_CHECKS_PER_AI = 3;
        const INVARIANT_MAX_BOWLING_CHECKS_PER_AI = 3;
        const INVARIANT_MAX_COIN_CHECKS_PER_AI = 6;
        function aggressiveCleanup() {
            if (!isGameRunning || gamePaused) return;
            const playerZ = playerMotorcycle ? playerMotorcycle.position.z : 0;
            const cleanupDistance = 50;
            const maxBursts = isMobile ? 30 : 50;
            while (activeBursts.length > maxBursts) {
                const burst = activeBursts.shift();
                scene.remove(burst);
                if (burst.userData && burst.userData.fromMaterialPool) {
                    returnToPool('particles', burst);
                } else {
                    if (burst.material) burst.material.dispose();
                    if (burst.geometry && !burst.userData?.sharedGeometry) burst.geometry.dispose();
                }
            }
            
            const maxBoost = isMobile ? 18 : 30;
            while (boostParticles.length > maxBoost) {
                const particle = boostParticles.shift();
                scene.remove(particle);
                if (particle.material) particle.material.dispose();
            }
            
            const maxTrails = isMobile ? 12 : 20;
            while (etherTrails.length > maxTrails) {
                const trail = etherTrails.shift();
                scene.remove(trail);
                if (trail.geometry) trail.geometry.dispose();
                if (trail.material) trail.material.dispose();
            }
            const maxFlares = isMobile ? 6 : 10;
            while (lensFlares.length > maxFlares) {
                const flare = lensFlares.shift();
                flare.traverse((c) => {
                    if (c.geometry) c.geometry.dispose();
                    if (c.material) { if (c.material.map) c.material.map.dispose(); c.material.dispose(); }
                });
                scene.remove(flare);
            }
            const maxSpeedLines = isMobile ? 12 : 20;
            while (speedLines.length > maxSpeedLines) {
                const line = speedLines.shift();
                scene.remove(line);
                if (line.geometry) line.geometry.dispose();
                if (line.material) line.material.dispose();
            }
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // CRITICAL: Cleanup objects behind the player to prevent accumulation
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            // Cleanup coins behind player
            for (let i = coins.length - 1; i >= 0; i--) {
                if (coins[i].position.z > playerZ + cleanupDistance) {
                    scene.remove(coins[i]);
                    returnToPool('coins', coins[i]);
                    coins.splice(i, 1);
                }
            }
            
            // Cleanup obstacles behind player
            for (let i = obstacles.length - 1; i >= 0; i--) {
                if (obstacles[i].position.z > playerZ + cleanupDistance) {
                    scene.remove(obstacles[i]);
                    disposeObject(obstacles[i]);
                    obstacles.splice(i, 1);
                }
            }
            
            // Ice gaps removed - no cleanup needed
            
            // Cleanup bowlingBallObstacles behind player
            for (let i = bowlingBallObstacles.length - 1; i >= 0; i--) {
                if (bowlingBallObstacles[i].position.z > playerZ + cleanupDistance) {
                    scene.remove(bowlingBallObstacles[i]);
                    disposeObject(bowlingBallObstacles[i]);
                    bowlingBallObstacles.splice(i, 1);
                }
            }
            
            // Cleanup itemBoxes behind player
            for (let i = itemBoxes.length - 1; i >= 0; i--) {
                if (itemBoxes[i].position.z > playerZ + cleanupDistance) {
                    scene.remove(itemBoxes[i]);
                    disposeObject(itemBoxes[i]);
                    itemBoxes.splice(i, 1);
                }
            }
            
            // Cleanup greenVials behind player
            for (let i = greenVials.length - 1; i >= 0; i--) {
                if (greenVials[i].position.z > playerZ + cleanupDistance) {
                    scene.remove(greenVials[i]);
                    disposeObject(greenVials[i]);
                    greenVials.splice(i, 1);
                }
            }
            
            // Cleanup activeProjectiles behind player or too far
            for (let i = activeProjectiles.length - 1; i >= 0; i--) {
                const proj = activeProjectiles[i];
                if (proj.position.z > playerZ + cleanupDistance || proj.position.z < playerZ - 200) {
                    scene.remove(proj);
                    disposeObject(proj);
                    activeProjectiles.splice(i, 1);
                }
            }
            
            // Cleanup batGangs behind player
            for (let i = batGangs.length - 1; i >= 0; i--) {
                if (batGangs[i].position.z > playerZ + cleanupDistance) {
                    scene.remove(batGangs[i]);
                    disposeObject(batGangs[i]);
                    batGangs.splice(i, 1);
                }
            }
            
            // Cleanup batAlleyBats behind player
            for (let i = batAlleyBats.length - 1; i >= 0; i--) {
                if (batAlleyBats[i].position.z > playerZ + cleanupDistance) {
                    scene.remove(batAlleyBats[i]);
                    disposeObject(batAlleyBats[i]);
                    batAlleyBats.splice(i, 1);
                }
            }
            
            // Cleanup bowlingBallAlleyBalls behind player
            for (let i = bowlingBallAlleyBalls.length - 1; i >= 0; i--) {
                if (bowlingBallAlleyBalls[i].position.z > playerZ + cleanupDistance) {
                    scene.remove(bowlingBallAlleyBalls[i]);
                    disposeObject(bowlingBallAlleyBalls[i]);
                    bowlingBallAlleyBalls.splice(i, 1);
                }
            }
            
            // Cleanup finalBats behind player
            for (let i = finalBats.length - 1; i >= 0; i--) {
                if (finalBats[i].position.z > playerZ + cleanupDistance) {
                    scene.remove(finalBats[i]);
                    disposeObject(finalBats[i]);
                    finalBats.splice(i, 1);
                }
            }
            
            // Cleanup galaxyShips behind player
            for (let i = galaxyShips.length - 1; i >= 0; i--) {
                if (galaxyShips[i].position.z > playerZ + cleanupDistance) {
                    scene.remove(galaxyShips[i]);
                    disposeObject(galaxyShips[i]);
                    galaxyShips.splice(i, 1);
                }
            }
            
            // Cleanup galaxyProjectiles behind player
            for (let i = galaxyProjectiles.length - 1; i >= 0; i--) {
                if (galaxyProjectiles[i].position.z > playerZ + cleanupDistance) {
                    scene.remove(galaxyProjectiles[i]);
                    disposeObject(galaxyProjectiles[i]);
                    galaxyProjectiles.splice(i, 1);
                }
            }
            
            // Cleanup galaxyBombs behind player
            for (let i = galaxyBombs.length - 1; i >= 0; i--) {
                if (galaxyBombs[i].position.z > playerZ + cleanupDistance) {
                    scene.remove(galaxyBombs[i]);
                    disposeObject(galaxyBombs[i]);
                    galaxyBombs.splice(i, 1);
                }
            }
            // Cleanup dragons behind player
            for (let i = dragons.length - 1; i >= 0; i--) {
                if (dragons[i].position.z > playerZ + cleanupDistance) {
                    scene.remove(dragons[i]);
                    disposeObject(dragons[i]);
                    dragons.splice(i, 1);
                }
            }
            
            // Cleanup pepe enemies behind player
            for (let i = pepeEnemies.length - 1; i >= 0; i--) {
                if (pepeEnemies[i].position.z > playerZ + cleanupDistance) {
                    scene.remove(pepeEnemies[i]);
                    disposeObject(pepeEnemies[i]);
                    pepeEnemies.splice(i, 1);
                }
            }
            
            // Building segments: use endZ (they have startZ/endZ, not zPosition). Dispose (unique geo).
            if (typeof cityBuildings !== 'undefined' && cityBuildings) {
                const buildingThreshold = buildingSegments.length > 12 ? 10 : 30;
                for (let i = buildingSegments.length - 1; i >= 0; i--) {
                    const segment = buildingSegments[i];
                    if (segment.userData.endZ > playerZ + buildingThreshold) {
                        cityBuildings.remove(segment);
                        disposeObject(segment);
                        buildingSegments.splice(i, 1);
                    }
                }
            }
            // Road segments: shared geometry ‚Äî do NOT dispose. Only remove + splice.
            const roadThreshold = roadSegments.length > 10 ? 10 : 30;
            for (let i = roadSegments.length - 1; i >= 0; i--) {
                const segment = roadSegments[i];
                if (segment.userData.zPosition > playerZ + roadThreshold) {
                    scene.remove(segment);
                    roadSegments.splice(i, 1);
                }
            }
            
            const maxAI = level >= 10 ? INVARIANT_MAX_AI_AFTER_L10 : 11;
            while (aiMotorcycles.length > maxAI) {
                const ai = aiMotorcycles.shift();
                scene.remove(ai);
                disposeObject(ai);
            }
            
        }
        
        // Enhanced memory monitoring for detecting future leaks
        let memoryWarningShown = false;
        let frameCount = 0;
        function monitorMemoryLeaks() {
            frameCount++;
            // Only check memory every 300 frames (~5 seconds at 60fps) to reduce overhead
            if (frameCount % 300 !== 0) return;
            
            if (window.performance && window.performance.memory) {
                const memory = window.performance.memory;
                const usedMB = memory.usedJSHeapSize / 1048576;
                const totalMB = memory.totalJSHeapSize / 1048576;
                
                // Show warning if memory usage is excessive (increased threshold)
                if (usedMB > 200 && !memoryWarningShown) {
                    console.warn(`High memory usage detected: ${usedMB.toFixed(2)}MB`);
                    memoryWarningShown = true;
                    aggressiveCleanup();
                    forceCleanup();
                    cleanupPowerUps();
                }
                
                // Reset warning if memory goes back down
                if (usedMB < 120 && memoryWarningShown) {
                    memoryWarningShown = false;
                }
            }
        }
        
        // PERF: Tracks entity counts, triggers aggressiveCleanup/forceCleanup when over thresholds.
        // Risks: unbounded arrays (galaxy proj/bombs, activeBursts, etc.) ‚Äî all now capped or cleaned.
        function monitorPerformance() {
            const totalObjects = coins.length + obstacles.length + bowlingBallObstacles.length + 
                               batGangs.length + powerUps.length + itemBoxes.length + greenVials.length + 
                               activeProjectiles.length + dragons.length + aiMotorcycles.length +
                               batAlleyBats.length + bowlingBallAlleyBalls.length +
                               finalBats.length + galaxyShips.length + galaxyProjectiles.length +
                               galaxyBombs.length + activeBursts.length + boostParticles.length +
                               etherTrails.length + speedLines.length + lensFlares.length +
                               pepeEnemies.length + (typeof meteors !== 'undefined' ? meteors.length : 0);
            
            // Thresholds: level 25+ has 100‚Äì180 objects normally; don‚Äôt treat that as ‚Äúwarning‚Äù
            const envCount = (typeof buildingSegments !== 'undefined' ? buildingSegments.length : 0) +
                            (typeof roadSegments !== 'undefined' ? roadSegments.length : 0);
            const warningThreshold = level >= 15 ? 200 : 180;
            const criticalThreshold = level >= 15 ? 320 : 280;
            const envThreshold = 25;
                               
            if (totalObjects > warningThreshold || envCount > envThreshold) {
                if (totalObjects > warningThreshold) console.warn(`[PERF] ${totalObjects} entities @ L${level}`);
                aggressiveCleanup();
                if (totalObjects > criticalThreshold) {
                    console.error(`CRITICAL: ${totalObjects} objects! Running force cleanup...`);
                    cleanupScene();
                    cleanupPowerUps();
                    forceCleanup();
                }
            }

            const sceneLimit = 200;
            if (scene.children.length > sceneLimit) {
                console.warn(`[PERF] Scene ${scene.children.length} children - forcing cleanup`);
                aggressiveCleanup();
                
                // Remove old non-essential objects
                for (let i = scene.children.length - 1; i >= 0; i--) {
                    const child = scene.children[i];
                    if (child.userData && child.userData.disposable && 
                        child.position.z > (playerMotorcycle ? playerMotorcycle.position.z + 50 : 50)) {
                        scene.remove(child);
                        disposeObject(child);
                    }
                }
            }
            
            // Call existing memory monitoring
            monitorMemoryLeaks();
        }

        // Spawn throttling: keep 25+ feeling populated (was over‚Äëcut and killed spawns)
        function shouldSpawnObject(spawnRate, level) {
            let levelMultiplier = 0;
            if (level > 35) {
                levelMultiplier = Math.min((level - 35) / 25, 0.5);
            } else if (level > 25) {
                levelMultiplier = Math.min((level - 25) / 50, 0.2);
            } else if (level > 18) {
                levelMultiplier = Math.min((level - 18) / 60, 0.12);
            }
            const adjustedRate = spawnRate * (1 + levelMultiplier);
            return Math.random() < 1 / adjustedRate;
        }

        function createCoin() {
            return getPooledObject('coins', () => {
                const coinGroup = new THREE.Group();
                
                // SILVER COIN - Main collectible (bright, round, shiny)
                const coinGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 24);
                const coinMaterial = new THREE.MeshStandardMaterial({
                    color: 0xe8e8e8, // Bright silver
                    metalness: 0.95,
                    roughness: 0.08,
                    emissive: 0xffffff,
                    emissiveIntensity: 0.4
                });
                const coin = new THREE.Mesh(coinGeometry, coinMaterial);
                coin.rotation.x = Math.PI / 2;
                coinGroup.add(coin);
                
                // Shiny edge ring
                const edgeGeometry = new THREE.TorusGeometry(0.38, 0.04, 12, 24);
                const edgeMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    metalness: 1.0,
                    roughness: 0.05,
                    emissive: 0xcccccc,
                    emissiveIntensity: 0.3
                });
                const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
                edge.rotation.x = Math.PI / 2;
                coinGroup.add(edge);
                
                // Bright glow around coin
                const glowGeometry = new THREE.SphereGeometry(0.5, 12, 12);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.2
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                coinGroup.add(glow);
                
                return coinGroup;
            });
        }

        // ICE GAP - Deadly hole in the frozen road
        function createIceGap(width, zPosition) {
            const gapGroup = new THREE.Group();
            
            // Create dark void effect - deep blue/black hole (visible from above)
            const gapGeometry = new THREE.PlaneGeometry(width, 4); // 4 units deep
            const gapMaterial = new THREE.MeshStandardMaterial({
                color: 0x000811, // Deep dark blue-black void
                emissive: 0x001133,
                emissiveIntensity: 0.4,
                transparent: true,
                opacity: 0.95,
                side: THREE.DoubleSide
            });
            const gap = new THREE.Mesh(gapGeometry, gapMaterial);
            gap.rotation.x = Math.PI / 2;
            gap.position.y = -0.45; // Just below road surface
            gapGroup.add(gap);
            
            // Add bright cyan ice edge glow (warning effect) - pulsing
            const edgeGeometry = new THREE.PlaneGeometry(width + 0.3, 0.4);
            const edgeMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 1.2,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const topEdge = new THREE.Mesh(edgeGeometry, edgeMaterial);
            topEdge.rotation.x = Math.PI / 2;
            topEdge.position.y = -0.25;
            topEdge.userData.pulsePhase = Math.random() * Math.PI * 2;
            gapGroup.add(topEdge);
            
            const bottomEdge = new THREE.Mesh(edgeGeometry, edgeMaterial);
            bottomEdge.rotation.x = Math.PI / 2;
            bottomEdge.position.y = -0.65;
            bottomEdge.userData.pulsePhase = Math.random() * Math.PI * 2;
            gapGroup.add(bottomEdge);
            
            // Add side edges for visibility
            const sideEdgeGeometry = new THREE.PlaneGeometry(0.3, 4);
            const leftEdge = new THREE.Mesh(sideEdgeGeometry, edgeMaterial);
            leftEdge.rotation.x = Math.PI / 2;
            leftEdge.rotation.z = Math.PI / 2;
            leftEdge.position.set(-width / 2, -0.45, 0);
            gapGroup.add(leftEdge);
            
            const rightEdge = new THREE.Mesh(sideEdgeGeometry, edgeMaterial);
            rightEdge.rotation.x = Math.PI / 2;
            rightEdge.rotation.z = Math.PI / 2;
            rightEdge.position.set(width / 2, -0.45, 0);
            gapGroup.add(rightEdge);
            
            // Add depth particles (falling ice effect)
            for (let i = 0; i < 8; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.08, 4, 4);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0x0044aa,
                    transparent: true,
                    opacity: 0.6
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.set(
                    (Math.random() - 0.5) * width * 0.9,
                    -0.5 - Math.random() * 3,
                    (Math.random() - 0.5) * 1.5
                );
                particle.userData.fallSpeed = 0.01 + Math.random() * 0.02;
                gapGroup.add(particle);
            }
            
            gapGroup.position.z = zPosition;
            gapGroup.userData.width = width;
            gapGroup.userData.isIceGap = true;
            gapGroup.userData.depth = 4;
            gapGroup.userData.animationPhase = Math.random() * Math.PI * 2;
            
            return gapGroup;
        }

        function createObstacle() {
            // BIOME-SPECIFIC OBSTACLES (Sunset Tundra boulders removed ‚Äî use default Krypton)
            if (currentBiome === 'northernLights') {
                // NORTHERN LIGHTS: Glowing obstacles
                const glowGroup = new THREE.Group();
                const glowGeometry = new THREE.IcosahedronGeometry(0.7, 0);
                const glowMaterial = new THREE.MeshStandardMaterial({
                    color: Math.random() > 0.5 ? 0x00ff88 : 0xff00ff, // Green or pink
                    metalness: 0.5,
                    roughness: 0.2,
                    emissive: Math.random() > 0.5 ? 0x00ff88 : 0xff00ff,
                    emissiveIntensity: 1.5,
                    transparent: true,
                    opacity: 0.9
                });
                const glowObstacle = new THREE.Mesh(glowGeometry, glowMaterial);
                glowObstacle.position.y = 0.7;
                glowGroup.add(glowObstacle);
                glowGroup.userData.speed = baseMoveSpeed * obstacleSpeedMultiplier;
                return glowGroup;
            }
            
            // Default: Krypton crystal (for arctic and blizzard)
            const kryptonGroup = new THREE.Group();
            
            // Create crystalline Krypton structure
            const kryptonMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ff88, // Bright green-cyan for Krypton
                metalness: 0.7,
                roughness: 0.1,
                emissive: 0x00ffaa, // Strong emissive glow
                emissiveIntensity: 1.2,
                transparent: true,
                opacity: 0.9
            });

            // Main crystal body - octahedron shape
            const kryptonGeometry = new THREE.OctahedronGeometry(0.6, 0);
            const kryptonMesh = new THREE.Mesh(kryptonGeometry, kryptonMaterial);
            kryptonMesh.position.y = 0.6; 
            kryptonGroup.add(kryptonMesh);

            // Smaller crystal satellites
            for (let i = 0; i < 4; i++) {
                const smallCrystal = new THREE.Mesh(
                    new THREE.OctahedronGeometry(0.2, 0), 
                    kryptonMaterial
                );
                const angle = (i / 4) * Math.PI * 2;
                smallCrystal.position.set(
                    Math.cos(angle) * 0.8,
                    0.3,
                    Math.sin(angle) * 0.8
                );
                kryptonGroup.add(smallCrystal);
            }

            // Energy core
            const coreGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const coreMaterial = new THREE.MeshStandardMaterial({
                color: 0x88ffff,
                emissive: 0x88ffff,
                emissiveIntensity: 2.0,
                metalness: 0,
                roughness: 1,
                transparent: true,
                opacity: 0.7
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            core.position.y = 0.6;
            kryptonGroup.add(core);

            kryptonGroup.position.y = 0.5;
            kryptonGroup.userData.isPlayerObstacle = false; // Spawned obstacles are deadly to player
            kryptonGroup.userData.rotationSpeed = 0.02; // Add rotation for visual effect
            return kryptonGroup;
        }



         function createBowlingBallObstacle() {
             // Snow ball ‚Äî instantly kills on contact (same as before)
             const ballGroup = new THREE.Group();
             
             const geometry = new THREE.SphereGeometry(0.8, 16, 16);
             const material = new THREE.MeshStandardMaterial({
                 color: 0xf0f8ff, // Snow white / Alice blue
                 metalness: 0.1,
                 roughness: 0.85,
                 emissive: 0xe0f4ff,
                 emissiveIntensity: 0.15
             });
             const snowBall = new THREE.Mesh(geometry, material);
             ballGroup.add(snowBall);
             
             // Frost / snow shimmer outline
             const coronaGeometry = new THREE.SphereGeometry(0.82, 16, 16);
             const coronaMaterial = new THREE.MeshStandardMaterial({
                 color: 0xb0e0f0,
                 transparent: true,
                 opacity: 0.2,
                 side: THREE.BackSide,
                 emissive: 0xa0d8f0,
                 emissiveIntensity: 0.15,
                 metalness: 0,
                 roughness: 1
             });
             const corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
             ballGroup.add(corona);
             
             ballGroup.position.y = 0.8;
             return ballGroup;
         }

        function createBatGang() {
            const batGang = new THREE.Group();
            const numBats = 3 + Math.floor(Math.random() * 3);
            const batColor = 0xaa0000; // Slightly brighter red

            for (let i = 0; i < numBats; i++) {
                const batGeometry = new THREE.ConeGeometry(0.3, 0.5, 8);
                const batMaterial = new THREE.MeshStandardMaterial({
                    color: batColor,
                    metalness: 0.6,
                    roughness: 0.5,
                    emissive: 0x550000,
                    emissiveIntensity: 0.4
                });
                const bat = new THREE.Mesh(batGeometry, batMaterial);
                bat.position.set((Math.random() - 0.5) * 1.5, (Math.random() - 0.5) * 1.5, (Math.random() - 0.5) * 1.5);
                bat.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                batGang.add(bat);
            }
            batGang.position.y = 2;
            batGang.userData.speed = 0.2 + Math.random() * 0.1;
            batGang.userData.attackPattern = Math.random() < 0.5 ? 'swoop' : 'straight';
            batGang.userData.swoopPhase = Math.random() * Math.PI * 2;
            batGang.userData.amplitude = 1 + Math.random();
            batGang.userData.frequency = 0.05 + Math.random() * 0.05;
            return batGang;
        }

        // BAT ALLEY SYSTEM - Single bats for levels 65-70
        function createAlleyBat() {
            const batGroup = new THREE.Group();
            const batColor = 0xff0000; // Bright red for alley bats
            
            // Single large bat
            const batGeometry = new THREE.ConeGeometry(0.4, 0.6, 8);
            const batMaterial = new THREE.MeshStandardMaterial({
                color: batColor,
                metalness: 0.6,
                roughness: 0.5,
                emissive: 0xff0000,
                emissiveIntensity: 0.8
            });
            const bat = new THREE.Mesh(batGeometry, batMaterial);
            batGroup.add(bat);
            
            batGroup.position.y = 2;
            batGroup.userData.speed = 0.15; // Slower than bat gangs for dodging challenge
            batGroup.userData.isAlleyBat = true;
            return batGroup;
        }

        // BOWLING BALL ALLEY SYSTEM - Snow balls for levels 75-80 (instant kill)
        function createAlleyBowlingBall() {
            const ballGroup = new THREE.Group();
            
            const geometry = new THREE.SphereGeometry(1.0, 16, 16);
            const material = new THREE.MeshStandardMaterial({
                color: 0xf0f8ff,
                metalness: 0.1,
                roughness: 0.85,
                emissive: 0xe0f4ff,
                emissiveIntensity: 0.15
            });
            const snowBall = new THREE.Mesh(geometry, material);
            ballGroup.add(snowBall);
            
            const coronaGeometry = new THREE.SphereGeometry(1.05, 16, 16);
            const coronaMaterial = new THREE.MeshStandardMaterial({
                color: 0xb0e0f0,
                transparent: true,
                opacity: 0.25,
                side: THREE.BackSide,
                emissive: 0xa0d8f0,
                emissiveIntensity: 0.2,
                metalness: 0,
                roughness: 1
            });
            const corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
            ballGroup.add(corona);
            
            ballGroup.position.y = 1.0;
            ballGroup.userData.isAlleyBall = true;
            return ballGroup;
        }

        // FINAL BAT - Level 85 special bat that attacks directly
        function createFinalBat() {
            const batGroup = new THREE.Group();
            const batColor = 0xff00ff; // Magenta for final bat
            
            // Large aggressive bat
            const batGeometry = new THREE.ConeGeometry(0.6, 0.8, 8);
            const batMaterial = new THREE.MeshStandardMaterial({
                color: batColor,
                metalness: 0.7,
                roughness: 0.3,
                emissive: 0xff00ff,
                emissiveIntensity: 1.5
            });
            const bat = new THREE.Mesh(batGeometry, batMaterial);
            batGroup.add(bat);
            
            // Add energy aura
            const auraGeometry = new THREE.SphereGeometry(1.0, 8, 8);
            const auraMaterial = new THREE.MeshStandardMaterial({
                color: 0xff00ff,
                transparent: true,
                opacity: 0.3,
                emissive: 0xff00ff,
                emissiveIntensity: 0.5,
                metalness: 0,
                roughness: 1
            });
            const aura = new THREE.Mesh(auraGeometry, auraMaterial);
            batGroup.add(aura);
            
            batGroup.position.y = 4;
            batGroup.userData.speed = 1.8; // Fast direct attack
            batGroup.userData.isFinalBat = true;
            batGroup.userData.isAttacking = false;
            batGroup.userData.pulsePhase = 0;
            return batGroup;
        }

        function createItemBox() {
            const rubyGroup = new THREE.Group();
            
            // STUNNING RUBY GEM DESIGN
            // Main ruby body - diamond/gem shape using dodecahedron
            const rubyGeometry = new THREE.DodecahedronGeometry(0.8, 0);
            const rubyMaterial = new THREE.MeshStandardMaterial({
                color: 0xff0040, // Deep ruby red
                metalness: 0.1,
                roughness: 0.05, // Very smooth for gem-like reflections
                emissive: 0xff0020, // Red glow
                emissiveIntensity: 1.2,
                transparent: true,
                opacity: 0.95
            });
            const ruby = new THREE.Mesh(rubyGeometry, rubyMaterial);
            rubyGroup.add(ruby);
            
            // Inner crystal core - FIXED: Use MeshStandardMaterial for emissive
            const coreGeometry = new THREE.OctahedronGeometry(0.5, 0);
            const coreMaterial = new THREE.MeshStandardMaterial({
                color: 0xff4080,
                emissive: 0xff4080,
                emissiveIntensity: 2.0,
                transparent: true,
                opacity: 0.8
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            rubyGroup.add(core);
            
            // Outer energy aura - FIXED: Use MeshStandardMaterial for emissive
            const auraGeometry = new THREE.IcosahedronGeometry(1.2, 0);
            const auraMaterial = new THREE.MeshStandardMaterial({
                color: 0xff8888,
                emissive: 0xff4444,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            const aura = new THREE.Mesh(auraGeometry, auraMaterial);
            rubyGroup.add(aura);
            
            rubyGroup.position.y = 0.5;
            rubyGroup.userData.rotationSpeed = 0.03;
            rubyGroup.userData.pulsePhase = Math.random() * Math.PI * 2; // Random start phase
            return rubyGroup;
        }

        function createGreenVial() {
            // GOLD COIN - Rare power-up (replaces green vial)
            const coinGroup = new THREE.Group();
            
            // Main gold coin disc - LARGER and SHINIER than silver
            const coinGeometry = new THREE.CylinderGeometry(0.55, 0.55, 0.12, 32);
            const coinMaterial = new THREE.MeshStandardMaterial({
                color: 0xffd700, // Gold color
                metalness: 0.98,
                roughness: 0.05,
                emissive: 0xffaa00,
                emissiveIntensity: 0.6
            });
            const coinDisc = new THREE.Mesh(coinGeometry, coinMaterial);
            coinDisc.rotation.x = Math.PI / 2;
            coinGroup.add(coinDisc);
            
            // Raised golden edge ring
            const edgeGeometry = new THREE.TorusGeometry(0.53, 0.05, 12, 32);
            const edgeMaterial = new THREE.MeshStandardMaterial({
                color: 0xffcc00,
                metalness: 1.0,
                roughness: 0.02,
                emissive: 0xffaa00,
                emissiveIntensity: 0.5
            });
            const coinEdge = new THREE.Mesh(edgeGeometry, edgeMaterial);
            coinEdge.rotation.x = Math.PI / 2;
            coinGroup.add(coinEdge);
            
            // Center star emblem
            const starGeometry = new THREE.OctahedronGeometry(0.2);
            const starMaterial = new THREE.MeshStandardMaterial({
                color: 0xffff00,
                metalness: 0.9,
                roughness: 0.1,
                emissive: 0xffff00,
                emissiveIntensity: 1.0
            });
            const star = new THREE.Mesh(starGeometry, starMaterial);
            star.scale.set(1, 1, 0.4);
            coinGroup.add(star);
            
            // Bright golden glow effect
            const glowGeometry = new THREE.SphereGeometry(0.7, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xffdd00,
                transparent: true,
                opacity: 0.35
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            coinGroup.add(glow);
            
            // Bright shine highlight
            const highlightGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const highlightMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 1.0
            });
            const highlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
            highlight.position.set(0.2, 0.15, 0.08);
            coinGroup.add(highlight);

            coinGroup.position.y = 0.6;
            coinGroup.userData.rotationSpeed = 0.06;
            coinGroup.userData.pulsePhase = Math.random() * Math.PI * 2;
            coinGroup.userData.isGoldCoin = true;
            return coinGroup;
        }

        // DRAGON VISUAL ENHANCEMENT: Updated createDragon function
        function createDragon(tieFighterType = 0) { // 0 = first tieFighter, 1 = mid tieFighter, 2 = final tieFighter
            const tieFighterGroup = new THREE.Group();
            tieFighterGroup.userData.segments = [];
            tieFighterGroup.userData.wingFlapAngle = 0;
            tieFighterGroup.userData.wingFlapDirection = 1;
            tieFighterGroup.userData.wingFlapSpeed = 0.08;
            tieFighterGroup.userData.bodyWaveAngle = 0;
            tieFighterGroup.userData.tieFighterType = tieFighterType;
            tieFighterGroup.userData.stalkPhase = 0;
            tieFighterGroup.userData.stalkSpeed = tieFighterType === 2 ? 0.06 : tieFighterType === 1 ? 0.045 : 0.03;
            tieFighterGroup.userData.stalkAmplitude = tieFighterType === 2 ? 6 : tieFighterType === 1 ? 4.5 : 3;
            tieFighterGroup.userData.circlePhase = 0;
            tieFighterGroup.userData.circleSpeed = tieFighterType === 2 ? 0.03 : tieFighterType === 1 ? 0.022 : 0.015;
            tieFighterGroup.userData.circleRadius = tieFighterType === 2 ? 12 : tieFighterType === 1 ? 9 : 6;
            tieFighterGroup.userData.attackMode = 'stalking';
            tieFighterGroup.userData.attackTimer = 0;
            tieFighterGroup.userData.attackInterval = tieFighterType === 2 ? 150 : tieFighterType === 1 ? 200 : 250;
            tieFighterGroup.userData.faceAnimationPhase = 0;
            tieFighterGroup.userData.isCharging = false;
            
            // BERSERKER FURY MODE - Level 90 dragon only
            if (tieFighterType === 2) {
                tieFighterGroup.userData.berserkerFury = false;
                tieFighterGroup.userData.berserkerTimer = 0;
                tieFighterGroup.userData.berserkerTriggered = false;
                tieFighterGroup.userData.chargeCount = 0;
                tieFighterGroup.userData.maxCharges = 3;
                tieFighterGroup.userData.chargeCooldown = 0;
            }

            const numSegments = tieFighterType === 2 ? 40 : tieFighterType === 1 ? 30 : 20;
            const segmentRadius = tieFighterType === 2 ? 2.0 : tieFighterType === 1 ? 1.3 : 0.6;
            const segmentSpacing = tieFighterType === 2 ? -2.0 : tieFighterType === 1 ? -1.5 : -1.0;

            // Materials
            const blackMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0x000000,
                emissiveIntensity: 0.1
            });

            const neonMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000,
                emissive: 0xff4500,
                emissiveIntensity: 1.5,
                metalness: 0.3,
                roughness: 0.5,
            });

            for (let i = 0; i < numSegments; i++) {
                const segmentGeometry = new THREE.SphereGeometry(
                    segmentRadius * (1 - (i / numSegments) * 0.3),
                    16, 16
                );
                const material = (i % 2 === 0) ? neonMaterial.clone() : blackMaterial.clone();
                const segment = new THREE.Mesh(segmentGeometry, material);
                segment.position.z = i * segmentSpacing;
                tieFighterGroup.add(segment);
                tieFighterGroup.userData.segments.push(segment);
            }

            // Enhanced facial features
            const headSegment = tieFighterGroup.userData.segments[0];
            const headGroup = new THREE.Group();

            const headGeometry = new THREE.BoxGeometry(segmentRadius * 2, segmentRadius * 1.5, segmentRadius * 2);
            const head = new THREE.Mesh(headGeometry, neonMaterial.clone());
            head.position.z = -segmentRadius;
            headGroup.add(head);

            const snoutGeometry = new THREE.ConeGeometry(segmentRadius * 1.2, segmentRadius * 2.5, 8);
            const snout = new THREE.Mesh(snoutGeometry, neonMaterial.clone());
            snout.position.z = -segmentRadius * 2;
            snout.rotation.x = Math.PI / 2;
            headGroup.add(snout);

            const jawGeometry = new THREE.BoxGeometry(segmentRadius * 1.8, segmentRadius * 0.4, segmentRadius * 1.2);
            const jaw = new THREE.Mesh(jawGeometry, neonMaterial.clone());
            jaw.position.set(0, -segmentRadius * 0.6, -segmentRadius * 1.5);
            jaw.userData.baseY = jaw.position.y;
            headGroup.add(jaw);
            tieFighterGroup.userData.jaw = jaw;

            const eyeGeometry = new THREE.SphereGeometry(segmentRadius * 0.4, 16, 16);
            const eyeMaterial = new THREE.MeshStandardMaterial({
                color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 2.0, metalness: 0, roughness: 1
            });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial.clone());
            leftEye.position.set(-segmentRadius * 0.7, segmentRadius * 0.4, -segmentRadius * 0.8);
            headGroup.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeometry.clone(), eyeMaterial.clone());
            rightEye.position.set(segmentRadius * 0.7, segmentRadius * 0.4, -segmentRadius * 0.8);
            headGroup.add(rightEye);
            tieFighterGroup.userData.eyes = [leftEye, rightEye];

            const whiskerGeometry = new THREE.CylinderGeometry(0.05, 0.05, segmentRadius * 4, 8);
            const whiskerMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000, emissive: 0xff4500, emissiveIntensity: 1.0, metalness: 0.5, roughness: 0.3
            });
            const leftWhisker1 = new THREE.Mesh(whiskerGeometry, whiskerMaterial.clone());
            leftWhisker1.position.set(-segmentRadius * 0.6, segmentRadius * 0.3, -segmentRadius * 2);
            leftWhisker1.rotation.z = Math.PI / 6;
            headGroup.add(leftWhisker1);
            const leftWhisker2 = new THREE.Mesh(whiskerGeometry.clone(), whiskerMaterial.clone());
            leftWhisker2.position.set(-segmentRadius * 0.6, segmentRadius * 0.3, -segmentRadius * 2);
            leftWhisker2.rotation.z = Math.PI / 4;
            headGroup.add(leftWhisker2);
            const rightWhisker1 = new THREE.Mesh(whiskerGeometry.clone(), whiskerMaterial.clone());
            rightWhisker1.position.set(segmentRadius * 0.6, segmentRadius * 0.3, -segmentRadius * 2);
            rightWhisker1.rotation.z = -Math.PI / 6;
            headGroup.add(rightWhisker1);
            const rightWhisker2 = new THREE.Mesh(whiskerGeometry.clone(), whiskerMaterial.clone());
            rightWhisker2.position.set(segmentRadius * 0.6, segmentRadius * 0.3, -segmentRadius * 2);
            rightWhisker2.rotation.z = -Math.PI / 4;
            headGroup.add(rightWhisker2);

            tieFighterGroup.userData.whiskers = [leftWhisker1, leftWhisker2, rightWhisker1, rightWhisker2];
            headSegment.add(headGroup);

            // Remove wings and add flowing body segments
            tieFighterGroup.userData.bodyWaveAngle = 0;
            tieFighterGroup.userData.waveSpeed = 0.05;
            tieFighterGroup.userData.waveAmplitude = 0.3;

            tieFighterGroup.rotation.y = Math.PI;
            tieFighterGroup.userData.speed = tieFighterType === 2 ? 2.5 : tieFighterType === 1 ? 2.0 : 1.5; // MASSIVELY INCREASED BASE SPEEDS
            tieFighterGroup.userData.verticalSpeed = 0.02;
            tieFighterGroup.userData.verticalPhase = 0;
            tieFighterGroup.userData.amplitude = tieFighterType === 2 ? 5 : tieFighterType === 1 ? 3.5 : 2;
            tieFighterGroup.userData.frequency = 0.05;
            tieFighterGroup.userData.stalkDistance = tieFighterType === 2 ? 60 : tieFighterType === 1 ? 45 : 30;
            tieFighterGroup.userData.catchUpSpeed = tieFighterType === 2 ? 0.8 : tieFighterType === 1 ? 0.6 : 0.4;
            neonMaterial.dispose();
            blackMaterial.dispose();
            eyeMaterial.dispose();
            whiskerMaterial.dispose();
            return tieFighterGroup;
        }

        // GIANT PEPE FROG ENEMY (Level 40+) ‚Äî pepe.html asset, detailed face + bike, slow laser-guided approach, steals ALL coins
        function createPepeEnemy() {
            const pepeGroup = new THREE.Group();
            
            // ‚Äî‚Äî BIKE FIRST (pepe.html cruiser style) ‚Äî‚Äî‚Äî
            const bikeBodyMat = new THREE.MeshStandardMaterial({
                color: 0x00cc66,
                metalness: 0.3,
                roughness: 0.6,
                emissive: 0x00cc66,
                emissiveIntensity: 0.2
            });
            const wheelMat = new THREE.MeshStandardMaterial({
                color: 0x1a3a2a,
                metalness: 0.4,
                roughness: 0.7,
                emissive: 0x1a3a2a,
                emissiveIntensity: 0.1
            });
            const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 24);
            
            const bikeBodyGeo = new THREE.BoxGeometry(0.6, 0.3, 1.8);
            const bikeBody = new THREE.Mesh(bikeBodyGeo, bikeBodyMat);
            bikeBody.position.set(0, 0.15, 0);
            pepeGroup.add(bikeBody);
            
            const handlebarGeo = new THREE.CylinderGeometry(0.05, 0.05, 1.2, 10);
            const handlebarMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.9, roughness: 0.1 });
            const handlebars = new THREE.Mesh(handlebarGeo, handlebarMat);
            handlebars.rotation.x = Math.PI / 2;
            handlebars.position.set(0, 0.6, 0.4);
            pepeGroup.add(handlebars);
            
            const frontWheel = new THREE.Mesh(wheelGeo, wheelMat);
            frontWheel.rotation.x = Math.PI / 2;
            frontWheel.position.set(0, 0, 0.7);
            pepeGroup.add(frontWheel);
            const rearWheel = new THREE.Mesh(wheelGeo, wheelMat);
            rearWheel.rotation.x = Math.PI / 2;
            rearWheel.position.set(0, 0, -0.7);
            pepeGroup.add(rearWheel);
            
            // ‚Äî‚Äî FROG RIDER ON TOP (pepe.html createPhotorealisticBear) ‚Äî‚Äî‚Äî
            const skinMaterial = new THREE.MeshStandardMaterial({
                color: 0x00cc66,
                roughness: 0.7,
                metalness: 0.1,
                emissive: 0x00cc66,
                emissiveIntensity: 0.2,
                transparent: true,
                opacity: 0.98,
                side: THREE.DoubleSide
            });
            const skinCanvas = document.createElement('canvas');
            skinCanvas.width = 512;
            skinCanvas.height = 512;
            const skinCtx = skinCanvas.getContext('2d');
            skinCtx.fillStyle = '#00cc66';
            skinCtx.fillRect(0, 0, 512, 512);
            for (let i = 0; i < 1500; i++) {
                skinCtx.fillStyle = `rgba(${Math.random() * 50}, ${Math.random() * 100 + 150}, ${Math.random() * 50 + 100}, ${Math.random() * 0.4 + 0.2})`;
                skinCtx.beginPath();
                skinCtx.arc(Math.random() * 512, Math.random() * 512, Math.random() * 3 + 1, 0, Math.PI * 2);
                skinCtx.fill();
            }
            const skinTexture = new THREE.CanvasTexture(skinCanvas);
            skinTexture.wrapS = THREE.RepeatWrapping;
            skinTexture.wrapT = THREE.RepeatWrapping;
            skinMaterial.map = skinTexture;
            
            const frog = new THREE.Group();
            frog.position.set(0, 0.7, 0); // Sit on bike
            
            // Head (wide, flat ‚Äî pepe.html)
            const headGeo = new THREE.SphereGeometry(0.4, 32, 24);
            headGeo.scale(1.3, 0.8, 1.1);
            const head = new THREE.Mesh(headGeo, skinMaterial);
            head.position.set(0, 0.5, 0.1);
            frog.add(head);
            
            // Mouth (wide meme smile)
            const mouthGeo = new THREE.SphereGeometry(0.12, 16, 12);
            mouthGeo.scale(2.5, 0.4, 1);
            const mouthMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.9, metalness: 0 });
            const mouth = new THREE.Mesh(mouthGeo, mouthMat);
            mouth.position.set(0, 0.35, 0.28);
            frog.add(mouth);
            
            // Eyes ‚Äî LARGE, visible (pepe.html + bigger)
            const eyeballGeo = new THREE.SphereGeometry(0.14, 20, 16);
            eyeballGeo.scale(1, 1.25, 1);
            const eyeballMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.05,
                metalness: 0.05,
                emissive: 0xffffff,
                emissiveIntensity: 0.5
            });
            const leftEye = new THREE.Mesh(eyeballGeo, eyeballMat);
            leftEye.position.set(-0.2, 0.62, 0.24);
            frog.add(leftEye);
            const rightEye = new THREE.Mesh(eyeballGeo, eyeballMat);
            rightEye.position.set(0.2, 0.62, 0.24);
            frog.add(rightEye);
            
            // Pupils ‚Äî clearly visible
            const pupilGeo = new THREE.SphereGeometry(0.09, 12, 8);
            const pupilMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.6, metalness: 0 });
            const leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
            leftPupil.position.set(-0.2, 0.62, 0.3);
            frog.add(leftPupil);
            const rightPupil = new THREE.Mesh(pupilGeo, pupilMat);
            rightPupil.position.set(0.2, 0.62, 0.3);
            frog.add(rightPupil);
            
            // Eye reflections ‚Äî BIGGER, brighter (pepe.html)
            const reflGeo = new THREE.SphereGeometry(0.045, 10, 8);
            const reflMat = new THREE.MeshStandardMaterial({
                color: 0x00ff88,
                emissive: 0x00ff88,
                emissiveIntensity: 1.2
            });
            const leftRefl = new THREE.Mesh(reflGeo, reflMat);
            leftRefl.position.set(-0.17, 0.65, 0.31);
            frog.add(leftRefl);
            const rightRefl = new THREE.Mesh(reflGeo, reflMat);
            rightRefl.position.set(0.23, 0.65, 0.31);
            frog.add(rightRefl);
            
            // Body
            const bodyGeo = new THREE.SphereGeometry(0.45, 24, 16);
            bodyGeo.scale(1.1, 1.0, 0.9);
            const body = new THREE.Mesh(bodyGeo, skinMaterial);
            body.position.set(0, 0, 0);
            frog.add(body);
            
            // Arms + webbed hands (gripping handlebars)
            const armGeo = new THREE.CylinderGeometry(0.1, 0.12, 0.5, 12);
            const leftArm = new THREE.Mesh(armGeo, skinMaterial);
            leftArm.position.set(-0.3, 0.15, 0.4);
            leftArm.rotation.z = 0.5;
            leftArm.rotation.x = -0.3;
            frog.add(leftArm);
            const rightArm = new THREE.Mesh(armGeo, skinMaterial);
            rightArm.position.set(0.3, 0.15, 0.4);
            rightArm.rotation.z = -0.5;
            rightArm.rotation.x = -0.3;
            frog.add(rightArm);
            const handGeo = new THREE.SphereGeometry(0.12, 16, 12);
            handGeo.scale(1.0, 0.9, 1.2);
            const leftHand = new THREE.Mesh(handGeo, skinMaterial);
            leftHand.position.set(-0.45, 0.3, 0.7);
            frog.add(leftHand);
            const rightHand = new THREE.Mesh(handGeo, skinMaterial);
            rightHand.position.set(0.45, 0.3, 0.7);
            frog.add(rightHand);
            
            pepeGroup.add(frog);
            
            pepeGroup.scale.set(3, 3, 3);
            pepeGroup.rotation.y = Math.PI; // Face player (head-on)
            pepeGroup.userData.isPepeEnemy = true;
            pepeGroup.userData.collisionRadius = 4;
            return pepeGroup;
        }

        // NEW GALAXY ZONE: Create AI Wars style ships
        function createGalaxyShip() {
            const shipGroup = new THREE.Group();
            
            // Ship hull with AI Wars aesthetic
            const hullGeometry = new THREE.BoxGeometry(2, 0.8, 4);
            const hullMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a2e,
                metalness: 0.7,
                roughness: 0.3,
                emissive: 0x00ffff,
                emissiveIntensity: 0.2
            });
            const hull = new THREE.Mesh(hullGeometry, hullMaterial);
            shipGroup.add(hull);
            
            // Wings with neon edges
            const wingGeometry = new THREE.BoxGeometry(4, 0.2, 1.5);
            const wingMaterial = new THREE.MeshStandardMaterial({
                color: 0x0a0a1a,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0xff00ff,
                emissiveIntensity: 0.3
            });
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-3, 0, 0);
            shipGroup.add(leftWing);
            
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(3, 0, 0);
            shipGroup.add(rightWing);
            
            // Cockpit with glowing effect
            const cockpitGeometry = new THREE.SphereGeometry(0.6, 8, 8);
            const cockpitMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 1.0,
                metalness: 0,
                roughness: 1,
                transparent: true,
                opacity: 0.8
            });
            const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
            cockpit.position.set(0, 0.2, 1.5);
            shipGroup.add(cockpit);
            
            // Engine thrusters
            const thrusterGeometry = new THREE.CylinderGeometry(0.3, 0.5, 1, 6);
            const thrusterMaterial = new THREE.MeshStandardMaterial({
                color: 0xff4500,
                emissive: 0xff4500,
                emissiveIntensity: 1.5,
                metalness: 0,
                roughness: 1
            });
            const leftThruster = new THREE.Mesh(thrusterGeometry, thrusterMaterial);
            leftThruster.position.set(-1.5, -0.2, -2);
            leftThruster.rotation.x = Math.PI / 2;
            shipGroup.add(leftThruster);
            
            const rightThruster = new THREE.Mesh(thrusterGeometry, thrusterMaterial);
            rightThruster.position.set(1.5, -0.2, -2);
            rightThruster.rotation.x = Math.PI / 2;
            shipGroup.add(rightThruster);
            
            // Ship behavior
            shipGroup.userData.speed = 0.3 + Math.random() * 0.2;
            shipGroup.userData.shootTimer = 0;
            shipGroup.userData.shootInterval = 80 + Math.random() * 40;
            shipGroup.userData.driftAngle = Math.random() * Math.PI * 2;
            shipGroup.userData.driftSpeed = 0.02;
            
            return shipGroup;
        }

        // Create galaxy zone projectile
        function createGalaxyProjectile(position, direction) {
            const projectileGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const projectileMaterial = new THREE.MeshStandardMaterial({
                color: 0xff00ff,
                emissive: 0xff00ff,
                emissiveIntensity: 1.5,
                metalness: 0,
                roughness: 1
            });
            const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
            projectile.position.copy(position);
            projectile.userData.velocity = direction.clone().multiplyScalar(1.5);
            projectile.userData.life = 0;
            projectile.userData.maxLife = 300;
            
            return projectile;
        }

        // Create red vial bomb dropped by galaxy ships
        function createGalaxyBomb(position) {
            const bombGroup = new THREE.Group();
            
            // Red vial body - MUCH LARGER AND BRIGHTER
            const vialGeometry = new THREE.CylinderGeometry(0.8, 0.8, 2.5, 8); // Much larger: 0.3->0.8, 1.2->2.5
            const vialMaterial = new THREE.MeshStandardMaterial({ // MeshStandardMaterial supports emissive/glow
                color: 0xff0000, // Bright red instead of dark red
                emissive: 0xff0000,
                emissiveIntensity: 1.5, // Much brighter
                metalness: 0,
                roughness: 1,
                transparent: true,
                opacity: 0.9
            });
            const vial = new THREE.Mesh(vialGeometry, vialMaterial);
            bombGroup.add(vial);
            
            // Glowing red liquid inside - MUCH LARGER AND BRIGHTER
            const liquidGeometry = new THREE.CylinderGeometry(0.7, 0.7, 2.2, 8); // Much larger: 0.25->0.7, 1.0->2.2
            const liquidMaterial = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 2.0, // Much brighter
                metalness: 0,
                roughness: 1,
                transparent: true,
                opacity: 0.8
            });
            const liquid = new THREE.Mesh(liquidGeometry, liquidMaterial);
            bombGroup.add(liquid);
            
            // Cork/cap - LARGER
            const capGeometry = new THREE.CylinderGeometry(0.85, 0.85, 0.4, 8); // Larger: 0.32->0.85, 0.2->0.4
            const capMaterial = new THREE.MeshStandardMaterial({
                color: 0x2F4F4F, // Dark slate gray
                metalness: 0.8,
                roughness: 0.2
            });
            const cap = new THREE.Mesh(capGeometry, capMaterial);
            cap.position.y = 1.45; // Adjusted for larger vial: 0.7->1.45
            bombGroup.add(cap);
            
            // Add outer glow effect for maximum visibility
            const glowGeometry = new THREE.CylinderGeometry(1.0, 1.0, 3.0, 8);
            const glowMaterial = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 1.0,
                metalness: 0,
                roughness: 1,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            bombGroup.add(glow);
            
            bombGroup.position.copy(position);
            bombGroup.userData.velocity = new THREE.Vector3(0, 0, 0.3); // Slight forward momentum
            bombGroup.userData.gravity = -0.02; // Falling speed
            bombGroup.userData.life = 0;
            bombGroup.userData.maxLife = 600;
            bombGroup.userData.hasExploded = false;
            
            return bombGroup;
        }


        const powerUpTypes = {
            ghost: { color: 0xff00ff, duration: 5000, message: "Ghost Mode Activated!" },
            magnet: { color: 0xffffff, duration: 6000, message: "Clock Mode!" },
            slowTime: { color: 0xffff00, duration: 4000, message: "Slow Time Activated!" },
            speedBoost: { color: 0xff8800, duration: 3000, message: "Speed Boost!" },
            projectile: { color: 0x00ffff, duration: 0, message: "Use DISCO!" }, // Cyan for DISCO projectiles
            obstacleDrop: { color: 0x8a2be2, duration: 0, message: "Krypton Acquired!" },
            swapPosition: { color: 0xff1493, duration: 0, message: "Position Swapped!" }
        };

        // Optimized power-up creation with shared geometries and materials
        const powerUpGeometries = {
            laser: new THREE.CylinderGeometry(0.1, 0.05, 5.0, 12), // Bigger, tapered laser beam
            core: new THREE.CylinderGeometry(0.15, 0.1, 5.0, 12), // Bigger core
            glow: new THREE.CylinderGeometry(0.25, 0.2, 5.5, 12), // Much bigger glow envelope
            spark: new THREE.SphereGeometry(0.3, 12, 12), // Bigger spark tip
            cube: new THREE.BoxGeometry(1.2, 1.2, 1.2),
            vialCylinder: new THREE.CylinderGeometry(0.15, 0.15, 0.35, 12),
            vialSphere: new THREE.SphereGeometry(0.15, 12, 12, 0, Math.PI * 2, 0, Math.PI / 2)
        };

        const powerUpSharedMaterials = {
            laser: new THREE.MeshStandardMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 5.0, // Much brighter
                metalness: 0,
                roughness: 1,
                transparent: true,
                opacity: 1.0 // Fully opaque for dramatic effect
            }),
            core: new THREE.MeshStandardMaterial({
                color: 0xff6666,
                emissive: 0xff0000,
                emissiveIntensity: 4.0, // Brighter core
                metalness: 0,
                roughness: 1,
                transparent: true,
                opacity: 0.9
            }),
            glow: new THREE.MeshStandardMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.6, // More visible glow
                emissive: 0xff0000,
                emissiveIntensity: 2.0, // Brighter glow
                metalness: 0,
                roughness: 1
            }),
            spark: new THREE.MeshStandardMaterial({
                color: 0xffffff,
                emissive: 0xff0000,
                emissiveIntensity: 6.0, // Ultra bright spark tip
                metalness: 0,
                roughness: 1,
                transparent: true,
                opacity: 1.0
            }),
            vial: new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                metalness: 0.2,
                roughness: 0.3,
                emissive: 0x00cc00,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.75
            })
        };

        function createPowerUp(type) {
            return getPooledObject('powerups', () => {
                const powerUpInfo = powerUpTypes[type];
                const powerUp = new THREE.Group();

                if (type === 'projectile') {
                     // STUNNING CYAN DISCO PROJECTILE - Glowing spinning disk!
                     const discoGeometry = new THREE.CylinderGeometry(1.5, 1.5, 0.3, 32); // Wide, thin cylinder = disk
                     const discoMaterial = new THREE.MeshStandardMaterial({
                         color: 0x00ffff, // Cyan color
                         emissive: 0x00ffff,
                         emissiveIntensity: 8.0, // Ultra bright cyan glow
                         metalness: 0,
                         roughness: 1,
                         transparent: true,
                         opacity: 0.9
                     });
                     const disco = new THREE.Mesh(discoGeometry, discoMaterial);
                     disco.rotation.x = Math.PI / 2; // Rotate to face forward like a spinning disk
                     powerUp.add(disco);
                     
                     // Add outer energy ring for extra glow
                     const outerRingGeometry = new THREE.CylinderGeometry(2.0, 2.0, 0.1, 32);
                     const outerRingMaterial = new THREE.MeshStandardMaterial({
                         color: 0x00ffff,
                         emissive: 0x00ffff,
                         emissiveIntensity: 6.0,
                         metalness: 0,
                         roughness: 1,
                         transparent: true,
                         opacity: 0.6
                     });
                     const outerRing = new THREE.Mesh(outerRingGeometry, outerRingMaterial);
                     outerRing.rotation.x = Math.PI / 2;
                     powerUp.add(outerRing);
                     
                     // Add central core for intense center glow
                     const coreGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.4, 16);
                     const coreMaterial = new THREE.MeshStandardMaterial({
                         color: 0xffffff, // Bright white center
                         emissive: 0x00ffff,
                         emissiveIntensity: 12.0, // Extremely bright core
                         metalness: 0,
                         roughness: 1
                     });
                     const core = new THREE.Mesh(coreGeometry, coreMaterial);
                     core.rotation.x = Math.PI / 2;
                     powerUp.add(core);
                     
                     // Add energy sparks around the edge
                     for (let i = 0; i < 8; i++) {
                         const sparkGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                         const sparkMaterial = new THREE.MeshStandardMaterial({
                             color: 0x00ffff,
                             emissive: 0x00ffff,
                             emissiveIntensity: 10.0,
                             metalness: 0,
                             roughness: 1
                         });
                         const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
                         const angle = (i / 8) * Math.PI * 2;
                         spark.position.x = Math.cos(angle) * 1.3;
                         spark.position.y = Math.sin(angle) * 1.3;
                         spark.position.z = 0;
                         powerUp.add(spark);
                     }
                     
                     console.log("Created stunning DISCO projectile with", powerUp.children.length, "components");

                } else {
                     // Create cubic power-up with green vial inside using shared materials
                     const baseMaterial = new THREE.MeshStandardMaterial({
                         color: powerUpInfo.color,
                         metalness: 0.3,
                         roughness: 0.6,
                         emissive: powerUpInfo.color,
                         emissiveIntensity: 0.8
                     });
                     
                     const mainShape = new THREE.Mesh(powerUpGeometries.cube, baseMaterial);
                     powerUp.add(mainShape);

                     const vialGroup = new THREE.Group();

                     const cylinderMesh = new THREE.Mesh(powerUpGeometries.vialCylinder, powerUpSharedMaterials.vial);
                     cylinderMesh.position.y = 0.175; // vialCylinderHeight / 2
                     vialGroup.add(cylinderMesh);

                     const sphereMesh = new THREE.Mesh(powerUpGeometries.vialSphere, powerUpSharedMaterials.vial);
                     sphereMesh.position.y = 0;
                     sphereMesh.rotation.x = Math.PI;
                     vialGroup.add(sphereMesh);

                     vialGroup.position.y = -0.175; // -(vialCylinderHeight / 2)
                     powerUp.add(vialGroup);
                }

                powerUp.userData.type = type;
                return powerUp;
            });
        }


        const coins = [];
        const obstacles = [];
        const iceGaps = []; // ICE GAPS - REMOVED (no longer used)
        const bowlingBallObstacles = [];
        const batGangs = [];
        const activeBursts = [];
        const powerUps = [];
        const itemBoxes = [];
        const activeProjectiles = [];
        const dragons = []; // Array to hold tieFighter instances
        const pepeEnemies = []; // Giant Pepe frog (level 40+), head-on road, steals all coins
        let level40PepeSpawned = false;
        const boostParticles = []; // Array to hold boost particles
        const greenVials = []; // Array to hold green vial collectibles
        
        // NEW ALLEY SYSTEMS
        const batAlleyBats = []; // For levels 65-70
        const bowlingBallAlleyBalls = []; // For levels 75-80
        const finalBats = []; // For level 85
        
        // NEW GALAXY ZONE SYSTEM (Levels 3-8)
        const galaxyShips = []; // Enemy ships in galaxy zone
        const galaxyProjectiles = []; // Enemy ship projectiles
        const galaxyBombs = []; // Red vial bombs dropped by ships
        let galaxyZoneActive = false;
        let galaxyZoneTimer = 0;
        const galaxyShipSpawnRate = 450;
        const maxGalaxyShips = 2;
        const MAX_GALAXY_PROJECTILES = 20;
        const MAX_GALAXY_BOMBS = 12;
        const bombDropRate = 60; // How often ships drop bombs (reduced from 120 to 60 for more frequent drops)
        
        // NEW VISUAL ENHANCEMENT SYSTEMS
                    const etherTrails = []; // Array for EMC collection trails
        const speedLines = []; // Array for dynamic speed lines
        let hyperspaceActive = false; // Hyperspace jump effect state
        let forcePowerActive = false; // Mr. Terrific's helmet DISCO glow state
        
        // CAMERA SHAKE SYSTEM
        const cameraShake = {
            active: false,
            intensity: 0,
            duration: 0,
            timer: 0,
            offsetX: 0,
            offsetY: 0,
            offsetZ: 0
        };

        // DIFFICULTY: Post-10 favors behavior/patterns over spawn count. Hard caps prevent entity bloat.
        function getObstacleSpawnRate(currentLevel) {
            if (currentLevel < 10) return 1200;
            if (currentLevel < 20) return 900;
            if (currentLevel < 35) return 700;
            return 550;
        }
        function getMaxObstaclesForLevel(currentLevel) {
            if (currentLevel < 10) return 1;
            if (currentLevel < 25) return 2;
            return 3;
        }
        
        function getIceGapMaxWidth(currentLevel) {
            // Never more than 60% of road width
            const maxWidthPercent = 0.6;
            return roadWidth * maxWidthPercent;
        }

        // LENS FLARE SYSTEM
        const lensFlares = [];
        
        function createLensFlare(light, size = 100, color = 0xffffff) {
            const flareGroup = new THREE.Group();
            
            // Main flare
            const flareGeometry = new THREE.PlaneGeometry(size, size);
            const flareMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            });
            const flare = new THREE.Mesh(flareGeometry, flareMaterial);
            flareGroup.add(flare);
            
            // Secondary flares at different sizes
            for (let i = 0; i < 3; i++) {
                const secondarySize = size * (0.3 + i * 0.2);
                const secondaryGeometry = new THREE.PlaneGeometry(secondarySize, secondarySize);
                const secondaryMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.3 - i * 0.1,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide
                });
                const secondaryFlare = new THREE.Mesh(secondaryGeometry, secondaryMaterial);
                secondaryFlare.position.z = (i + 1) * 2;
                flareGroup.add(secondaryFlare);
            }
            
            // Make flares always face camera
            flareGroup.userData.isLensFlare = true;
            flareGroup.userData.light = light;
            scene.add(flareGroup);
            lensFlares.push(flareGroup);
            
            return flareGroup;
        }
        
        function updateLensFlares() {
            for (let i = lensFlares.length - 1; i >= 0; i--) {
                const flare = lensFlares[i];
                const light = flare.userData.light;
                
                if (!light.parent) {
                    flare.traverse((c) => {
                        if (c.geometry) c.geometry.dispose();
                        if (c.material) { if (c.material.map) c.material.map.dispose(); c.material.dispose(); }
                    });
                    scene.remove(flare);
                    lensFlares.splice(i, 1);
                    continue;
                }
                
                // Position flare at light position
                flare.position.copy(light.getWorldPosition(new THREE.Vector3()));
                
                // Make flare face camera
                flare.lookAt(camera.position);
                
                // Adjust opacity based on light intensity
                const intensity = light.intensity;
                flare.children.forEach((child, index) => {
                    if (child.material) {
                        child.material.opacity = (intensity / 2) * (index === 0 ? 0.6 : 0.3 - index * 0.1);
                    }
                });
            }
        }


        const coinSpawnRate = 8; // Fast spawn rate for good action
        const maxCoins = 60; // Balanced for performance and fun
        const obstacleSpawnRate = 450; // ~25% fewer than original 300
        const maxObstacles = 3; // Restore so 25+ has action

        const bowlingBallSpawnRate = 2800; // ~25% fewer (was 2000 before 50% cut)
        const maxBowlingBalls = 2; // Restore for 25+

        const batGangSpawnRate = 1600; // ~25% fewer (was 1200 before 50% cut)
        const maxBatGangs = 2; // Restore for 25+

        const powerUpSpawnRate = 600; // Reduced from 1200 (more frequent power-ups)
        const maxPowerUps = 4; // Increased from 3

        const itemBoxSpawnRate = 300; // Reduced from 600 (more frequent item boxes)
        const maxItemBoxes = 6; // Increased from 5

        const greenVialSpawnRate = 1000; // Balanced gold coin spawn rate
        const maxGreenVials = 2; // Up to 2 gold coins
        
        const projectileSpeed = 2.4; // 2x faster: 1.2 -> 2.4
        const tieFighterSpeed = 0.4; // Reduced from 0.5


        let score = 0;
        const scoreDisplay = document.getElementById('score');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreDisplay = document.getElementById('final-score');
        const finalLevelDisplay = document.getElementById('final-level'); // Get the new element
        
        // COMBO SYSTEM for dopamine-inducing progression
        let coinCombo = 0;
        let comboTimeout = null;
        const COMBO_RESET_TIME = 2000; // 2 seconds to maintain combo
        let lastCoinCollectionTime = 0;
        const startScreen = document.getElementById('cinematic-intro');
        // Single landing screen (intro + buttons) stays visible on load; hidden when Play Game runs (dismissIntro)
        const wagmiButton = document.getElementById('wagmi-button');
        const planetXButton = document.getElementById('planet-x-button');
        const restartButton = document.getElementById('restart-button');
        
        // Debug restart button setup
        if (!restartButton) {
            console.error("Restart button not found!");
        } else {
            console.log("Restart button found:", restartButton);
            
            // Test if button is clickable
            setTimeout(() => {
                console.log("Testing restart button after page load...");
                console.log("Button style:", window.getComputedStyle(restartButton));
                console.log("Button disabled:", restartButton.disabled);
                console.log("Button parent element:", restartButton.parentElement);
            }, 2000);
        }
        const gameFooter = document.querySelector('.game-footer');
        // const boostSound = document.getElementById('boost-sound');


        const dialogueBox = document.getElementById('dialogue-box');
        const boostButton = document.getElementById('boost-button');
        const blasterButton = document.getElementById('blaster-button');
        const miniBoostButton = document.getElementById('mini-boost-button');
        const lightningFlashElement = document.getElementById('lightning-flash');
        const levelUpPopup = document.getElementById('level-up-popup');
        const levelDisplay = document.getElementById('level-display');
        const comboDisplay = document.getElementById('combo-display');
        // Removed welcomeMessageElement reference
        const powerUpDisplay = document.getElementById('power-up-display');


         const mobileControlsDiv = document.querySelector('.mobile-controls');
         const steerLeftButton = document.getElementById('steer-left-button');
         const steerRightButton = document.getElementById('steer-right-button');
         const jumpButtonMobile = document.getElementById('jump-button');
         const usePowerUpButtonMobile = document.getElementById('use-power-up-button-mobile');

         // Add mobile button listeners
         if (steerLeftButton) {
             steerLeftButton.addEventListener('touchstart', (e) => { e.preventDefault(); if (!gamePaused && gameMode === 'manual') steerLeftButton.classList.add('active'); });
             steerLeftButton.addEventListener('touchend', (e) => { e.preventDefault(); steerLeftButton.classList.remove('active'); });
         }
         if (steerRightButton) {
             steerRightButton.addEventListener('touchstart', (e) => { e.preventDefault(); if (!gamePaused && gameMode === 'manual') steerRightButton.classList.add('active'); });
             steerRightButton.addEventListener('touchend', (e) => { e.preventDefault(); steerRightButton.classList.remove('active'); });
         }
         if (jumpButtonMobile) {
             jumpButtonMobile.addEventListener('touchstart', (e) => { 
                 e.preventDefault(); 
                 if (!gamePaused && gameMode === 'manual' && !isJumping) {
                     isJumping = true;
                     jumpVelocity = jumpPower;
                     if (audioSystemEnabled && typeof ensureGameAudio === 'function') ensureGameAudio();
                     if (jumpSynth) { try { jumpSynth.triggerAttackRelease("C4", "8n"); } catch (_) {} }
                 }
             });
         }
         if (usePowerUpButtonMobile) {
             usePowerUpButtonMobile.addEventListener('touchstart', (e) => { e.preventDefault(); if (!gamePaused && gameMode === 'manual') usePowerUp(); });
         }


        // isGameOver declared earlier - removed duplicate
        let gameMode = 'manual';
        let crashPosition = new THREE.Vector3();
        let isBoosting = false;
        let manualBoostsUsed = 0; // Track manual boosts used this level bracket
        let isMiniBoostActive = false;
        let miniBoostTimer = null;
        // isGameRunning, isGameOver, gamePaused declared earlier to avoid initialization errors
        let isInvincible = false;
        let invincibilityTimer = null;
        let isFirstLaunch = true;


        let isGhostActive = false;
        let ghostTimer = null;
        let ghostPulsePhase = 0; // For ghost pulsing effect
        let isMagnetActive = false;
        let magnetTimer = null;
        let isSlowTimeActive = false;
        let slowTimeTimer = null;
        let slowTimeFactor = 0.5;
        let goldCoinSlowMoTimer = null;
        let hasProjectile = false;
        let hasObstacleDrop = false;
        let hasSwapPosition = false;



        // VIBES system
        let remainingBlasterBolts = 0;
        let maxBlasterBolts = 0;
        let blasterBoltsUsed = 0;
        let isBlasterActive = false;
        let blasterDuration = 2000; // 2 seconds


        let level = 1;
        let levelThreshold = 3; // Reduced from 5 for faster progression
        const baseAiBikes = 3; // Restore for 25+ (was 4, then 2)
        const GRAND_PRIZE_LEVEL = 100;
        const BOOST_UNLOCK_LEVEL = 2; // Changed from 10 to 2
        const DRAGON_LEVELS = [15, 60, 90]; // No dragon at 35; first at 15, then 60, 90

        // Add extreme difficulty level constant
        const EXTREME_DIFFICULTY_LEVEL = 60;

        // Speed increase limit level
        const SPEED_INCREASE_LIMIT_LEVEL = 75;
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // BIOME SYSTEM - Different environments every 25 levels
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        let currentBiome = 'arctic';
        let windPush = 0; // For blizzard biome
        let zeroGravityActive = false; // For northern lights biome
        let bossPenguinSpawnLevel = 75; // First boss at level 75
        
        function getCurrentBiome(level) {
            if (level >= 75) return 'blizzard';
            if (level >= 50) return 'northernLights';
            if (level >= 25) return 'sunsetTundra';
            return 'arctic';
        }
        
        function applyBiome(biome) {
            currentBiome = biome;
            
            switch(biome) {
                case 'arctic':
                    // Levels 1-25: ARCTIC (current setup)
                    scene.background = new THREE.Color(0xd0e8f0); // Slightly darker to prevent whiteout
                    scene.fog = new THREE.Fog(0xd0e8f0, 80, 600); // Fog starts further away to prevent whiteout
                    renderer.setClearColor(0xd0e8f0);
                    windPush = 0;
                    zeroGravityActive = false;
                    break;
                    
                case 'sunsetTundra':
                    // Levels 25-50: SUNSET TUNDRA - Orange/purple sky, faster speed
                    scene.background = new THREE.Color(0xff6b35); // Orange
                    scene.fog = new THREE.Fog(0x8b4c8f, 40, 350); // Purple fog
                    renderer.setClearColor(0xff6b35);
                    // Don't multiply baseMoveSpeed here - it would compound. Just set it higher initially
                    if (baseMoveSpeed < initialBaseMoveSpeed * 1.15) {
                        baseMoveSpeed = initialBaseMoveSpeed * 1.15; // 15% faster
                    }
                    windPush = 0;
                    zeroGravityActive = false;
                    break;
                    
                case 'northernLights':
                    // Levels 50-75: NORTHERN LIGHTS - Green/pink aurora, glowing obstacles, zero gravity
                    scene.background = new THREE.Color(0x0a0a1a); // Dark
                    scene.fog = new THREE.Fog(0x1a3a2a, 30, 300); // Green fog
                    renderer.setClearColor(0x0a0a1a);
                    zeroGravityActive = true; // Zero gravity sections
                    windPush = 0;
                    // Aurora effect added in animate loop
                    break;
                    
                case 'blizzard':
                    // Levels 75-100: BLIZZARD CHAOS - Low visibility, wind pushes sideways
                    scene.background = new THREE.Color(0x4a5568); // Dark gray
                    scene.fog = new THREE.Fog(0xe0e0e0, 30, 250); // Light gray fog (not pure white) - adjusted distance
                    renderer.setClearColor(0x4a5568);
                    windPush = 0.05; // Wind pushes player sideways
                    zeroGravityActive = false;
                    break;
            }
        }
        
        // OPTIMIZED SNOW MOUNTAINS - Simple, performant, positioned FAR from road
        let permanentMountainsGroup = new THREE.Group();
        permanentMountainsGroup.name = 'permanentMountains';
        scene.add(permanentMountainsGroup);
        let mountainUpdateCounter = 0; // Throttle mountain updates
        
        // Shared materials for performance - PHOTOREALISTIC mountain materials
        const mountainBaseMaterial = new THREE.MeshStandardMaterial({
            color: 0x8090a0, // Rocky gray-blue base
            roughness: 0.85, // Rough rock texture
            metalness: 0.0, // No metalness for natural rock
        });
        const mountainSnowMaterial = new THREE.MeshStandardMaterial({
            color: 0xfefefe,
            roughness: 0.6,
            metalness: 0.0,
        });
        
        function createSnowMountains() {
            // Clear existing
            while(permanentMountainsGroup.children.length > 0) {
                const child = permanentMountainsGroup.children[0];
                permanentMountainsGroup.remove(child);
            }
            
            // Create 16 simple mountains (8 per side) - reduced for performance
            for (let i = 0; i < 16; i++) {
                const mountain = new THREE.Group();
                
                // Simple mountain - just base and snow cap (no extra patches) - 40% BIGGER (15% increase from previous)
                const baseHeight = (60 + Math.random() * 80) * 1.4375;
                const baseWidth = (30 + Math.random() * 40) * 1.4375;
                
                // Single cone for base - low poly (6 segments)
                const baseGeometry = new THREE.ConeGeometry(baseWidth, baseHeight, 6);
                const base = new THREE.Mesh(baseGeometry, mountainBaseMaterial);
                base.position.y = baseHeight / 2;
                mountain.add(base);
                
                // Simple snow cap - 40% BIGGER
                const snowHeight = (20 + Math.random() * 30) * 1.4375;
                const snowWidth = baseWidth * 0.7;
                const snowGeometry = new THREE.ConeGeometry(snowWidth, snowHeight, 6);
                const snowCap = new THREE.Mesh(snowGeometry, mountainSnowMaterial);
                snowCap.position.y = baseHeight + snowHeight / 2;
                mountain.add(snowCap);
                
                // Position mountains VERY FAR from road - minimum 120 units from center
                // Road width is 14, so this is safely out of view
                const isLeftSide = i % 2 === 0;
                const sideOffset = 120 + Math.random() * 100; // 120-220 units from center
                const mountainX = isLeftSide ? -sideOffset : sideOffset;
                
                // Spread along Z axis
                const mountainZ = -150 - (i * 80) - Math.random() * 40;
                
                mountain.position.set(mountainX, 0, mountainZ);
                permanentMountainsGroup.add(mountain);
            }
        }
        
        createSnowMountains();
        
        // THROTTLED mountain update - only every 30 frames
        function updatePermanentMountains() {
            mountainUpdateCounter++;
            if (mountainUpdateCounter % 30 !== 0) return; // Only update every 30 frames
            
            const playerZ = playerMotorcycle.position.z;
            
            permanentMountainsGroup.children.forEach((mountain, index) => {
                if (mountain.position.z > playerZ + 150) {
                    const isLeftSide = index % 2 === 0;
                    const sideOffset = 120 + Math.random() * 100;
                    mountain.position.x = isLeftSide ? -sideOffset : sideOffset;
                    mountain.position.z = playerZ - 500 - Math.random() * 300;
                }
            });
        }


        const initialBaseMoveSpeed = (isCustomized && window.gameCustomizations) ? window.gameCustomizations.baseSpeed : 2.36; // SPEED BOOST: 35% faster (was 1.75) for more mayhem!
        let baseMoveSpeed = initialBaseMoveSpeed;
        let moveSpeed = baseMoveSpeed;
        let currentMoveSpeed = baseMoveSpeed; // Make currentMoveSpeed global for stats tracking
        const speedIncreaseRate = 0.00004; // Increased slightly for faster progression
        const maxMoveSpeed = 8.0; // FIXED: Must be higher than initialBaseMoveSpeed to prevent hyperspace triggering at start
        const baseSpeedIncreasePerLevel = 0.0146; // Recalculated for new max speed (25% increase)

        let steerSpeed = 0.10; // Smooth steering speed
        let currentSteerAngle = 0;
        let targetSteerAngle = 0;
        const steerInterpolationSpeed = 0.12; // Increased for more fluid movement
        const maxSteerAngle = 0.32; // Slightly increased from 0.3 for better maneuverability
        let steerMomentum = 0;
        const momentumDecay = 0.985; // Faster decay for more responsive feel
        const maxMomentum = 0.10; // Increased for more fluid momentum
        let lastSteerInput = 0;
        const inputSmoothing = 0.15; // Increased for more responsive input
        let lateralVelocity = 0; // Add lateral velocity for smoother movement
        const lateralDamping = 0.95; // Lower damping for more fluid movement
        let targetMoveSpeed = baseMoveSpeed; // Smooth forward speed interpolation
        let smoothedMoveSpeed = baseMoveSpeed;
        let brakesUsed = false; // B = brakes (-50% speed), once per run

        let playerRandomSteerDirection = 0;
        let playerRandomSteerTimer = 0;
        const playerRandomSteerInterval = 120;
        const playerRandomSteerChance = 0.1;

         const aiSteerSpeed = 0.005;
         const aiRandomSteerInterval = 90;
         const aiRandomSteerChance = 0.2;


        const roadEdgeThreshold = (roadWidth / 2) - 0.5;

        const resetThreshold = -roadLength / 4;
        const sceneryChangeDistance = roadLength / 2;
        let lastSceneryChangeZ = 0;

        let playerManualSteerDirection = 0;

        const keys = {};

        let isJumping = false;
        let jumpVelocity = 0;
        const jumpPower = 0.5;
        const gravity = -0.03;

        let coinsForPowerUp = 0;
        const coinsNeededForPowerUp = 15;
        const powerUpDuration = 2500;
        const powerUpCoinBonus = 3;

        // Chrome/Safari: create context and synths at load (match index3). Firefox: defer until first gesture.
        let audioContext = null;
        let shieldSynth, magnetSynth, slowTimeSynth, coinSynth, crashNoise, itemBoxSynth, cardPickupSynth, cardImpactSynth;
        let goldCoinSynth, epicPowerUpSynth, projectileSynth, explosionSynth, engineSynth, ambientSynth, forceSynth, hyperspaceNoise, powerUpActivateSynth;
        let jumpSynth = null;
        if (!isFirefox && typeof Tone !== 'undefined' && (window.AudioContext || window.webkitAudioContext)) {
            try {
                var AC = window.AudioContext || window.webkitAudioContext;
                audioContext = new AC();
                Tone.setContext(audioContext);
                shieldSynth = new Tone.Synth().toDestination();
                magnetSynth = new Tone.Synth().toDestination();
                slowTimeSynth = new Tone.Synth().toDestination();
                coinSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sine" }, envelope: { attack: 0.005, decay: 0.15, sustain: 0.1, release: 0.3 } }).toDestination().set({ volume: -8 });
                crashNoise = new Tone.NoiseSynth({ noise: { type: "pink" }, envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.2 } }).toDestination();
                itemBoxSynth = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 } }).toDestination();
                cardPickupSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sawtooth" }, envelope: { attack: 0.002, decay: 0.18, sustain: 0.15, release: 0.25 } }).toDestination().set({ volume: -6 });
                cardImpactSynth = new Tone.MetalSynth({ frequency: 180, envelope: { attack: 0.001, decay: 0.3, release: 0.2 }, harmonicity: 4.2, modulationIndex: 20, resonance: 5000, octaves: 1.2 }).toDestination().set({ volume: -8 });
                goldCoinSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.2, release: 0.5 } }).toDestination().set({ volume: -5 });
                epicPowerUpSynth = new Tone.MetalSynth({ frequency: 200, envelope: { attack: 0.001, decay: 0.4, release: 0.2 }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5 }).toDestination().set({ volume: -10 });
                projectileSynth = new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.15, sustain: 0, release: 0.1 } }).toDestination().set({ volume: -5 });
                explosionSynth = new Tone.NoiseSynth({ noise: { type: "white" }, envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.1 } }).toDestination();
                engineSynth = new Tone.Oscillator(60, "sawtooth").toDestination().set({ volume: -20 });
                ambientSynth = new Tone.AMSynth().toDestination().set({ volume: -25 });
                forceSynth = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.2, decay: 0.5, sustain: 0.3, release: 1.0 } }).toDestination().set({ volume: -10 });
                hyperspaceNoise = new Tone.NoiseSynth({ noise: { type: "white" }, envelope: { attack: 0.1, decay: 0.3, sustain: 0.2, release: 0.5 } }).toDestination().set({ volume: -8 });
                powerUpActivateSynth = new Tone.Synth().toDestination();
                jumpSynth = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination().set({ volume: -15 });
                window.__gameAudioInited = true;
            } catch (e) { console.warn("Web Audio init at load failed:", e); }
        }
        function ensureGameAudio() {
            if (window.__gameAudioInited) return;
            const AC = window.AudioContext || window.webkitAudioContext;
            if (!AC || typeof Tone === 'undefined') return;

            // Chrome/Safari: original synchronous behavior ‚Äî leave untouched
            if (!isFirefox) {
                window.__gameAudioInited = true;
                try {
                    audioContext = new AC();
                    Tone.setContext(audioContext);
                    if (audioContext.resume) audioContext.resume().catch(function(){});
                    if (Tone.start) Tone.start().catch(function(){});
                    shieldSynth = new Tone.Synth().toDestination();
                    magnetSynth = new Tone.Synth().toDestination();
                    slowTimeSynth = new Tone.Synth().toDestination();
                    coinSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sine" }, envelope: { attack: 0.005, decay: 0.15, sustain: 0.1, release: 0.3 } }).toDestination().set({ volume: -8 });
                    crashNoise = new Tone.NoiseSynth({ noise: { type: "pink" }, envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.2 } }).toDestination();
                    itemBoxSynth = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 } }).toDestination();
                    cardPickupSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sawtooth" }, envelope: { attack: 0.002, decay: 0.18, sustain: 0.15, release: 0.25 } }).toDestination().set({ volume: -6 });
                    cardImpactSynth = new Tone.MetalSynth({ frequency: 180, envelope: { attack: 0.001, decay: 0.3, release: 0.2 }, harmonicity: 4.2, modulationIndex: 20, resonance: 5000, octaves: 1.2 }).toDestination().set({ volume: -8 });
                    goldCoinSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.2, release: 0.5 } }).toDestination().set({ volume: -5 });
                    epicPowerUpSynth = new Tone.MetalSynth({ frequency: 200, envelope: { attack: 0.001, decay: 0.4, release: 0.2 }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5 }).toDestination().set({ volume: -10 });
                    projectileSynth = new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.15, sustain: 0, release: 0.1 } }).toDestination().set({ volume: -5 });
                    explosionSynth = new Tone.NoiseSynth({ noise: { type: "white" }, envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.1 } }).toDestination();
                    engineSynth = new Tone.Oscillator(60, "sawtooth").toDestination().set({ volume: -20 });
                    ambientSynth = new Tone.AMSynth().toDestination().set({ volume: -25 });
                    forceSynth = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.2, decay: 0.5, sustain: 0.3, release: 1.0 } }).toDestination().set({ volume: -10 });
                    hyperspaceNoise = new Tone.NoiseSynth({ noise: { type: "white" }, envelope: { attack: 0.1, decay: 0.3, sustain: 0.2, release: 0.5 } }).toDestination().set({ volume: -8 });
                    powerUpActivateSynth = new Tone.Synth().toDestination();
                    jumpSynth = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination().set({ volume: -15 });
                } catch (err) { console.warn("Web Audio init failed (e.g. Firefox before gesture):", err); }
                return;
            }

            // Firefox only: defer synth creation until after context resume + Tone.start
            if (window.__gameAudioIniting) return;
            window.__gameAudioIniting = true;
            try {
                audioContext = new AC();
                Tone.setContext(audioContext);
                var resumeP = audioContext.resume ? audioContext.resume() : Promise.resolve();
                resumeP.then(function() { return Tone.start ? Tone.start() : Promise.resolve(); }).then(function() {
                    try {
                        shieldSynth = new Tone.Synth().toDestination();
                        magnetSynth = new Tone.Synth().toDestination();
                        slowTimeSynth = new Tone.Synth().toDestination();
                        coinSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sine" }, envelope: { attack: 0.005, decay: 0.15, sustain: 0.1, release: 0.3 } }).toDestination().set({ volume: -8 });
                        crashNoise = new Tone.NoiseSynth({ noise: { type: "pink" }, envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.2 } }).toDestination();
                        itemBoxSynth = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 } }).toDestination();
                        cardPickupSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sawtooth" }, envelope: { attack: 0.002, decay: 0.18, sustain: 0.15, release: 0.25 } }).toDestination().set({ volume: -6 });
                        cardImpactSynth = new Tone.MetalSynth({ frequency: 180, envelope: { attack: 0.001, decay: 0.3, release: 0.2 }, harmonicity: 4.2, modulationIndex: 20, resonance: 5000, octaves: 1.2 }).toDestination().set({ volume: -8 });
                        goldCoinSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.2, release: 0.5 } }).toDestination().set({ volume: -5 });
                        epicPowerUpSynth = new Tone.MetalSynth({ frequency: 200, envelope: { attack: 0.001, decay: 0.4, release: 0.2 }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5 }).toDestination().set({ volume: -10 });
                        projectileSynth = new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.15, sustain: 0, release: 0.1 } }).toDestination().set({ volume: -5 });
                        explosionSynth = new Tone.NoiseSynth({ noise: { type: "white" }, envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.1 } }).toDestination();
                        engineSynth = new Tone.Oscillator(60, "sawtooth").toDestination().set({ volume: -20 });
                        ambientSynth = new Tone.AMSynth().toDestination().set({ volume: -25 });
                        forceSynth = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.2, decay: 0.5, sustain: 0.3, release: 1.0 } }).toDestination().set({ volume: -10 });
                        hyperspaceNoise = new Tone.NoiseSynth({ noise: { type: "white" }, envelope: { attack: 0.1, decay: 0.3, sustain: 0.2, release: 0.5 } }).toDestination().set({ volume: -8 });
                        powerUpActivateSynth = new Tone.Synth().toDestination();
                        jumpSynth = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination().set({ volume: -15 });
                        window.__gameAudioInited = true;
                    } catch (e) { console.warn("Web Audio init failed (e.g. Firefox before gesture):", e); }
                    window.__gameAudioIniting = false;
                }).catch(function(err) {
                    console.warn("Web Audio init failed (e.g. Firefox before gesture):", err);
                    window.__gameAudioIniting = false;
                });
            } catch (err) {
                console.warn("Web Audio init failed (e.g. Firefox before gesture):", err);
                window.__gameAudioIniting = false;
            }
        }
        window.__onFirstTap = ensureGameAudio;
        
        // Star Wars ambient music simulation
        let ambientMusicActive = false;
        let ambientMusicInterval = null;
        let audioSystemEnabled = false; // Audio OFF by default (match index3 ‚Äî user enables for sound)
        
        // DIFFICULTY SYSTEM
        let gameDifficulty = 'normal';
        const difficultySettings = {
            normal: {
                multiplier: 1.0,
                name: 'Normal',
                description: 'Balanced gameplay for all pilots'
            },
            hard: {
                multiplier: 1.5,
                name: 'Hard',
                description: 'Faster enemies, less margin for error'
            },
            insane: {
                multiplier: 2.0,
                name: 'Insane',
                description: 'Extreme speed, only for Jedi Masters'
            }
        };
        
        // SESSION STATS TRACKING
        const sessionStats = {
            distanceTraveled: 0,
            enemiesDefeated: 0,
            etherCollected: 0,
            startTime: 0,
            sessionTime: 0,
            maxSpeed: 0,
            hyperspaceJumps: 0,
            powerUpsUsed: 0
        };
        
        // LEADERBOARD TRACKING VARIABLES
        let totalEnemiesDefeated = 0;
        let totalDiscoProjectiles = 0;
        let sessionStartTime = Date.now();
        let lastLeaderboardCheck = 0; // For showing motivational messages
        let playerName = "Player One"; // Default player name
        
        // Pause timing variables
        let pauseStartTime = 0;
        let totalPausedTime = 0;
        
        // Animation frame management
        window.animationFrameId = null;
        
        // Helper function to get adjusted time (accounting for paused time)
        function getAdjustedTime() {
            return Date.now() - totalPausedTime;
        }
        
        // const boostSound = new Tone.Player({
        //     url: "https://assets.mixkit.co/sfx/preview/mixkit-sci-fi-rocket-engine-1320.mp3",
        //     loop: true,
        // }).toDestination();

        // DRAGON SOUND REMOVED: tieFighterRoarSynth definition commented out
        /*
        const tieFighterRoarSynth = new Tone.NoiseSynth({
            noise: { type: 'brown' },
            envelope: {
                attack: 0.2,
                decay: 1.5,
                sustain: 0.1,
                release: 0.8
            },
            volume: -2
        }).toDestination();
        */


        window.addEventListener('keydown', (event) => {
            keys[event.key] = true;
            
            // Game controls
            if (event.key === ' ' && !event.shiftKey && !isJumping && isGameRunning && (gameMode === 'manual' || gameMode === 'auto') && !gamePaused) {
                 startJump();
            }
            if ((event.key === 'e' || event.key === 'E') && !isMobileDevice()) {
                usePowerUp();
            }
            if (event.key === 'ArrowUp' && !isMobileDevice() && isGameRunning && !gamePaused && level >= BOOST_UNLOCK_LEVEL) {
                activateBoost(3000, true); // Manual boost
            }
            if ((event.key === 'f' || event.key === 'F') && !isMobileDevice() && isGameRunning && !gamePaused) {
                activateBlasterBolt();
            }
            if ((event.key === 's' || event.key === 'S') && !isMobileDevice() && isGameRunning && !gamePaused) {
                activateMiniBoost();
            }
            
            // Settings menu controls
            if (event.key === 'Tab') {
                event.preventDefault();
                toggleSettingsMenu();
            }
            if (event.key === 'Escape') {
                const settingsMenu = document.getElementById('settings-menu');
                if (settingsMenu.style.display === 'block') {
                    // Close settings menu and resume game
                    settingsMenu.style.display = 'none';
                    if (isGameRunning && !isGameOver && gamePaused) {
                        gamePaused = false;
                        document.getElementById('pause-overlay').style.display = 'none';
                        // Don't call animate() here - the loop should already be running, just resume
                        // The animate loop will continue automatically when gamePaused becomes false
                    }
                }
            }
            
            // Customization controls
            if (event.key === '1') {
                changeBikeSkin('prev');
            }
            if (event.key === '2') {
                changeBikeSkin('next');
            }
            if (event.key === '3') {
                changeTrailEffect('prev');
            }
            if (event.key === '4') {
                changeTrailEffect('next');
            }
            if (event.key === '5') {
                changeRiderOutfit('prev');
            }
            if (event.key === '6') {
                changeRiderOutfit('next');
            }
            
            // Pause game with P key
            if (event.key === 'p' || event.key === 'P') {
                togglePause();
            }
            
            // Toggle game instructions with I key
            if (event.key === 'i' || event.key === 'I') {
                toggleGameInstructions();
            }
            
            // Toggle audio system with M key
            if (event.key === 'm' || event.key === 'M') {
                toggleAudioSystem();
            }
            
            // Toggle headlight with H key
            if (event.key === 'h' || event.key === 'H') {
                toggleHeadlight();
            }
            // Brakes: reduce speed by 50%, once per run
            if ((event.key === 'b' || event.key === 'B') && isGameRunning && !gamePaused && !brakesUsed && !isGameOver) {
                brakesUsed = true;
                baseMoveSpeed *= 0.5;
                moveSpeed *= 0.5;
                currentMoveSpeed *= 0.5;
                targetMoveSpeed = moveSpeed;
                smoothedMoveSpeed = moveSpeed;
                if (typeof setMessage === 'function') setMessage('BRAKES! -50% speed (one-time)');
            }
        });

        window.addEventListener('keyup', (event) => {
            keys[event.key] = false;
        });

        // Add click/tap to pause functionality
        document.addEventListener('click', handleScreenTap);
        document.addEventListener('touchstart', handleScreenTap);

        // Prevent context menu on right click to avoid interference
        document.addEventListener('contextmenu', (event) => {
            event.preventDefault();
        });



        // Planet X Button Event Handler
            // Planet X button removed from stats sheet

        const dialogueMessages = [
            "Fair Play prevails...",
            "I have a bad feeling about this!",
            "The Empire strikes back...",
            "These aren't the droids you're looking for!",
            "The faster I go, the closer to lightspeed.",
            "Racing through city tunnels.",
            "Imperial entanglements ahead!",
            "The Force will be with you, always.",
            "Justice credits scattered on streets.",
                            "Use DISCO, Terrific!",
            "Watch out for Imperial patrols!",
            "Another Imperial speeder spotted!",
            "tieFighter formation detected!",
                            "The Jackpot is within reach!",
            "Star Destroyer approaching...",
            "The Force flows through everything..."
        ];
        let dialogueTimer = 0;
        const dialogueInterval = 900;

        let lightningTimer = 0;
        const lightningInterval = 1500;
        const lightningDuration = 100;

        let obstacleSpeedMultiplier = 1.5;

                        // Update the rider colors array for Mr. Terrific's appearance
        const riderColors = [
            0xFFE4B5, // Level 1: Light skin tone (Mr. Terrific's complexion)
            0xFFE4B5, // Level 2: Keep skin tone
            0xFFE4B5, // Level 3: Keep skin tone
            0xFFE4B5, // Level 4: Keep skin tone
            0xFFE4B5, // Level 5: Keep skin tone
            0xFFE4B5, // Level 6: Keep skin tone
            0xFFE4B5, // Level 7: Keep skin tone
            0xFFE4B5, // Level 8: Keep skin tone
            0xFFE4B5  // Level 9: Keep skin tone
        ];

        // isMobileDevice / isMobile defined in EARLY VARIABLE DECLARATIONS (cyphes-style)
        
        // MOBILE SWIPE-TO-STEER SYSTEM
        let touchStartX = 0;
        let touchCurrentX = 0;
        let swipeSteerDirection = 0;
        
        // Touch event handlers for swipe steering
        document.addEventListener('touchstart', (e) => {
            if (isMobileDevice() && isGameRunning && !isGameOver && !gamePaused) {
                touchStartX = e.touches[0].clientX;
                touchCurrentX = touchStartX;
            }
        });
        
        document.addEventListener('touchmove', (e) => {
            if (isMobileDevice() && isGameRunning && !isGameOver && !gamePaused) {
                e.preventDefault(); // Prevent scrolling
                touchCurrentX = e.touches[0].clientX;
                const swipeDistance = touchCurrentX - touchStartX;
                const swipeThreshold = 30; // IMPROVED: More responsive swipe (was 50)
                const swipeDeadzone = 10; // Small deadzone to prevent accidental swipes
                
                if (Math.abs(swipeDistance) > swipeThreshold && Math.abs(swipeDistance) > swipeDeadzone) {
                    swipeSteerDirection = swipeDistance > 0 ? -1 : 1; // Invert for natural feel
                } else {
                    swipeSteerDirection = 0;
                }
            }
        });
        
        document.addEventListener('touchend', (e) => {
            if (isMobileDevice()) {
                swipeSteerDirection = 0; // Reset steering when touch ends
            }
        });

         function updateMobileControlVisibility() {
             if (isMobileDevice() && isGameRunning && !isGameOver && !gamePaused) {
                 mobileControlsDiv.style.display = 'flex';
                 
                 // Only show power-up button if player has a power-up
                 if (hasProjectile || hasObstacleDrop) {
                     usePowerUpButtonMobile.style.display = 'flex';
                 } else {
                     usePowerUpButtonMobile.style.display = 'none';
                 }
             } else {
                 mobileControlsDiv.style.display = 'none';
             }
         }

        function setGameUIVisibility(visible) {
            const display = visible ? 'block' : 'none';
            scoreDisplay.style.display = display;
            // jackpotDisplay removed - no longer needed
            levelDisplay.style.display = display;
            boostButton.style.display = display;
            blasterButton.style.display = display;
            miniBoostButton.style.display = display;
            powerUpDisplay.style.display = display;
            gameFooter.style.display = visible && !isGameOver ? 'flex' : 'none';
        }


        function getPlayerAISteerDirection() {
            playerRandomSteerTimer++;
            if (playerRandomSteerTimer >= playerRandomSteerInterval || Math.random() < playerRandomSteerChance) {
                playerRandomSteerDirection = (Math.random() - 0.5) * 2;
                playerRandomSteerTimer = 0;
            }
            const motorcycleX = playerMotorcycle.position.x;
            const centerOffset = -motorcycleX * 0.002;
            let aiSteer = playerRandomSteerDirection * 0.05 + centerOffset;
            aiSteer = Math.max(-1, Math.min(1, aiSteer));
            return aiSteer;
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // AGENT CONTROLLER - Replaces keyboard input with neural network outputs
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        class AgentController {
            constructor() {
                this.isAgentMode = false;
                this.agentId = null;
                this.wsConnection = null;
                this.lastAction = { steer: 0, jump: false, boost: false, usePowerUp: false };
                this.actionQueue = [];
                this.latency = 0;
                this.actionsPerSecond = 0;
                this.lastActionTime = Date.now();
                this.actionCount = 0;
                this.steerSmoothing = 0.3;
                this.targetSteer = 0;
                this.currentSteer = 0;
                this.maxActionsPerSecond = 60;
                this.minActionInterval = 16;
                this.lastProcessedAction = 0;
                this.stateBuffer = { player: { x: 0, y: 0, z: 0, speed: 0 }, obstacles: [], coins: [], powerUps: [], score: 0, level: 1, timestamp: 0 };
                this._stateBroadcastInterval = null;
                this._frameInput = null; // one getInput() per frame, reused for steer + jump/boost/powerUp
            }
            async connect(agentId, accessKey, endpoint) {
                this.agentId = agentId;
                const url = (endpoint || 'ws://localhost:8080').trim().replace(/^http/, 'ws');
                try {
                    this.updateStatus('connecting');
                    document.getElementById('agent-status').style.display = 'block';
                    this.wsConnection = new WebSocket(url);
                    this.wsConnection.onopen = () => {
                        console.log('[Agent] Connected:', agentId);
                        this.authenticate(accessKey);
                        this.isAgentMode = true;
                        this.updateStatus('connected');
                        document.getElementById('agent-status').style.display = 'block';
                        setTimeout(() => {
                            closeAgentModal();
                            if (typeof setMessage === 'function') setMessage('ü§ñ Agent connected. Click Play Game to start!');
                        }, 1200);
                    };
                    this.wsConnection.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleAgentAction(data.type === 'action' ? data : { steer: data.steer, jump: data.jump, boost: data.boost, usePowerUp: data.usePowerUp });
                        } catch (e) { console.warn('[Agent] Invalid message', e); }
                    };
                    this.wsConnection.onerror = () => { this.updateStatus('error'); this.fallbackToAI(); };
                    this.wsConnection.onclose = () => { this.updateStatus('disconnected'); this.isAgentMode = false; if (this._stateBroadcastInterval) clearInterval(this._stateBroadcastInterval); };
                    this.startStateBroadcast();
                    return true;
                } catch (err) {
                    console.error('[Agent] Failed to connect:', err);
                    this.updateStatus('failed');
                    return false;
                }
            }
            authenticate(accessKey) {
                const challenge = this.generateChallenge();
                this.wsConnection.send(JSON.stringify({
                    type: 'auth',
                    role: 'game',
                    agentId: this.agentId,
                    challenge: challenge,
                    response: this.signChallenge(challenge, accessKey),
                    timestamp: Date.now()
                }));
            }
            generateChallenge() {
                return Array.from(crypto.getRandomValues(new Uint8Array(32))).map(b => b.toString(16).padStart(2, '0')).join('');
            }
            signChallenge(challenge, key) {
                let hash = 0;
                const combined = challenge + key;
                for (let i = 0; i < combined.length; i++) { const char = combined.charCodeAt(i); hash = ((hash << 5) - hash) + char; hash = hash & hash; }
                return hash.toString(16);
            }
            handleAgentAction(action) {
                const now = Date.now();
                if (now - this.lastProcessedAction < this.minActionInterval) return;
                this.lastProcessedAction = now;
                if (!action || typeof action.steer !== 'number' || typeof action.jump !== 'boolean' || typeof action.boost !== 'boolean' || typeof action.usePowerUp !== 'boolean') return;
                this.actionQueue.push({ steer: Math.max(-1, Math.min(1, action.steer)), jump: action.jump, boost: action.boost, usePowerUp: action.usePowerUp, timestamp: now });
                this.actionCount++;
                if (now - this.lastActionTime >= 1000) { this.actionsPerSecond = this.actionCount; this.actionCount = 0; this.lastActionTime = now; this.updatePerformanceDisplay(); }
                if (this.actionCount === 1 && Math.random() < 0.05) console.log('[Agent] Receiving actions from bot');
            }
            getInput() {
                if (this._frameInput !== null) return this._frameInput;
                if (!this.isAgentMode || this.actionQueue.length === 0) { this._frameInput = this.lastAction; return this._frameInput; }
                const action = this.actionQueue.shift();
                this.targetSteer = action.steer;
                this.currentSteer += (this.targetSteer - this.currentSteer) * this.steerSmoothing;
                this.lastAction = { steer: this.currentSteer, jump: action.jump, boost: action.boost, usePowerUp: action.usePowerUp };
                this._frameInput = this.lastAction;
                return this._frameInput;
            }
            clearFrameInput() { this._frameInput = null; }
            startStateBroadcast() {
                if (this._stateBroadcastInterval) clearInterval(this._stateBroadcastInterval);
                this._stateBroadcastInterval = setInterval(() => {
                    if (!this.isAgentMode || !this.wsConnection || this.wsConnection.readyState !== WebSocket.OPEN) return;
                    this.updateStateBuffer();
                    this.wsConnection.send(JSON.stringify({ type: 'state', data: this.stateBuffer }));
                }, 50);
            }
            updateStateBuffer() {
                if (typeof playerMotorcycle === 'undefined') return;
                this.stateBuffer = {
                    player: { x: playerMotorcycle.position.x, y: playerMotorcycle.position.y, z: playerMotorcycle.position.z, speed: typeof currentMoveSpeed !== 'undefined' ? currentMoveSpeed : 0, isJumping: typeof isJumping !== 'undefined' ? isJumping : false, hasPowerUp: (typeof hasProjectile !== 'undefined' && hasProjectile) || (typeof hasObstacleDrop !== 'undefined' && hasObstacleDrop) || (typeof hasSwapPosition !== 'undefined' && hasSwapPosition) },
                    obstacles: (function() {
                        const obs = typeof obstacles !== 'undefined' ? obstacles : [];
                        const pz = playerMotorcycle.position.z, px = playerMotorcycle.position.x;
                        return obs.slice().sort((a, b) => {
                            const da = Math.hypot(a.position.x - px, a.position.z - pz);
                            const db = Math.hypot(b.position.x - px, b.position.z - pz);
                            return da - db;
                        }).slice(0, 5).map(o => ({ x: o.position.x, z: o.position.z, type: o.userData && o.userData.isIceGap ? 'gap' : 'obstacle' }));
                    })(),
                    coins: (typeof coins !== 'undefined' ? coins : []).slice(0, 10).map(c => ({ x: c.position.x, z: c.position.z })),
                    powerUps: (typeof powerUps !== 'undefined' ? powerUps : []).slice(0, 3).map(p => ({ x: p.position.x, z: p.position.z, type: (p.userData && p.userData.type) || 'powerUp' })),
                    score: typeof score !== 'undefined' ? score : 0,
                    level: typeof level !== 'undefined' ? level : 1,
                    biome: typeof currentBiome !== 'undefined' ? currentBiome : 'arctic',
                    timestamp: Date.now()
                };
            }
            fallbackToAI() { console.log('[Agent] Falling back to built-in'); this.isAgentMode = false; }
            disconnect() { if (this._stateBroadcastInterval) clearInterval(this._stateBroadcastInterval); this._stateBroadcastInterval = null; if (this.wsConnection) this.wsConnection.close(); this.isAgentMode = false; this.agentId = null; }
            updateStatus(status) {
                const map = { connected: { icon: 'üü¢', text: 'Agent Connected' }, connecting: { icon: 'üü°', text: 'Connecting...' }, error: { icon: 'üî¥', text: 'Connection Error' }, disconnected: { icon: '‚ö™', text: 'Disconnected' }, failed: { icon: '‚ùå', text: 'Connection Failed' } };
                const s = map[status]; if (!s) return;
                const el = document.getElementById('status-icon'); const te = document.getElementById('status-text');
                if (el) el.textContent = s.icon; if (te) te.textContent = s.text;
            }
            updatePerformanceDisplay() {
                const le = document.getElementById('agent-latency'); const ae = document.getElementById('agent-actions');
                if (le) le.textContent = this.latency; if (ae) ae.textContent = this.actionsPerSecond;
            }
        }
        const agentController = new AgentController();

        // Show what the agent sees (inputs) and does (outputs). Remote agent = no weights/hidden layers.
        function visualizeAgentBrain(controller) {
            const container = document.getElementById('brain-viz-container');
            const canvas = document.getElementById('brain-viz');
            if (!container || !canvas) return;
            const isActive = controller && controller.isAgentMode && typeof isGameRunning !== 'undefined' && isGameRunning && !gamePaused;
            if (!isActive) {
                container.style.display = 'none';
                return;
            }
            container.style.display = 'block';
            const ctx = canvas.getContext('2d');
            if (!ctx) return;
            const w = canvas.width;
            const h = canvas.height;
            const lastState = controller.stateBuffer || {};
            const lastDecision = controller.lastAction || { steer: 0, jump: false, boost: false, usePowerUp: false };

            ctx.fillStyle = 'rgba(0,12,24,0.9)';
            ctx.fillRect(0, 0, w, h);

            const inputX = 28;
            const midX = w / 2;
            const outputX = w - 28;
            const layerH = h / 4;

            // ‚îÄ‚îÄ‚îÄ Input layer (what we send to agent) ‚îÄ‚îÄ‚îÄ
            ctx.fillStyle = 'rgba(0,200,255,0.25)';
            ctx.fillRect(2, 2, inputX + 20, h - 4);
            ctx.fillStyle = '#7dd3fc';
            ctx.font = '9px monospace';
            ctx.fillText('In', inputX - 10, 14);
            const player = lastState.player || {};
            const obs = lastState.obstacles || [];
            const inputs = [
                'x ' + (player.x != null ? player.x.toFixed(1) : '-'),
                'z ' + (player.z != null ? player.z.toFixed(0) : '-'),
                'spd ' + (player.speed != null ? player.speed.toFixed(0) : '-'),
                'obs ' + obs.length,
                'sc ' + (lastState.score != null ? lastState.score : '-')
            ];
            inputs.forEach((t, i) => {
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.fillText(t, 4, 28 + i * 14);
            });

            // ‚îÄ‚îÄ‚îÄ Middle: "Remote" (no weights in browser) ‚îÄ‚îÄ‚îÄ
            ctx.fillStyle = 'rgba(100,100,120,0.3)';
            ctx.fillRect(midX - 24, layerH, 48, h - 2 * layerH);
            ctx.fillStyle = '#94a3b8';
            ctx.font = '8px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Remote', midX, h / 2 - 4);
            ctx.fillText('agent', midX, h / 2 + 6);
            ctx.textAlign = 'left';

            // ‚îÄ‚îÄ‚îÄ Output layer (what agent decided) ‚îÄ‚îÄ‚îÄ
            ctx.fillStyle = 'rgba(0,255,150,0.2)';
            ctx.fillRect(outputX - 22, 2, 44, h - 4);
            ctx.fillStyle = '#5eead4';
            ctx.font = '9px monospace';
            ctx.fillText('Out', outputX - 14, 14);
            const steer = lastDecision.steer != null ? lastDecision.steer : 0;
            const jump = lastDecision.jump ? 1 : 0;
            const boost = lastDecision.boost ? 1 : 0;
            const pwr = lastDecision.usePowerUp ? 1 : 0;
            ctx.fillStyle = steer !== 0 ? 'rgba(0,255,150,0.9)' : 'rgba(255,255,255,0.5)';
            ctx.fillText('steer ' + steer.toFixed(2), outputX - 20, 36);
            ctx.fillStyle = jump ? 'rgba(0,255,150,0.9)' : 'rgba(255,255,255,0.4)';
            ctx.fillText('jump ' + jump, outputX - 20, 50);
            ctx.fillStyle = boost ? 'rgba(0,255,150,0.9)' : 'rgba(255,255,255,0.4)';
            ctx.fillText('boost ' + boost, outputX - 20, 64);
            ctx.fillStyle = pwr ? 'rgba(0,255,150,0.9)' : 'rgba(255,255,255,0.4)';
            ctx.fillText('power ' + pwr, outputX - 20, 78);

            // Simple connection lines (input ‚Üí mid ‚Üí output)
            ctx.strokeStyle = 'rgba(0,200,255,0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(inputX + 18, h / 2);
            ctx.lineTo(midX - 24, h / 2);
            ctx.stroke();
            ctx.strokeStyle = 'rgba(0,255,150,0.25)';
            ctx.beginPath();
            ctx.moveTo(midX + 24, h / 2);
            ctx.lineTo(outputX - 22, h / 2);
            ctx.stroke();
        }

        function checkAgentJump() {
            if (!agentController.isAgentMode || !isGameRunning || gamePaused) return;
            const inpt = agentController.getInput();
            if (inpt.jump && !isJumping) startJump();
        }
        function checkAgentBoost() {
            if (!agentController.isAgentMode || !isGameRunning || gamePaused) return;
            if (typeof BOOST_UNLOCK_LEVEL === 'undefined' || level < BOOST_UNLOCK_LEVEL) return;
            const inpt = agentController.getInput();
            if (inpt.boost && !isBoosting) activateBoost(3000, true);
        }
        function checkAgentPowerUp() {
            if (!agentController.isAgentMode || !isGameRunning || gamePaused) return;
            const inpt = agentController.getInput();
            if (inpt.usePowerUp && (hasProjectile || hasObstacleDrop || hasSwapPosition)) usePowerUp();
        }

        function getPlayerManualSteerDirection() {
            if (agentController.isAgentMode) return agentController.getInput().steer;
            let manualSteer = 0;
            if (!isMobileDevice() && gameMode === 'manual') {
                 if (keys['ArrowLeft'] || keys['a']) {
                     manualSteer = 1;
                 } else if (keys['ArrowRight'] || keys['d']) {
                     manualSteer = -1;
                 }
            }
             if (isMobileDevice() && gameMode === 'manual') {
                 if (steerLeftButton && steerLeftButton.classList.contains('active')) manualSteer = 1;
                 else if (steerRightButton && steerRightButton.classList.contains('active')) manualSteer = -1;
                 if (swipeSteerDirection !== 0) manualSteer = swipeSteerDirection;
             }
            return manualSteer;
        }

        function automateAIMotorcycle(aiBike) {
             // Only move the AI if canMove is true
             if (!aiBike.userData.canMove) return;

             const difficultyMultiplier = difficultySettings[gameDifficulty].multiplier;
             const currentAiMoveSpeed = isSlowTimeActive ? 
                 aiBike.userData.moveSpeed * slowTimeFactor * difficultyMultiplier : 
                 aiBike.userData.moveSpeed * difficultyMultiplier;
             aiBike.position.z -= currentAiMoveSpeed;

            aiBike.userData.targetTimer++;
            if (aiBike.userData.targetTimer >= 90 || Math.random() < 0.2) {
                 aiBike.userData.targetX = (Math.random() - 0.5) * (roadWidth - 1);
                 aiBike.userData.targetTimer = 0;
            }

            const steeringDifference = aiBike.userData.targetX - aiBike.position.x;
            const steerMagnitude = Math.min(aiBike.userData.steerSpeed, Math.abs(steeringDifference) * 0.05);

            let steeringDirection = 0;
            if (steeringDifference < -0.1) {
              steeringDirection = -1;
            } else if (steeringDifference > 0.1) {
              steeringDirection = 1;
            }
            aiBike.position.x += steeringDirection * steerMagnitude;
            aiBike.rotation.y = steeringDirection * 0.1;
            aiBike.rotation.x = 0;
            aiBike.rotation.z = 0;

            const aiBikeX = aiBike.position.x;
            if (aiBikeX < -roadEdgeThreshold) {
                 aiBike.position.x = -roadEdgeThreshold;
            } else if (aiBikeX > roadEdgeThreshold) {
                 aiBike.position.x = roadEdgeThreshold;
            }

             const lookAheadDistance = 10;
             const currentAiPosition = aiBike.position.clone();
             const aiForward = new THREE.Vector3(0, 0, -1).applyQuaternion(aiBike.quaternion);
             const lookAheadPoint = currentAiPosition.clone().add(aiForward.multiplyScalar(lookAheadDistance));
             let avoidDirection = 0;

             let obstacleChecks = 0;
             for (let oi = 0; oi < obstacles.length && obstacleChecks < INVARIANT_MAX_OBSTACLE_CHECKS_PER_AI; oi++) {
                 obstacleChecks++;
                 const obstacle = obstacles[oi];
                 const distToObstacle = lookAheadPoint.distanceTo(obstacle.position);
                 if (distToObstacle < 3) {
                     avoidDirection = obstacle.position.x - aiBike.position.x > 0 ? -1 : 1;
                     break;
                 }
             }
             if (avoidDirection === 0) {
                 let ballChecks = 0;
                 for (let bi = 0; bi < bowlingBallObstacles.length && ballChecks < INVARIANT_MAX_BOWLING_CHECKS_PER_AI; bi++) {
                     ballChecks++;
                     const bowlingBall = bowlingBallObstacles[bi];
                     if (lookAheadPoint.distanceTo(bowlingBall.position) < 3) {
                         avoidDirection = bowlingBall.position.x - aiBike.position.x > 0 ? -1 : 1;
                         break;
                     }
                 }
             }
             if (avoidDirection !== 0) {
                 aiBike.position.x += avoidDirection * aiBike.userData.steerSpeed * 1.5;
             }

             let coinChecks = 0;
             for (let i = coins.length - 1; i >= 0; i--) {
                 if (coinChecks >= INVARIANT_MAX_COIN_CHECKS_PER_AI) break;
                 const coin = coins[i];
                 if (Math.abs(coin.position.z - aiBike.position.z) > 10) continue;
                 coinChecks++;
                 if (aiBike.position.distanceTo(coin.position) < 1.0) {
                     scene.remove(coin);
                     returnToPool('coins', coin);
                     coins.splice(i, 1);
                     break;
                 }
             }
        }

         function moveBatGang(batGang) {
             const currentBatGangSpeed = isSlowTimeActive ? batGang.userData.speed * slowTimeFactor : batGang.userData.speed;
             batGang.position.z += currentBatGangSpeed * baseMoveSpeed * 1.2; // Bats chase player at reasonable speed
             if (batGang.userData.attackPattern === 'swoop') {
                 batGang.userData.swoopPhase += batGang.userData.frequency;
                 batGang.position.y = 2 + Math.sin(batGang.userData.swoopPhase) * batGang.userData.amplitude;
             }
         }

        // DRAGON VISUAL ENHANCEMENT: Updated moveDragon function for new visuals
        function moveDragon(tieFighter) {
            tieFighter.userData.attackTimer++;
            
            // BERSERKER FURY MODE - Level 90 dragon only
            if (tieFighter.userData.tieFighterType === 2) {
                tieFighter.userData.berserkerTimer++;
                
                // Trigger berserker fury after 30 seconds (1800 frames at 60fps)
                if (!tieFighter.userData.berserkerTriggered && tieFighter.userData.berserkerTimer >= 1800) {
                    tieFighter.userData.berserkerFury = true;
                    tieFighter.userData.berserkerTriggered = true;
                    setMessage("üíÄ FINAL STRONGHOLD ENTERING BERSERKER FURY! MAXIMUM EVASION!");
                    
                    // Visual effect - make all segments pulse red
                    tieFighter.userData.segments.forEach(segment => {
                        if(segment.material.emissive) {
                            segment.material.emissive.setHex(0xff0000); // Red emissive
                            segment.material.emissiveIntensity = 2.0;
                        }
                    });
                    
                    // Continuous screen shake for berserker fury
                    triggerCameraShake(2.0, 30000); // 30 second continuous shake
                }
                
                // Handle charge cooldown for triple charges
                if (tieFighter.userData.chargeCooldown > 0) {
                    tieFighter.userData.chargeCooldown--;
                }
            }
            
            // Calculate distance to player for proximity-based behavior
            const distanceToPlayer = tieFighter.position.distanceTo(playerMotorcycle.position);
        
            // --- Attack Logic ---
            const isBerserkerFury = tieFighter.userData.berserkerFury;
            const attackCondition = isBerserkerFury ? 
                (tieFighter.userData.chargeCooldown === 0 && tieFighter.userData.chargeCount < tieFighter.userData.maxCharges) :
                (tieFighter.userData.attackTimer > tieFighter.userData.attackInterval);
                
            if (attackCondition && !tieFighter.userData.isCharging) {
                tieFighter.userData.isCharging = true;
                tieFighter.userData.attackTimer = 0; // Reset timer for next charge
                
                if (isBerserkerFury) {
                    tieFighter.userData.chargeCount++;
                    tieFighter.userData.chargeCooldown = tieFighter.userData.chargeCount < tieFighter.userData.maxCharges ? 30 : 120; // 0.5s between charges, 2s after triple
                }
                
                // Add a visual cue for charging
                tieFighter.userData.segments.forEach(segment => {
                    if(segment.material.emissive) {
                        segment.material.emissiveIntensity = isBerserkerFury ? 4.0 : 3.0; // Extra bright for berserker fury
                    }
                });
                
                // Alert player of incoming attack
                if (isBerserkerFury) {
                    setMessage(`üíÄ BERSERKER CHARGE ${tieFighter.userData.chargeCount}/3! DODGE NOW!`);
                } else {
                    setMessage("‚ö†Ô∏è STRONGHOLD CHARGING ATTACK!");
                }
            }
        
            let currentTieFighterSpeed;
            if (tieFighter.userData.isCharging) {
                // BERSERKER FURY: Massively increased charge speed
                const chargeMultiplier = isBerserkerFury ? 5.0 : 3.5; // 12.5 speed for berserker fury vs 8.75 for normal
                currentTieFighterSpeed = tieFighter.userData.speed * chargeMultiplier;
                
                // Charge for a longer duration to be more threatening
                if (tieFighter.userData.attackTimer > 90) { // 1.5 second charge at 60fps
                    tieFighter.userData.isCharging = false;
                    
                    // Reset charge count if this was the last charge in berserker fury
                    if (isBerserkerFury && tieFighter.userData.chargeCount >= tieFighter.userData.maxCharges) {
                        tieFighter.userData.chargeCount = 0;
                    }
                    
                    // Restore normal glow
                    tieFighter.userData.segments.forEach(segment => {
                        if(segment.material.emissive) {
                            segment.material.emissiveIntensity = isBerserkerFury ? 2.0 : 1.5;
                        }
                    });
                    
                    if (isBerserkerFury) {
                        setMessage("üíÄ Berserker charge completed!");
                    } else {
                        setMessage("üíÄ Stronghold attack completed!");
                    }
                }
            } else {
                // PERSISTENT CHASING: Speed depends on distance to maintain pressure
                if (distanceToPlayer > 30) {
                    // Far away - speed up significantly to catch up
                    currentTieFighterSpeed = tieFighter.userData.speed * 2.2; // INCREASED FROM 1.8 TO 2.2
                } else if (distanceToPlayer > 15) {
                    // Medium distance - normal chase speed
                    currentTieFighterSpeed = tieFighter.userData.speed * 1.8; // INCREASED FROM 1.3 TO 1.8
                } else {
                    // Close - still aggressive but controlled
                    currentTieFighterSpeed = tieFighter.userData.speed * 1.2; // INCREASED FROM 0.9 TO 1.2
                }
            }
        
            // Apply slow time effect
            if (isSlowTimeActive) {
                currentTieFighterSpeed *= slowTimeFactor;
            }
        
            // --- Movement Logic ---
            const direction = new THREE.Vector3().subVectors(playerMotorcycle.position, tieFighter.position).normalize();
            
            // AGGRESSIVE MOVEMENT: Always move toward player
            tieFighter.position.add(direction.multiplyScalar(currentTieFighterSpeed));
        
            // SMART POSITIONING: Try to get behind or to the side of player for flanking
            const targetX = playerMotorcycle.position.x + (Math.sin(Date.now() * 0.002) * 2); // Weave side to side
            tieFighter.position.x += (targetX - tieFighter.position.x) * 0.05; // Increased responsiveness
        
            // Maintain vertical oscillation but keep it above the road
            tieFighter.userData.verticalPhase += tieFighter.userData.frequency;
            tieFighter.position.y = Math.max(2.0, 6 + Math.sin(tieFighter.userData.verticalPhase) * tieFighter.userData.amplitude);
        
            // Make the tieFighter look at the player menacingly
            tieFighter.lookAt(playerMotorcycle.position);
            
            // THREAT PROXIMITY WARNINGS WITH PERIODIC REMINDERS
            if (!tieFighter.userData.reminderTimer) tieFighter.userData.reminderTimer = 0;
            tieFighter.userData.reminderTimer++;
            
            if (distanceToPlayer < 20 && distanceToPlayer > 15) {
                if (Math.random() < 0.01) { // Occasional warning
                    setMessage("üî¥ STRONGHOLD APPROACHING!");
                }
            } else if (distanceToPlayer < 10) {
                if (Math.random() < 0.02) { // More frequent warnings when very close
                    setMessage("üíÄ STRONGHOLD IMMINENT THREAT!");
                }
            }
            
            // PERIODIC PRESENCE REMINDER - every 8 seconds (480 frames at 60fps)
            if (tieFighter.userData.reminderTimer >= 480) {
                if (distanceToPlayer < 50) { // Only if reasonably close
                    const messages = [
                        "üëÅÔ∏è Stronghold still hunting you...",
                        "‚ö†Ô∏è Don't forget the stronghold behind you!",
                        "üíÄ Stronghold maintaining pursuit...",
                        "üéØ You can't shake the stronghold!"
                    ];
                    setMessage(messages[Math.floor(Math.random() * messages.length)]);
                }
                tieFighter.userData.reminderTimer = 0;
            }
        
            // PERSISTENT THREAT: Only remove if player gets VERY far ahead (much more lenient)
            if (tieFighter.position.z > playerMotorcycle.position.z + 150) {
                scene.remove(tieFighter);
                dragons.splice(dragons.indexOf(tieFighter), 1);
                setMessage("üéØ Stronghold lost your trail... for now.");
            }
            
            // COLLISION DETECTION: Damage player if stronghold gets too close
            if (distanceToPlayer < 3.0 && !isGhostActive && !isInvincible && !isCinematicInvulnerable) {
                // BERSERKER FURY: Double EMC penalty for Level 90 dragons
                const emcPenalty = (tieFighter.userData.tieFighterType === 2 && isBerserkerFury) ? 100 : 50;
                if (score > 0) score = Math.max(0, score - emcPenalty);
                updateScoreDisplay();
                
                if (emcPenalty === 100) {
                    setMessage("üí• BIG ICE HIT! --100 Coins");
                } else {
                    setMessage("üí• ICE OBSTACLE! --50 Coins");
                }
                
                // Push stronghold back slightly after impact
                const pushDirection = direction.clone().multiplyScalar(-10);
                tieFighter.position.add(pushDirection);
                
                // Give player brief invincibility after impact
                isInvincible = true;
                setTimeout(() => {
                    isInvincible = false;
                }, 2000); // 2 seconds of invincibility
            }
        }

        // ALLEY BAT MOVEMENT
        function moveAlleyBat(bat) {
            const currentBatSpeed = isSlowTimeActive ? bat.userData.speed * slowTimeFactor : bat.userData.speed;
            bat.position.z += currentBatSpeed * baseMoveSpeed * 1.1;
            
            // Simple side-to-side movement for dodging challenge
            bat.position.x += Math.sin(Date.now() * 0.005) * 0.02;
            
            if (bat.position.z > playerMotorcycle.position.z + 50) {
                scene.remove(bat);
                batAlleyBats.splice(batAlleyBats.indexOf(bat), 1);
            }
        }

        // ALLEY BOWLING BALL MOVEMENT
        function moveAlleyBowlingBall(ball) {
            // Stationary like normal bowling balls
            if (ball.position.z > playerMotorcycle.position.z + 5) {
                scene.remove(ball);
                bowlingBallAlleyBalls.splice(bowlingBallAlleyBalls.indexOf(ball), 1);
            }
        }

        // FINAL BAT MOVEMENT - Attacks player directly
        function moveFinalBat(bat) {
            bat.userData.pulsePhase += 0.1;
            
            // Pulsing aura effect
            if (bat.children[1]) { // Aura
                const pulseFactor = 1 + Math.sin(bat.userData.pulsePhase) * 0.3;
                bat.children[1].scale.setScalar(pulseFactor);
            }
            
            if (!bat.userData.isAttacking) {
                // Move toward player's X position
                const direction = new THREE.Vector3().subVectors(playerMotorcycle.position, bat.position).normalize();
                bat.position.add(direction.multiplyScalar(bat.userData.speed));
                
                // Start attacking when close enough
                const distance = bat.position.distanceTo(playerMotorcycle.position);
                if (distance < 15) {
                    bat.userData.isAttacking = true;
                    setMessage("üíÄ FINAL BAT DIVING! DISCO POWER ONLY!");
                }
            } else {
                // Direct attack toward player
                const direction = new THREE.Vector3().subVectors(playerMotorcycle.position, bat.position).normalize();
                bat.position.add(direction.multiplyScalar(bat.userData.speed * 1.5)); // Faster when attacking
            }
            
            // Remove if too far away
            if (bat.position.z > playerMotorcycle.position.z + 50) {
                scene.remove(bat);
                finalBats.splice(finalBats.indexOf(bat), 1);
            }
        }

        // NEW GALAXY ZONE SYSTEM
        function updateGalaxyZone() {
            galaxyZoneTimer++;
            
            // Spawn galaxy ships
            if (galaxyShips.length < maxGalaxyShips && Math.random() < 1 / galaxyShipSpawnRate) {
                const ship = createGalaxyShip();
                ship.position.set(
                    (Math.random() - 0.5) * roadWidth * 1.5,
                    3 + Math.random() * 4,
                    playerMotorcycle.position.z - 80 - Math.random() * 60
                );
                scene.add(ship);
                galaxyShips.push(ship);
                console.log("Galaxy ship spawned at level", level);
            }
            
            // Update galaxy ships
            for (let i = galaxyShips.length - 1; i >= 0; i--) {
                const ship = galaxyShips[i];
                
                // Ship movement with drift pattern
                ship.userData.driftAngle += ship.userData.driftSpeed;
                ship.position.x += Math.sin(ship.userData.driftAngle) * 0.05;
                ship.position.z += ship.userData.speed;
                
                // Ship shooting behavior
                ship.userData.shootTimer++;
                if (ship.userData.shootTimer >= ship.userData.shootInterval) {
                    // Calculate direction to player
                    const direction = new THREE.Vector3()
                        .subVectors(playerMotorcycle.position, ship.position)
                        .normalize();
                    
                    if (galaxyProjectiles.length >= MAX_GALAXY_PROJECTILES) {
                        const old = galaxyProjectiles.shift();
                        scene.remove(old);
                        disposeObject(old);
                    }
                    const projectile = createGalaxyProjectile(ship.position.clone(), direction);
                    scene.add(projectile);
                    galaxyProjectiles.push(projectile);
                    
                    // Play shooting sound
                    projectileSynth.triggerAttackRelease('A4', '8n');
                    
                    ship.userData.shootTimer = 0;
                    ship.userData.shootInterval = 60 + Math.random() * 80; // Reset with some randomness
                }
                
                // Ship bomb dropping behavior
                if (!ship.userData.bombTimer) ship.userData.bombTimer = 0;
                ship.userData.bombTimer++;
                if (ship.userData.bombTimer >= bombDropRate && Math.random() < 0.8) {
                    if (galaxyBombs.length >= MAX_GALAXY_BOMBS) {
                        const old = galaxyBombs.shift();
                        scene.remove(old);
                        disposeObject(old);
                    }
                    const bomb = createGalaxyBomb(ship.position.clone());
                    scene.add(bomb);
                    galaxyBombs.push(bomb);
                    
                    console.log("Red vial bomb dropped at position:", bomb.position); // Debug message
                    setMessage("üí£ Enemy ship dropped a red vial bomb!"); // Visual feedback
                    
                    // Play bomb drop sound
                    projectileSynth.triggerAttackRelease('C3', '8n');
                    
                    ship.userData.bombTimer = 0;
                }
                
                if (ship.position.z > playerMotorcycle.position.z + 100 || 
                    ship.position.z < playerMotorcycle.position.z - 200) {
                    scene.remove(ship);
                    disposeObject(ship);
                    galaxyShips.splice(i, 1);
                }
            }
            
            // Update galaxy projectiles
            for (let i = galaxyProjectiles.length - 1; i >= 0; i--) {
                const projectile = galaxyProjectiles[i];
                
                // Move projectile
                projectile.position.add(projectile.userData.velocity);
                projectile.userData.life++;
                
                // Check collision with player
                const distance = playerMotorcycle.position.distanceTo(projectile.position);
                if (distance < 2.0 && !isGhostActive && !isInvincible && !isCinematicInvulnerable && !isBlasterActive) {
                    // Player hit by galaxy projectile
                    createExplosion(projectile.position, 0xff00ff);
                    explosionSynth.triggerAttackRelease("8n");
                    
                    // Damage or effect
                                         if (score > 0) score = Math.max(0, score - 2);
                     updateScoreDisplay();
                    setMessage("‚ö° Hit by ice shard! --2 Coins");
                    
                    scene.remove(projectile);
                    disposeObject(projectile);
                    galaxyProjectiles.splice(i, 1);
                    continue;
                }
                if (projectile.userData.life > projectile.userData.maxLife ||
                    projectile.position.z > playerMotorcycle.position.z + 50) {
                    scene.remove(projectile);
                    disposeObject(projectile);
                    galaxyProjectiles.splice(i, 1);
                }
            }
            
            // Update galaxy bombs
            for (let i = galaxyBombs.length - 1; i >= 0; i--) {
                const bomb = galaxyBombs[i];
                bomb.userData.life++;
                
                // Apply gravity and movement
                bomb.userData.velocity.y += bomb.userData.gravity;
                bomb.position.add(bomb.userData.velocity);
                
                // Rotate bomb as it falls
                bomb.rotation.x += 0.05;
                bomb.rotation.z += 0.03;
                
                // Check collision with player
                const distanceToPlayer = bomb.position.distanceTo(playerMotorcycle.position);
                if (distanceToPlayer < 2.5 && !isGhostActive && !isInvincible && !isCinematicInvulnerable && !isBlasterActive && !bomb.userData.hasExploded) {
                    // Hit player with bomb - more damage than projectiles
                    createExplosion(bomb.position.clone(), 0xff0000);
                    explosionSynth.triggerAttackRelease("8n");
                    
                                         if (score > 0) score = Math.max(0, score - 3);
                     updateScoreDisplay();
                                                             setMessage("üí£ Hit by falling ice! --3 Coins");
                    
                    bomb.userData.hasExploded = true;
                    scene.remove(bomb);
                    disposeObject(bomb);
                    galaxyBombs.splice(i, 1);
                    continue;
                }
                
                // Check if bomb hits ground/road
                if (bomb.position.y <= -1 && !bomb.userData.hasExploded) {
                    // Bomb hits ground - create explosion effect
                    createExplosion(bomb.position.clone(), 0xff4500); // Orange-red explosion
                    explosionSynth.triggerAttackRelease("8n");
                    
                    bomb.userData.hasExploded = true;
                }
                
                if (bomb.userData.life > bomb.userData.maxLife || bomb.userData.hasExploded ||
                    bomb.position.z > playerMotorcycle.position.z + 50 ||
                    bomb.position.z < playerMotorcycle.position.z - 50) {
                    scene.remove(bomb);
                    disposeObject(bomb);
                    galaxyBombs.splice(i, 1);
                }
            }
        }

        function showRandomDialogue() {
            if (dialogueMessages.length === 0 || isGameOver || !isGameRunning || gamePaused) return;
            const randomIndex = Math.floor(Math.random() * dialogueMessages.length);
            dialogueBox.textContent = dialogueMessages[randomIndex];
            dialogueBox.style.display = 'block';
            setTimeout(() => {
                dialogueBox.style.display = 'none';
            }, 3000);
        }

         function setMessage(message) {
             dialogueBox.textContent = message;
             dialogueBox.style.display = 'block';
             setTimeout(() => {
                 dialogueBox.style.display = 'none';
             }, 3000);
         }


        // Update lightning effect for more impact
        function createLightningStrike() {
            if (isGameOver || !isGameRunning || gamePaused) return;
            lightningLight.intensity = 8; // Increased from 5
            lightningFlashElement.style.display = 'block';
            lightningFlashElement.style.backgroundColor = 'rgba(255, 255, 255, 0.9)'; // Increased opacity
            setTimeout(() => {
                lightningLight.intensity = 0;
                lightningFlashElement.style.display = 'none';
            }, lightningDuration);
        }

        // Update level up effect (no shake on level-up ‚Äî shake only on competitor collision)
        function showLevelUp(level) {
            if (level !== GRAND_PRIZE_LEVEL) {
                levelUpPopup.textContent = `ICEBERG ${level}!`;
                levelUpPopup.style.display = 'block';
                levelUpPopup.style.fontSize = 'clamp(2.3rem, 5.75vw, 4.6rem)';
                levelUpPopup.style.textShadow = '0 0 20px #ff6600, 0 0 40px #ff6600, 0 0 60px #ff3300, 0 0 80px #ff3300';
                levelUpPopup.style.animation = 'none'; // Reset animation
                // Trigger animation
                setTimeout(() => {
                    levelUpPopup.style.animation = 'levelUpFlash 0.8s ease-out forwards';
                }, 10);
                createLightningStrike();
                
                // Haptic feedback for level up (pattern: tap-pause-longer tap)
                if (navigator.vibrate) {
                    navigator.vibrate([50, 30, 100]);
                }
                
                // Add special message for extreme difficulty level
                if (level === EXTREME_DIFFICULTY_LEVEL) {
                    levelUpPopup.textContent = `EXTREME MODE!`;
                    levelUpPopup.style.fontSize = 'clamp(2.875rem, 6.9vw, 5.75rem)';
                    levelUpPopup.style.color = '#ff0000';
                    levelUpPopup.style.textShadow = '0 0 30px #ff0000, 0 0 60px #ff0000, 0 0 90px #ff3300, 0 0 120px #ff3300';
                    
                    // Multiple lightning strikes for dramatic effect
                    setTimeout(() => createLightningStrike(), 300);
                    setTimeout(() => createLightningStrike(), 600);
                    setTimeout(() => createLightningStrike(), 900);
                    
                    // Show warning message
                    setTimeout(() => {
                        setMessage("WARNING: Extreme difficulty activated!");
                    }, 1500);
                }
                
                // Quick flash - hide after animation completes
                setTimeout(() => {
                    levelUpPopup.style.display = 'none';
                }, 800); // Quick flash - reduced from 2500ms
            }
            updateRiderAppearance(level);
        }

         function updateRiderAppearance(currentLevel) {
             // Apply customization settings instead of hard-coded appearance
             // Respect the player's chosen customization settings
             
             // Apply the current rider outfit from customization settings
             applyRiderOutfit(customization.currentOutfit);
             
             // Apply the current bike skin from customization settings  
             applySkinToMotorcycle(playerMotorcycle, customization.currentSkin);
             
             // Ensure rider parts maintain proper scale
             if (playerRiderBody) {
                 playerRiderBody.scale.set(1, 1, 1);
             }
             if (playerRiderHead) {
                 playerRiderHead.scale.set(1, 1, 1);
             }
         }


         function createCoinBurst(position) {
             const numParticles = 40 + Math.floor(Math.random() * 25);
             const pool = burstMaterialPool;
             for (let i = 0; i < numParticles; i++) {
                 const particle = getPooledObject('particles', () => {
                     const m = new THREE.Mesh(sharedGeometries.particle, pool[i % pool.length]);
                     m.userData.fromMaterialPool = true;
                     m.userData.sharedGeometry = true;
                     return m;
                 });
                 if (!particle.userData.fromMaterialPool) {
                     particle.userData.fromMaterialPool = true;
                     particle.userData.sharedGeometry = true;
                 }
                 particle.scale.set(0.8, 0.8, 0.8);
                 particle.position.copy(position);
                 particle.userData.velocity = new THREE.Vector3(
                     (Math.random() - 0.5) * 3.0,
                     Math.random() * 2.0 + 0.8,
                     (Math.random() - 0.5) * 3.0
                 );
                 particle.userData.life = 0;
                 particle.userData.maxLife = 100;
                 scene.add(particle);
                 activeBursts.push(particle);
             }
         }
         
         // MAGICAL SPARKLE EFFECT - Creates mythical trailing sparkles (ENHANCED)
         function createMagicalSparkles(position) {
             const numSparkles = 20; // More sparkles!
             for (let i = 0; i < numSparkles; i++) {
                 setTimeout(() => {
                     const sparkleGeometry = new THREE.SphereGeometry(0.12, 8, 8); // Bigger sparkles
                     const sparkleColors = [0xffffff, 0x00ffff, 0xffff00, 0xff00ff, 0x00ff88, 0xc0c0c0];
                     const sparkleColor = sparkleColors[Math.floor(Math.random() * sparkleColors.length)];
                     const sparkleMaterial = new THREE.MeshStandardMaterial({ // Use StandardMaterial for better visibility
                         color: sparkleColor,
                         emissive: sparkleColor,
                         emissiveIntensity: 1.5,
                         transparent: true,
                         opacity: 1.0
                     });
                     const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
                     sparkle.position.copy(position);
                     sparkle.position.x += (Math.random() - 0.5) * 2.0; // Wider spread
                     sparkle.position.y += Math.random() * 2.5;
                     sparkle.position.z += (Math.random() - 0.5) * 2.0;
                     
                     sparkle.userData.velocity = new THREE.Vector3(
                         (Math.random() - 0.5) * 0.2,
                         Math.random() * 0.3 + 0.15,
                         (Math.random() - 0.5) * 0.2
                     );
                     sparkle.userData.life = 0;
                     sparkle.userData.maxLife = 80 + Math.random() * 40; // Longer life
                     sparkle.userData.rotationSpeed = (Math.random() - 0.5) * 0.4;
                     
                     scene.add(sparkle);
                     activeBursts.push(sparkle);
                 }, i * 25); // Faster staggered spawning
             }
         }
         
         // SILVER COIN EXPLOSION - Enhanced satisfying effect with combo scaling
         function createSilverCoinExplosion(position) {
             // REDUCED screen flash for regular coins - less intense to avoid feeling like shake
             const flashIntensity = Math.min(0.08 + (coinCombo * 0.02), 0.2); // Reduced intensity
             const flash = document.createElement('div');
             flash.style.cssText = `position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(255,255,255,${flashIntensity});z-index:999;pointer-events:none;animation:flashFade 0.2s ease-out forwards;`;
             document.body.appendChild(flash);
             setTimeout(() => flash.remove(), 200); // Shorter duration
             
             // OPTIMIZED: Fewer particles for better performance
             const baseParticles = 15; // Reduced from 75
             const comboBonus = Math.min(coinCombo * 2, 15); // Reduced bonus
             const numParticles = baseParticles + comboBonus;
             for (let i = 0; i < numParticles; i++) {
                 const particle = new THREE.Mesh(
                     new THREE.SphereGeometry(0.1, 4, 4), // Lower poly sphere
                     new THREE.MeshBasicMaterial({ // BasicMaterial is faster
                         color: i % 2 === 0 ? 0xffffff : 0xc0c0c0,
                         transparent: true,
                         opacity: 0.9
                     })
                 );
                 particle.position.copy(position);
                 particle.userData.velocity = new THREE.Vector3(
                     (Math.random() - 0.5) * 2,
                     Math.random() * 1.5 + 0.5,
                     (Math.random() - 0.5) * 2
                 );
                 particle.userData.life = 0;
                 particle.userData.maxLife = 40; // Shorter life
                 scene.add(particle);
                 activeBursts.push(particle);
             }
             
             // Small expanding ring
             const ringGeometry = new THREE.TorusGeometry(0.3, 0.08, 8, 24);
             const ringMaterial = new THREE.MeshBasicMaterial({
                 color: 0xffffff,
                 transparent: true,
                 opacity: 0.7
             });
             const ring = new THREE.Mesh(ringGeometry, ringMaterial);
             ring.position.copy(position);
             ring.rotation.x = Math.PI / 2;
             ring.userData.velocity = new THREE.Vector3(0, 0, 0);
             ring.userData.expandSpeed = 0.12;
             ring.userData.life = 0;
             ring.userData.maxLife = 30;
             ring.userData.isRing = true;
             scene.add(ring);
             activeBursts.push(ring);
         }
         
         // EPIC GOLD COIN COLLECTION EFFECT - 3X MORE DRAMATIC!
         function createGoldCoinExplosion(position) {
             // TRIPLE screen flash (3x effect)
             for (let f = 0; f < 3; f++) {
                 setTimeout(() => {
                     const flash = document.createElement('div');
                     flash.style.cssText = `position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(255,215,0,${0.5 - f * 0.1});z-index:999;pointer-events:none;animation:flashFade 0.6s ease-out forwards;`;
                     document.body.appendChild(flash);
                     setTimeout(() => flash.remove(), 600);
                 }, f * 100);
             }
             
             // OPTIMIZED particle burst - reduced for performance
             const numParticles = 100; // Reduced from 720 for better performance
             for (let i = 0; i < numParticles; i++) {
                 const particle = new THREE.Mesh(
                     new THREE.SphereGeometry(0.18, 8, 8), // Slightly bigger
                     new THREE.MeshStandardMaterial({
                         color: i % 3 === 0 ? 0xffd700 : i % 3 === 1 ? 0xffff00 : 0xffffff,
                         emissive: i % 3 === 0 ? 0xffd700 : i % 3 === 1 ? 0xffff00 : 0xffffff,
                         emissiveIntensity: 1.5,
                         transparent: true,
                         opacity: 1.0
                     })
                 );
                 particle.position.copy(position);
                 particle.userData.velocity = new THREE.Vector3(
                     (Math.random() - 0.5) * 6, // 3x wider spread
                     Math.random() * 4.5 + 1.5, // 3x higher
                     (Math.random() - 0.5) * 6
                 );
                 particle.userData.life = 0;
                 particle.userData.maxLife = 150; // Longer life
                 scene.add(particle);
                 activeBursts.push(particle);
             }
             
             // TRIPLE expanding rings (3x effect)
             for (let r = 0; r < 3; r++) {
                 setTimeout(() => {
                     const ringGeometry = new THREE.TorusGeometry(0.5 + r * 0.3, 0.12, 8, 32);
                     const ringMaterial = new THREE.MeshBasicMaterial({
                         color: 0xffd700,
                         transparent: true,
                         opacity: 0.9
                     });
                     const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                     ring.position.copy(position);
                     ring.rotation.x = Math.PI / 2;
                     ring.userData.velocity = new THREE.Vector3(0, 0, 0);
                     ring.userData.expandSpeed = 0.2; // Faster expansion
                     ring.userData.life = 0;
                     ring.userData.maxLife = 50;
                     ring.userData.isRing = true;
                     scene.add(ring);
                     activeBursts.push(ring);
                 }, r * 50);
             }
             
             // Additional golden sparkle burst
             for (let i = 0; i < 30; i++) {
                 setTimeout(() => {
                     const sparkleGeometry = new THREE.SphereGeometry(0.12, 8, 8);
                     const sparkleMaterial = new THREE.MeshStandardMaterial({
                         color: 0xffff00,
                         emissive: 0xffff00,
                         emissiveIntensity: 2.0,
                         transparent: true,
                         opacity: 1.0
                     });
                     const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
                     sparkle.position.copy(position);
                     sparkle.position.x += (Math.random() - 0.5) * 3;
                     sparkle.position.y += Math.random() * 3;
                     sparkle.position.z += (Math.random() - 0.5) * 3;
                     sparkle.userData.velocity = new THREE.Vector3(
                         (Math.random() - 0.5) * 0.3,
                         Math.random() * 0.4 + 0.2,
                         (Math.random() - 0.5) * 0.3
                     );
                     sparkle.userData.life = 0;
                     sparkle.userData.maxLife = 100;
                     scene.add(sparkle);
                     activeBursts.push(sparkle);
                }, i * 20);
            }
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FLOATING SCORE TEXT SYSTEM - DOPAMINE FEEDBACK
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function createFloatingScoreText(worldPosition, text, type = 'coin-1') {
            // Convert 3D world position to 2D screen position
            const vector = worldPosition.clone();
            vector.project(camera);
            
            const screenX = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const screenY = (-vector.y * 0.5 + 0.5) * window.innerHeight;
            
            // Create floating text element
            const floatingText = document.createElement('div');
            floatingText.className = `floating-score ${type}`;
            floatingText.textContent = text;
            floatingText.style.left = `${screenX}px`;
            floatingText.style.top = `${screenY}px`;
            
            // Random horizontal offset for variety
            const offsetX = (Math.random() - 0.5) * 60;
            floatingText.style.transform = `translateX(${offsetX}px)`;
            
            document.body.appendChild(floatingText);
            
            // Remove after animation completes
            setTimeout(() => {
                if (floatingText.parentNode) {
                    floatingText.remove();
                }
            }, type === 'coin-gold' ? 1500 : type === 'celebration' ? 1500 : 1200);
        }
        
        // Celebration text messages for combos
        const celebrationMessages = [
            'üî• NICE!',
            '‚ö° AWESOME!',
            'üíé EPIC!',
            'üåü AMAZING!',
            'üöÄ INSANE!',
            'üí• GODLIKE!',
            'üëë LEGENDARY!'
        ];
        
        function getCelebrationMessage(combo) {
            if (combo >= 20) return celebrationMessages[6];
            if (combo >= 15) return celebrationMessages[5];
            if (combo >= 10) return celebrationMessages[4];
            if (combo >= 7) return celebrationMessages[3];
            if (combo >= 5) return celebrationMessages[2];
            if (combo >= 3) return celebrationMessages[1];
            return celebrationMessages[0];
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PENGUIN SKIN UNLOCK FUNCTIONS (penguinSkins defined earlier)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function saveUnlockedSkins() {
            const unlockedList = Object.keys(penguinSkins).filter(id => penguinSkins[id].unlocked);
            localStorage.setItem('penchase_unlocked_skins', JSON.stringify(unlockedList));
            localStorage.setItem('penchase_selected_skin', currentPenguinSkin);
        }
        
        function checkAndUnlockSkins(currentScore) {
            let newUnlock = null;
            
            // Update highest score ever
            if (currentScore > highestScoreEver) {
                highestScoreEver = currentScore;
                localStorage.setItem('penchase_highest_score', highestScoreEver.toString());
            }
            
            // Check each skin
            Object.keys(penguinSkins).forEach(skinId => {
                const skin = penguinSkins[skinId];
                if (!skin.unlocked && highestScoreEver >= skin.unlockScore) {
                    skin.unlocked = true;
                    newUnlock = skin;
                    saveUnlockedSkins();
                }
            });
            
            // Show unlock notification if new skin unlocked
            if (newUnlock) {
                showSkinUnlockNotification(newUnlock);
            }
            
            return newUnlock;
        }
        
        function showSkinUnlockNotification(skin) {
            const notification = document.createElement('div');
            notification.className = 'skin-unlock-notification';
            notification.innerHTML = `
                <h2>üéâ NEW PENGUIN UNLOCKED! üéâ</h2>
                <p style="font-size: 1.5em; color: #ffd700; margin: 10px 0;">${skin.name}</p>
                <p>${skin.description.split(' - ')[0]}</p>
                <p style="font-size: 0.9em; color: #888; margin-top: 10px;">Press TAB ‚Üí Settings to select</p>
            `;
            document.body.appendChild(notification);
            
            // Play unlock sound
            if (typeof Tone !== 'undefined') {
                const unlockSynth = new Tone.PolySynth(Tone.Synth).toDestination();
                unlockSynth.volume.value = -5;
                const now = Tone.now();
                unlockSynth.triggerAttackRelease(['C5', 'E5', 'G5'], '8n', now);
                unlockSynth.triggerAttackRelease(['E5', 'G5', 'C6'], '8n', now + 0.15);
                unlockSynth.triggerAttackRelease(['G5', 'C6', 'E6'], '4n', now + 0.3);
            }
            
            setTimeout(() => {
                if (notification.parentNode) notification.remove();
            }, 3000);
        }
        
        function applyPenguinSkin(skinId) {
            if (!penguinSkins[skinId] || !penguinSkins[skinId].unlocked) return false;
            
            currentPenguinSkin = skinId;
            saveUnlockedSkins();
            
            // Apply skin colors to player penguin (will be applied on next game restart)
            return true;
        }
        
        // Skin loading moved to early declarations section
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PENGUIN FLIPPER ANIMATION SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        let flipperAnimationPhase = 0;
        let celebrationActive = false;
        let celebrationTimer = 0;
        let slapImpactUntil = 0; // Hold "smack" pose after colliding with competitor
        
        const FLIPPER_BASE_SCALE = { x: 0.3, y: 1.8, z: 0.6 };
        
        function animatePenguinFlippers(steerDirection, isCelebrating = false, nearestCompetitorDist = Infinity) {
            if (!playerMotorcycle || !playerMotorcycle.userData.leftFlipper) return;
            
            const leftFlipper = playerMotorcycle.userData.leftFlipper;
            const rightFlipper = playerMotorcycle.userData.rightFlipper;
            const baseRotation = playerMotorcycle.userData.flipperBaseRotationZ;
            
            if (!leftFlipper || !rightFlipper) return;
            
            // Level 50+ flying: flippers extended by 175%
            const isFlying = zeroGravityActive && currentBiome === 'northernLights';
            const flipperYScale = isFlying ? FLIPPER_BASE_SCALE.y * 1.75 : FLIPPER_BASE_SCALE.y;
            
            // SLAP COMPETITOR ‚Äî dramatically extended flaps when near/hitting AI (wind-up then smack)
            const inSlapImpact = (Date.now() < slapImpactUntil);
            const approachingCompetitor = (!inSlapImpact && nearestCompetitorDist < 2.8);
            
            if (inSlapImpact || approachingCompetitor) {
                const intensity = inSlapImpact ? 1 : Math.max(0, 1 - (nearestCompetitorDist / 2.8));
                const SLAP_EXAGGERATION = 1.45;   // +45% more exaggerated slap visual
                const slapZ = 1.25 * SLAP_EXAGGERATION * intensity;   // Flippers swing way out (smacking)
                const slapX = 0.5 * SLAP_EXAGGERATION * intensity;   // Reach forward like slapping them off
                const extendY = 1 + 0.5 * SLAP_EXAGGERATION * intensity; // Elongate flippers for bigger smack
                
                leftFlipper.rotation.z = baseRotation.left + slapZ;
                rightFlipper.rotation.z = baseRotation.right - slapZ;
                leftFlipper.rotation.x = -0.2 + slapX;
                rightFlipper.rotation.x = -0.2 + slapX;
                leftFlipper.scale.set(FLIPPER_BASE_SCALE.x, flipperYScale * extendY, FLIPPER_BASE_SCALE.z);
                rightFlipper.scale.set(FLIPPER_BASE_SCALE.x, flipperYScale * extendY, FLIPPER_BASE_SCALE.z);
                return;
            }
            
            // Reset scale when not slapping (extended 175% when flying)
            leftFlipper.scale.set(FLIPPER_BASE_SCALE.x, flipperYScale, FLIPPER_BASE_SCALE.z);
            rightFlipper.scale.set(FLIPPER_BASE_SCALE.x, flipperYScale, FLIPPER_BASE_SCALE.z);
            
            if (isCelebrating || celebrationActive) {
                // CELEBRATION ANIMATION - Flippers wave up and down excitedly!
                flipperAnimationPhase += 0.4; // Fast waving
                const waveAmount = Math.sin(flipperAnimationPhase) * 0.6;
                
                leftFlipper.rotation.z = baseRotation.left + waveAmount;
                rightFlipper.rotation.z = baseRotation.right - waveAmount;
                
                leftFlipper.rotation.x = -0.2 + Math.cos(flipperAnimationPhase * 1.5) * 0.3;
                rightFlipper.rotation.x = -0.2 + Math.cos(flipperAnimationPhase * 1.5 + Math.PI) * 0.3;
            } else if (steerDirection !== 0) {
                // STEERING ANIMATION - Flippers lean into the turn
                const steerAmount = steerDirection * 0.4;
                const targetLeft = baseRotation.left + steerAmount;
                const targetRight = baseRotation.right + steerAmount;
                
                leftFlipper.rotation.z += (targetLeft - leftFlipper.rotation.z) * 0.15;
                rightFlipper.rotation.z += (targetRight - rightFlipper.rotation.z) * 0.15;
                
                flipperAnimationPhase += 0.15;
                const bobAmount = Math.sin(flipperAnimationPhase) * 0.1;
                leftFlipper.rotation.x = -0.2 + bobAmount;
                rightFlipper.rotation.x = -0.2 - bobAmount;
            } else {
                // IDLE - Smooth return to base with subtle breathing
                flipperAnimationPhase += 0.05;
                const breathAmount = Math.sin(flipperAnimationPhase) * 0.05;
                
                leftFlipper.rotation.z += (baseRotation.left - leftFlipper.rotation.z) * 0.1;
                rightFlipper.rotation.z += (baseRotation.right - rightFlipper.rotation.z) * 0.1;
                
                leftFlipper.rotation.x = -0.2 + breathAmount;
                rightFlipper.rotation.x = -0.2 + breathAmount;
            }
        }            
            // SCARF ANIMATION - Flows in the wind based on speed
            if (playerMotorcycle.userData.scarfTail) {
                const scarfTail = playerMotorcycle.userData.scarfTail;
                const speedFactor = 1 + (currentMoveSpeed / baseMoveSpeed) * 2; // Faster flutter at higher speeds
                const time = Date.now() * 0.01 * speedFactor;

                // Flutter animation - scarf waves in the wind
                scarfTail.rotation.z = -0.3 + Math.sin(time) * 0.15;
                scarfTail.rotation.y = Math.sin(time * 0.7) * 0.1;
                scarfTail.position.x = 0.25 + Math.sin(time * 1.3) * 0.03;
            }
        
        function triggerCelebration(duration = 1000) {
            celebrationActive = true;
            celebrationTimer = setTimeout(() => {
                celebrationActive = false;
            }, duration);
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // DOPAMINE PULSE EFFECT - Penguin scales up briefly on coin collection
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        let penguinPulseActive = false;
        let penguinPulseScale = 1.0;
        let penguinPulseTarget = 1.0;
        
        function triggerPenguinPulse(combo = 1) {
            // Scale pulse based on combo (bigger pulse for higher combos!)
            const pulseAmount = Math.min(1.0 + (combo * 0.03), 1.3); // 1.0 to 1.3x scale
            penguinPulseTarget = pulseAmount;
            penguinPulseActive = true;
            
            // Return to normal after a short delay
            setTimeout(() => {
                penguinPulseTarget = 1.0;
            }, 100 + combo * 10); // Longer pulse for higher combos
        }
        
        function updatePenguinPulse() {
            if (!playerMotorcycle) return;
            
            // Smooth interpolation to target scale
            penguinPulseScale += (penguinPulseTarget - penguinPulseScale) * 0.3;
            
            // Apply scale to the visual group (not the whole motorcycle to preserve position)
            if (playerMotorcycle.userData.visualGroup) {
                playerMotorcycle.userData.visualGroup.scale.setScalar(penguinPulseScale);
            }
            
            // Deactivate when back to normal
            if (Math.abs(penguinPulseScale - 1.0) < 0.01 && penguinPulseTarget === 1.0) {
                penguinPulseActive = false;
                penguinPulseScale = 1.0;
                if (playerMotorcycle.userData.visualGroup) {
                    playerMotorcycle.userData.visualGroup.scale.setScalar(1.0);
                }
            }
        }

        // CARD PICKUP EXPLOSION - Ruby arcade burst
        function createCardPickupExplosion(position) {
            // Magenta screen flash
            const flash = document.createElement('div');
            flash.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(255,0,120,0.35);z-index:999;pointer-events:none;animation:flashFade 0.45s ease-out forwards;';
            document.body.appendChild(flash);
            setTimeout(() => flash.remove(), 450);
            
            // Particle burst
            const numParticles = 120;
            for (let i = 0; i < numParticles; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.14, 8, 8),
                    new THREE.MeshStandardMaterial({
                        color: i % 2 === 0 ? 0xff2b6d : 0xff77b7,
                        emissive: i % 2 === 0 ? 0xff2b6d : 0xff77b7,
                        emissiveIntensity: 1.4,
                        transparent: true,
                        opacity: 1.0
                    })
                );
                particle.position.copy(position);
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 4.2,
                    Math.random() * 3.2 + 0.8,
                    (Math.random() - 0.5) * 4.2
                );
                particle.userData.life = 0;
                particle.userData.maxLife = 110;
                scene.add(particle);
                activeBursts.push(particle);
            }
            
            // Expanding ring
            const ringGeometry = new THREE.TorusGeometry(0.6, 0.1, 8, 28);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0xff2b6d,
                transparent: true,
                opacity: 0.85
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.copy(position);
            ring.rotation.x = Math.PI / 2;
            ring.userData.velocity = new THREE.Vector3(0, 0, 0);
            ring.userData.expandSpeed = 0.18;
            ring.userData.life = 0;
            ring.userData.maxLife = 40;
            ring.userData.isRing = true;
            scene.add(ring);
            activeBursts.push(ring);
            
            // Ripple
            const screenRipple = document.createElement('div');
            screenRipple.style.cssText = 'position:fixed;top:50%;left:50%;width:0;height:0;border:2px solid rgba(255,0,120,0.7);border-radius:50%;transform:translate(-50%,-50%);z-index:998;pointer-events:none;animation:rippleExpand 0.8s ease-out forwards;';
            document.body.appendChild(screenRipple);
            setTimeout(() => screenRipple.remove(), 800);
        }

        function playCardPickupSound() {
            if (!cardPickupSynth || !cardImpactSynth || !epicPowerUpSynth) return;
            try {
                const now = Tone.now();
                cardPickupSynth.triggerAttackRelease(['C5', 'E5', 'G5'], '8n', now);
                cardPickupSynth.triggerAttackRelease(['D6', 'F6', 'A6'], '16n', now + 0.08);
                cardImpactSynth.triggerAttackRelease('C2', '16n', now + 0.02);
                epicPowerUpSynth.triggerAttackRelease('C4', '16n', now + 0.12);
            } catch (_) {}
        }

         // Shared explosion geometry to prevent memory leaks
         const sharedExplosionGeometry = new THREE.SphereGeometry(0.2, 8, 8);
         
         // Function to create an explosion effect
         function createExplosion(position, color = 0xff00ff) { // Default color magenta
             const numParticles = 30 + Math.floor(Math.random() * 20); // More particles for explosion

             for (let i = 0; i < numParticles; i++) {
                 const explosionMaterial = new THREE.MeshBasicMaterial({
                     color: color,
                     transparent: true,
                     opacity: 1.0
                 });
                 const particle = new THREE.Mesh(sharedExplosionGeometry, explosionMaterial);
                 particle.position.copy(position);

                 const velocity = new THREE.Vector3(
                     (Math.random() - 0.5) * 2, // Wider spread
                     (Math.random() - 0.5) * 2,
                     (Math.random() - 0.5) * 2
                 );
                 particle.userData.velocity = velocity;
                 particle.userData.life = 0;
                 particle.userData.maxLife = 45; // Longer life for explosion particles
                 particle.userData.isExplosion = true; // Mark as explosion particle for proper disposal

                 scene.add(particle);
                 activeBursts.push(particle); // Use the same array for simplicity, manage life separately
             }
             if (explosionSynth) try { explosionSynth.triggerAttackRelease("8n"); } catch (_) {}
         }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // TWISTED METAL STYLE EXPLOSION - Massive, dramatic, satisfying!
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function createTwistedMetalExplosion(position) {
            // MASSIVE particle count for epic explosion
            const numParticles = 80;
            
            // Multiple color layers for dramatic effect
            const explosionColors = [0xff4400, 0xff8800, 0xffcc00, 0xffffff, 0xff0000];
            
            for (let i = 0; i < numParticles; i++) {
                const color = explosionColors[Math.floor(Math.random() * explosionColors.length)];
                const size = 0.15 + Math.random() * 0.35; // Varied sizes
                const particleGeometry = new THREE.SphereGeometry(size, 8, 8);
                const explosionMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 1.0
                });
                const particle = new THREE.Mesh(particleGeometry, explosionMaterial);
                particle.position.copy(position);

                // Explosive outward velocity
                const speed = 0.3 + Math.random() * 0.5;
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * speed * 4,
                    Math.random() * speed * 3, // More upward
                    (Math.random() - 0.5) * speed * 4
                );
                particle.userData.velocity = velocity;
                particle.userData.life = 0;
                particle.userData.maxLife = 60; // Longer lasting
                particle.userData.isExplosion = true;

                scene.add(particle);
                activeBursts.push(particle);
            }
            
            // Add expanding shockwave ring
            const ringGeometry = new THREE.TorusGeometry(0.5, 0.1, 8, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 0.8
            });
            const shockwave = new THREE.Mesh(ringGeometry, ringMaterial);
            shockwave.position.copy(position);
            shockwave.rotation.x = Math.PI / 2;
            shockwave.userData.isShockwave = true;
            shockwave.userData.life = 0;
            shockwave.userData.maxLife = 30;
            scene.add(shockwave);
            activeBursts.push(shockwave);
            
            // Screen flash effect
            const flash = document.createElement('div');
            flash.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(255,100,0,0.5);z-index:999;pointer-events:none;';
            document.body.appendChild(flash);
            setTimeout(() => flash.remove(), 150);
        }
        
        // index3: only check Tone exists; try/catch handles suspended context
        function playTwistedMetalCrashSound() {
            if (typeof Tone === 'undefined') return;
            try {
                const boomSynth = new Tone.Synth({
                    oscillator: { type: "sine" },
                    envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.5 }
                }).toDestination();
                boomSynth.volume.value = -3;
                boomSynth.triggerAttackRelease('C1', '4n');
                const metalSynth = new Tone.MetalSynth({
                    frequency: 150,
                    envelope: { attack: 0.001, decay: 0.3, release: 0.2 },
                    harmonicity: 5.1,
                    modulationIndex: 32
                }).toDestination();
                metalSynth.volume.value = -8;
                metalSynth.triggerAttackRelease('16n');
                const crashSynth = new Tone.NoiseSynth({
                    noise: { type: "white" },
                    envelope: { attack: 0.005, decay: 0.3, sustain: 0, release: 0.3 }
                }).toDestination();
                crashSynth.volume.value = -10;
                crashSynth.triggerAttackRelease('8n');
            } catch (_) {}
        }

        // index3-style: play when Tone exists; try/catch handles suspended context
        function playColoredBearCrashSound() {
            if (typeof Tone === 'undefined') return;
            try {
                const now = Tone.now();
                const chordSynth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "sawtooth" },
                    envelope: { attack: 0.01, decay: 0.15, sustain: 0.3, release: 0.4 }
                }).toDestination();
                chordSynth.volume.value = -6;
                chordSynth.triggerAttackRelease(['E5', 'G#5', 'B5'], '8n', now);
                chordSynth.triggerAttackRelease(['E6', 'G#6'], '16n', now + 0.08);
                const hitNoise = new Tone.NoiseSynth({
                    noise: { type: "brown" },
                    envelope: { attack: 0.002, decay: 0.12, sustain: 0, release: 0.1 }
                }).toDestination();
                hitNoise.volume.value = -8;
                hitNoise.triggerAttackRelease('16n');
            } catch (_) {}
        }

         function startJump() {
             if (!isJumping) {
                 isJumping = true;
                 jumpVelocity = jumpPower;
                 // Huge wing flap animation on jump
                 if (playerMotorcycle.userData.leftFlipper && playerMotorcycle.userData.rightFlipper) {
                     const leftFlipper = playerMotorcycle.userData.leftFlipper;
                     const rightFlipper = playerMotorcycle.userData.rightFlipper;
                     const baseLeft = playerMotorcycle.userData.flipperBaseRotationZ.left;
                     const baseRight = playerMotorcycle.userData.flipperBaseRotationZ.right;
                     // Dramatic flap down
                     leftFlipper.rotation.z = baseLeft + Math.PI / 3;
                     rightFlipper.rotation.z = baseRight - Math.PI / 3;
                     // Animate back up
                     let flapFrame = 0;
                     const flapAnimation = () => {
                         flapFrame++;
                         const progress = Math.min(flapFrame / 15, 1);
                         const flapAmount = Math.PI / 3 * (1 - progress);
                         leftFlipper.rotation.z = baseLeft + flapAmount;
                         rightFlipper.rotation.z = baseRight - flapAmount;
                         if (progress < 1) {
                             requestAnimationFrame(flapAnimation);
                         } else {
                             leftFlipper.rotation.z = baseLeft;
                             rightFlipper.rotation.z = baseRight;
                         }
                     };
                     requestAnimationFrame(flapAnimation);
                 }
                 // Haptic feedback for jump
                 if (navigator.vibrate) {
                     navigator.vibrate(40);
                 }
             }
         }

         function applyJumpPhysics() {
             if (isJumping) {
                 playerMotorcycle.position.y += jumpVelocity;
                 jumpVelocity += gravity;
                 if (playerMotorcycle.position.y <= 0) {
                     playerMotorcycle.position.y = 0;
                     isJumping = false;
                     jumpVelocity = 0;
                 }
             }
         }

         function activateInvincibility() { // Old power-up, kept for compatibility if needed
             if (!isInvincible) {
                 isInvincible = true;
                 setMessage("Power-up! Invincibility activated!");
                 invincibilityTimer = setTimeout(() => {
                     isInvincible = false;
                     setMessage("Invincibility ended.");
                 }, powerUpDuration);
             }
         }

        // Pre-create reusable materials to avoid memory allocation during gameplay
        const powerUpMaterials = {
            ghost: new THREE.MeshStandardMaterial({
                color: 0xff00ff,
                emissive: 0x000000, // No glow - removed swirl/shield aura
                emissiveIntensity: 0.0,
                metalness: 0.2,
                roughness: 0.1,
                transparent: true,
                opacity: 0.5,
            }),
            radioactiveBody: new THREE.MeshStandardMaterial({
                color: 0x000000, // Changed from white to black - no visible wrap
                metalness: 0.1,
                roughness: 0.2,
                emissive: 0x000000, // No glow - removed wrap/shield effect
                emissiveIntensity: 0.0
            }),
            radioactiveHead: new THREE.MeshStandardMaterial({
                color: 0x000000, // Changed from white to black - no visible wrap
                metalness: 0.1,
                roughness: 0.1,
                emissive: 0x000000, // No glow - removed wrap/shield effect
                emissiveIntensity: 0.0
            })
        };

        // Optimize score display to batch updates
        let scoreUpdatePending = false;
        function updateScoreDisplay() {
            if (scoreUpdatePending) return;
            scoreUpdatePending = true;
            requestAnimationFrame(() => {
                scoreDisplay.textContent = 'Coins: ' + score;
                scoreUpdatePending = false;
            });
        }

        function activateRandomPowerUp() {
            const availablePowerUps = Object.keys(powerUpTypes);
            const instantUsePowerUps = ['projectile', 'obstacleDrop', 'swapPosition'];
            const currentlyHeldInstant = instantUsePowerUps.some(type => {
                if (type === 'projectile' && hasProjectile) return true;
                if (type === 'obstacleDrop' && hasObstacleDrop) return true;
                if (type === 'swapPosition' && hasSwapPosition) return true;
                return false;
            });

            let powerUpPool = availablePowerUps;
            if (currentlyHeldInstant) {
                 powerUpPool = availablePowerUps.filter(type => !instantUsePowerUps.includes(type));
                 if (powerUpPool.length === 0) {
                     score += 50;
                     updateScoreDisplay();
                     setMessage("Item Box: Small Popn Bonus!");
                     itemBoxSynth.triggerAttackRelease('C6', '16n');
                     return;
                 }
            }

            const randomTypeIndex = Math.floor(Math.random() * powerUpPool.length);
            const randomType = powerUpPool[randomTypeIndex];
            const powerUpInfo = powerUpTypes[randomType];
            itemBoxSynth.triggerAttackRelease('C5', '16n', Tone.now(), 0.8);

            if (randomType === 'ghost') {
                 if (!isGhostActive) {
                     isGhostActive = true;
                     isInvincible = true; // Set invincibility during ghost mode
                     setMessage(powerUpInfo.message);
                     shieldSynth.triggerAttackRelease('F#5', '8n');

                     // Use pre-created materials instead of creating new ones
                     if (playerRiderBody && playerRiderHead) {
                         originalRiderMaterials.body = playerRiderBody.material;
                         originalRiderMaterials.head = playerRiderHead.material;
                         
                         playerRiderBody.material = powerUpMaterials.ghost;
                         playerRiderHead.material = powerUpMaterials.ghost;
                     }

                     ghostTimer = setTimeout(() => {
                         isGhostActive = false;
                         isInvincible = false; // Remove invincibility when ghost mode ends
                         setMessage("Ghost Mode faded.");
                         if (playerRiderBody && originalRiderMaterials.body) {
                            playerRiderBody.material = originalRiderMaterials.body;
                         }
                         if (playerRiderHead && originalRiderMaterials.head) {
                            playerRiderHead.material = originalRiderMaterials.head;
                         }
                     }, powerUpInfo.duration);
                 } else {
                      setMessage("Ghost Mode duration extended!");
                      isInvincible = true; // Maintain invincibility when extending
                      clearTimeout(ghostTimer);
                       ghostTimer = setTimeout(() => {
                          isGhostActive = false;
                          isInvincible = false; // Remove invincibility when ghost mode ends
                          setMessage("Ghost Mode faded.");
                          if (playerRiderBody && originalRiderMaterials.body) {
                             playerRiderBody.material = originalRiderMaterials.body;
                          }
                          if (playerRiderHead && originalRiderMaterials.head) {
                             playerRiderHead.material = originalRiderMaterials.head;
                          }
                       }, powerUpInfo.duration);
                 }
            } else if (randomType === 'magnet') {
                 if (!isMagnetActive) {
                     isMagnetActive = true;
                     isInvincible = true; // Set invincibility during magnet/clock mode
                     setMessage(powerUpInfo.message);
                     magnetSynth.triggerAttackRelease('G5', '8n');
                     
                     // Use pre-created materials
                     if (playerRiderBody && playerRiderHead) {
                         originalRiderMaterials.body = playerRiderBody.material;
                         originalRiderMaterials.head = playerRiderHead.material;
                         
                         playerRiderBody.material = powerUpMaterials.radioactiveBody;
                         playerRiderHead.material = powerUpMaterials.radioactiveHead;
                     }
                     
                     magnetTimer = setTimeout(() => {
                         isMagnetActive = false;
                         isInvincible = false; // Remove invincibility when magnet mode ends
                         setMessage("Radioactive mode deactivated.");
                         // CRITICAL: Reset materials and ensure emissive is 0
                         if (playerRiderBody && originalRiderMaterials.body) {
                            playerRiderBody.material = originalRiderMaterials.body;
                            if (playerRiderBody.material) {
                                playerRiderBody.material.emissiveIntensity = 0.0;
                                if (playerRiderBody.material.emissive) {
                                    playerRiderBody.material.emissive.setHex(0x000000);
                                }
                            }
                         }
                         if (playerRiderHead && originalRiderMaterials.head) {
                            playerRiderHead.material = originalRiderMaterials.head;
                            if (playerRiderHead.material) {
                                playerRiderHead.material.emissiveIntensity = 0.0;
                                if (playerRiderHead.material.emissive) {
                                    playerRiderHead.material.emissive.setHex(0x000000);
                                }
                            }
                         }
                       }, powerUpInfo.duration);
                 } else {
                      setMessage("Radioactive mode duration extended!");
                      isInvincible = true; // Maintain invincibility when extending
                       clearTimeout(magnetTimer);
                       magnetTimer = setTimeout(() => {
                           isMagnetActive = false;
                           isInvincible = false; // Remove invincibility when magnet mode ends
                           setMessage("Radioactive mode deactivated.");
                           // CRITICAL: Reset materials and ensure emissive is 0
                           if (playerRiderBody && originalRiderMaterials.body) {
                              playerRiderBody.material = originalRiderMaterials.body;
                              if (playerRiderBody.material) {
                                  playerRiderBody.material.emissiveIntensity = 0.0;
                                  if (playerRiderBody.material.emissive) {
                                      playerRiderBody.material.emissive.setHex(0x000000);
                                  }
                              }
                           }
                           if (playerRiderHead && originalRiderMaterials.head) {
                              playerRiderHead.material = originalRiderMaterials.head;
                              if (playerRiderHead.material) {
                                  playerRiderHead.material.emissiveIntensity = 0.0;
                                  if (playerRiderHead.material.emissive) {
                                      playerRiderHead.material.emissive.setHex(0x000000);
                                  }
                              }
                           }
                       }, powerUpInfo.duration);
                 }
            } else if (randomType === 'slowTime') {
                 if (!isSlowTimeActive) {
                     isSlowTimeActive = true;
                     isInvincible = true; // Set invincibility during slow time
                     setMessage(powerUpInfo.message);
                     slowTimeSynth.triggerAttackRelease('C6', '8n');
                     slowTimeTimer = setTimeout(() => {
                         isSlowTimeActive = false;
                         isInvincible = false; // Remove invincibility when slow time ends
                         setMessage("Time returned to normal.");
                     }, powerUpInfo.duration);
                 } else {
                      setMessage("Slow Time duration extended!");
                      isInvincible = true; // Maintain invincibility when extending
                       clearTimeout(slowTimeTimer);
                       slowTimeTimer = setTimeout(() => {
                           isSlowTimeActive = false;
                           isInvincible = false; // Remove invincibility when slow time ends
                           setMessage("Time returned to normal.");
                       }, powerUpInfo.duration);
                 }
            } else if (randomType === 'speedBoost') {
                 // CRITICAL: Ensure magnet/radioactive materials are NOT applied for speed boost
                 // Force reset any active magnet materials to prevent permanent wrap/shield
                 if (isMagnetActive) {
                     isMagnetActive = false;
                     if (magnetTimer) clearTimeout(magnetTimer);
                     if (playerRiderBody && originalRiderMaterials.body) {
                         playerRiderBody.material = originalRiderMaterials.body;
                         if (playerRiderBody.material) {
                             playerRiderBody.material.emissiveIntensity = 0.0;
                             if (playerRiderBody.material.emissive) {
                                 playerRiderBody.material.emissive.setHex(0x000000);
                             }
                         }
                     }
                     if (playerRiderHead && originalRiderMaterials.head) {
                         playerRiderHead.material = originalRiderMaterials.head;
                         if (playerRiderHead.material) {
                             playerRiderHead.material.emissiveIntensity = 0.0;
                             if (playerRiderHead.material.emissive) {
                                 playerRiderHead.material.emissive.setHex(0x000000);
                             }
                         }
                     }
                 }
                 
                 if (!isBoosting) {
                     isInvincible = true; // Set invincibility during speed boost powerup
                     activateBoost(powerUpInfo.duration);
                     setMessage(powerUpInfo.message);
                     // Remove invincibility when boost ends
                     setTimeout(() => {
                         isInvincible = false;
                     }, powerUpInfo.duration);
                 } else {
                      score += 20;
                      updateScoreDisplay();
                      setMessage("Item Box: Small Popn Bonus!");
                      itemBoxSynth.triggerAttackRelease('C6', '16n');
                 }
            } else if (randomType === 'projectile') {
                                 if (!hasProjectile) {
                    hasProjectile = true;
                    setMessage(powerUpInfo.message + (isMobileDevice() ? " Tap Power-up button." : " Press 'E' to use."));
                    forceSynth.triggerAttackRelease('G5', '8n');
                    updateMobileControlVisibility();
                 } else {
                      score += 20;
                      updateScoreDisplay();
                      setMessage("Item Box: Small Popn Bonus!");
                      itemBoxSynth.triggerAttackRelease('C6', '16n');
                 }
            } else if (randomType === 'obstacleDrop') {
                                 if (!hasObstacleDrop) {
                    hasObstacleDrop = true;
                    setMessage(powerUpInfo.message + (isMobileDevice() ? " Tap Power-up button." : " Press 'E' to use."));
                    powerUpActivateSynth.triggerAttackRelease('C7', '8n');
                    updateMobileControlVisibility();
                 } else {
                      score += 20;
                      updateScoreDisplay();
                      setMessage("Item Box: Small Popn Bonus!");
                      itemBoxSynth.triggerAttackRelease('C6', '16n');
                 }
            } else if (randomType === 'swapPosition') {
                 if (!hasSwapPosition) {
                     hasSwapPosition = true;
                     setMessage(powerUpInfo.message + (isMobileDevice() ? " Tap Power-up button." : " Press 'E' to use."));
                     powerUpActivateSynth.triggerAttackRelease('E7', '8n');
                 } else {
                      score += 20;
                      updateScoreDisplay();
                      setMessage("Item Box: Small Popn Bonus!");
                      itemBoxSynth.triggerAttackRelease('C6', '16n');
                 }
            }
            updatePowerUpDisplay();
        }

        function usePowerUp() {
            if (!isGameRunning || isGameOver || gamePaused) return;
            if (hasProjectile) {
                hasProjectile = false;
                setMessage("CYPHES resistance systems activated!");
                projectileSynth.triggerAttackRelease('A4', '16n', Tone.now(), 1.0);
                fireProjectile();
                animatePowerUpDisplay('use');
                trackPowerUpUsed(); // Track power-up usage
                updateMobileControlVisibility();
            } else if (hasObstacleDrop) {
                hasObstacleDrop = false;
                setMessage("Deploying Krypton!");
                powerUpActivateSynth.triggerAttackRelease('F4', '16n');
                dropObstacle();
                animatePowerUpDisplay('use');
                trackPowerUpUsed(); // Track power-up usage
                updateMobileControlVisibility();
            } else if (hasSwapPosition) {
                hasSwapPosition = false;
                setMessage("DISCO teleportation activated!");
                powerUpActivateSynth.triggerAttackRelease('D4', '16n');
                swapPositions();
                animatePowerUpDisplay('use');
                trackPowerUpUsed(); // Track power-up usage
            } else {
                setMessage("No DISCO power available!");
                animatePowerUpDisplay('use');
            }
            updatePowerUpDisplay();
        }

        function fireProjectile() {
            // DRAMATIC DISCO LAUNCH with enhanced effects
            const projectileGroup = createPowerUp('projectile'); // Create the dramatic projectile group
            projectileGroup.position.copy(playerMotorcycle.position);
            projectileGroup.position.y += 1.0; // Launch from rider position
            projectileGroup.rotation.copy(playerMotorcycle.rotation);
            const forward = new THREE.Vector3(0, 0, -1); // Shoot forward (negative Z)
            projectileGroup.userData.direction = forward;
            projectileGroup.userData.speed = projectileSpeed * 1.5; // Faster for dramatic effect
            scene.add(projectileGroup);
            activeProjectiles.push(projectileGroup);
            totalDiscoProjectiles++; // Track for leaderboard
            
            // DEBUG: Log projectile creation
            console.log("DISCO fired!", {
                position: projectileGroup.position.clone(),
                direction: projectileGroup.userData.direction,
                speed: projectileGroup.userData.speed,
                children: projectileGroup.children.length
            });
            
            // DRAMATIC MUZZLE FLASH EFFECT
            createMuzzleFlash(playerMotorcycle.position.clone());
            
            // SCREEN FLASH EFFECT for DISCO launch
            const launchFlash = document.createElement('div');
            launchFlash.style.position = 'fixed';
            launchFlash.style.top = '0';
            launchFlash.style.left = '0';
            launchFlash.style.width = '100%';
            launchFlash.style.height = '100%';
            launchFlash.style.backgroundColor = 'rgba(0, 255, 255, 0.4)';
            launchFlash.style.pointerEvents = 'none';
            launchFlash.style.zIndex = '1000';
            document.body.appendChild(launchFlash);
            setTimeout(() => {
                if (launchFlash.parentNode) launchFlash.parentNode.removeChild(launchFlash);
            }, 150); // Cyan flash for 150ms
            
            // Enhanced camera shake for DISCO launch
            triggerCameraShake(0.8, 300); // Strong shake for 300ms
        }
        
        // Create dramatic muzzle flash for DISCO launch
        function createMuzzleFlash(position) {
            const flashGroup = new THREE.Group();
            
            // Main flash burst
            const flashGeometry = new THREE.SphereGeometry(2.0, 16, 16);
            const flashMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 8.0,
                metalness: 0,
                roughness: 1,
                transparent: true,
                opacity: 0.9
            });
            const flash = new THREE.Mesh(flashGeometry, flashMaterial);
            flashGroup.add(flash);
            
            // Energy ring bursts
            for (let i = 0; i < 5; i++) {
                const ringGeometry = new THREE.RingGeometry(0.5 + i * 0.3, 1.0 + i * 0.3, 12);
                const ringMaterial = new THREE.MeshStandardMaterial({
                    color: 0x00ffff,
                    emissive: 0x00ffff,
                    emissiveIntensity: 6.0 - i * 1.0,
                    metalness: 0,
                    roughness: 1,
                    transparent: true,
                    opacity: 0.8 - i * 0.15,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.random() * Math.PI;
                ring.rotation.y = Math.random() * Math.PI;
                flashGroup.add(ring);
            }
            
            flashGroup.position.copy(position);
            flashGroup.position.y += 1.0;
            scene.add(flashGroup);
            
            // Animate muzzle flash (fade out quickly)
            let flashLife = 0;
            const flashDuration = 20; // Very short duration for muzzle flash
            const flashInterval = setInterval(() => {
                flashLife++;
                const progress = flashLife / flashDuration;
                const scale = 1.0 + progress * 2.0; // Expand rapidly
                const opacity = 1.0 - progress; // Fade out
                
                flashGroup.scale.setScalar(scale);
                flashGroup.children.forEach(child => {
                    if (child.material) {
                        child.material.opacity = opacity * (child.material.opacity > 0.5 ? 0.9 : child.material.opacity);
                    }
                });
                
                if (progress >= 1.0) {
                    scene.remove(flashGroup);
                    clearInterval(flashInterval);
                    // Dispose materials
                    flashGroup.children.forEach(child => {
                        if (child.material) child.material.dispose();
                        if (child.geometry) child.geometry.dispose();
                    });
                }
                         }, 16); // 60fps animation
        }
        
        // Create MASSIVE dramatic explosion for DISCO impacts
        function createTSphereImpactExplosion(position) {
            // SCREEN SHAKE for impact
            triggerCameraShake(1.5, 500); // Very strong shake for 500ms
            
            // IMPACT SCREEN FLASH
            const impactFlash = document.createElement('div');
            impactFlash.style.position = 'fixed';
            impactFlash.style.top = '0';
            impactFlash.style.left = '0';
            impactFlash.style.width = '100%';
            impactFlash.style.height = '100%';
            impactFlash.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
            impactFlash.style.pointerEvents = 'none';
            impactFlash.style.zIndex = '1000';
            document.body.appendChild(impactFlash);
            setTimeout(() => {
                if (impactFlash.parentNode) impactFlash.parentNode.removeChild(impactFlash);
            }, 200); // Bright white flash
            
            const explosionGroup = new THREE.Group();
            
            // MASSIVE CORE EXPLOSION
            const coreGeometry = new THREE.SphereGeometry(4.0, 20, 20);
            const coreMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                emissive: 0xff0000,
                emissiveIntensity: 10.0,
                metalness: 0,
                roughness: 1,
                transparent: true,
                opacity: 1.0
            });
            const coreExplosion = new THREE.Mesh(coreGeometry, coreMaterial);
            explosionGroup.add(coreExplosion);
            
            // MULTIPLE ENERGY SHOCKWAVE RINGS
            for (let i = 0; i < 8; i++) {
                const ringGeometry = new THREE.RingGeometry(1.0 + i * 0.5, 2.0 + i * 0.5, 16);
                const ringMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 8.0 - i * 0.8,
                    metalness: 0,
                    roughness: 1,
                    transparent: true,
                    opacity: 0.9 - i * 0.1,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.random() * Math.PI;
                ring.rotation.y = Math.random() * Math.PI;
                ring.rotation.z = Math.random() * Math.PI;
                explosionGroup.add(ring);
            }
            
            // DEBRIS PARTICLES
            for (let i = 0; i < 20; i++) {
                const debrisGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const debrisMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff4400,
                    emissive: 0xff0000,
                    emissiveIntensity: 3.0,
                    metalness: 0,
                    roughness: 1
                });
                const debris = new THREE.Mesh(debrisGeometry, debrisMaterial);
                debris.position.set(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
                debris.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    (Math.random() - 0.5) * 0.3,
                    (Math.random() - 0.5) * 0.3
                );
                explosionGroup.add(debris);
            }
            
            explosionGroup.position.copy(position);
            scene.add(explosionGroup);
            
            // DRAMATIC EXPLOSION ANIMATION
            let explosionLife = 0;
            const explosionDuration = 60; // Longer duration for dramatic effect
            const explosionInterval = setInterval(() => {
                explosionLife++;
                const progress = explosionLife / explosionDuration;
                
                // Core explosion effects
                const scale = 1.0 + progress * 5.0; // Massive expansion
                const coreOpacity = 1.0 - Math.pow(progress, 0.5); // Slower fade
                
                coreExplosion.scale.setScalar(scale);
                coreExplosion.material.opacity = coreOpacity;
                
                // Shockwave rings expand at different rates
                explosionGroup.children.forEach((child, index) => {
                    if (index > 0 && index <= 8) { // Rings
                        const ringScale = 1.0 + progress * (3.0 + index * 0.5);
                        child.scale.setScalar(ringScale);
                        child.material.opacity = (0.9 - index * 0.1) * (1.0 - progress);
                        child.rotation.z += 0.02 * (index + 1); // Rotating rings
                    } else if (index > 8) { // Debris
                        child.position.add(child.userData.velocity);
                        child.userData.velocity.multiplyScalar(0.98); // Debris slowdown
                        child.rotation.x += 0.1;
                        child.rotation.y += 0.1;
                        child.material.opacity = 1.0 - progress;
                    }
                });
                
                if (progress >= 1.0) {
                    scene.remove(explosionGroup);
                    clearInterval(explosionInterval);
                    // Dispose materials and geometries
                    explosionGroup.children.forEach(child => {
                        if (child.material) child.material.dispose();
                        if (child.geometry) child.geometry.dispose();
                    });
                }
            }, 16); // 60fps animation
        }

        function dropObstacle() {
            const obstacle = createObstacle();
            obstacle.userData.isPlayerObstacle = true; // Mark as player-dropped
            const dropPosition = playerMotorcycle.position.clone();
            dropPosition.z -= 10; // Place in front of player (negative Z)
            obstacle.position.copy(dropPosition);
            scene.add(obstacle);
            obstacles.push(obstacle);
            setTimeout(() => {
                 scene.remove(obstacle);
                 disposeObject(obstacle);
                 const index = obstacles.indexOf(obstacle);
                 if (index !== -1) obstacles.splice(index, 1);
            }, 8000);
        }

        function swapPositions() {
            // Find the leading AI competitor (smallest Z position)
            let leadingAI = null;
            let furthestZ = Infinity;

            aiMotorcycles.forEach(aiBike => {
                 // Check if the AI is visible and is ahead of the player
                 if (aiBike.visible && aiBike.position.z < playerMotorcycle.position.z) {
                     if (aiBike.position.z < furthestZ) {
                         furthestZ = aiBike.position.z;
                         leadingAI = aiBike;
                     }
                 }
            });

            if (leadingAI) {
                 const playerPos = playerMotorcycle.position.clone();
                 const aiPos = leadingAI.position.clone();

                 // Perform the swap
                 playerMotorcycle.position.copy(aiPos);
                 leadingAI.position.copy(playerPos);

                 // Temporarily disable AI movement after swap
                 leadingAI.userData.canMove = false;
                 setTimeout(() => {
                     leadingAI.userData.canMove = true;
                 }, 500); // AI movement re-enabled after 500ms

                 setMessage(`Swapped positions with the leading AI!`);
            } else {
                 setMessage("No leading AI competitor found to swap with!");
            }
        }


         function updatePowerUpDisplay() {
             const activeStatus = [];
             let hasInstantUsePowerUp = false;
             if (isGhostActive) activeStatus.push("Ghost");
             if (isMagnetActive) activeStatus.push("Radioactive");
             if (isSlowTimeActive) activeStatus.push("Slow Time");
             if (hasProjectile) { activeStatus.push("DISCO!"); hasInstantUsePowerUp = true; }
             if (hasObstacleDrop) { activeStatus.push("Kyrpton!"); hasInstantUsePowerUp = true; }
             if (hasSwapPosition) { activeStatus.push("Swap Position!"); hasInstantUsePowerUp = true; }

             if (activeStatus.length > 0) {
                 powerUpDisplay.textContent = "P-UP: " + activeStatus.join(" | ");
                 powerUpDisplay.style.display = 'block';
             } else {
                 powerUpDisplay.textContent = "";
                 powerUpDisplay.style.display = 'none';
             }
             if (isMobileDevice() && gameMode === 'manual' && hasInstantUsePowerUp && isGameRunning && !isGameOver && !gamePaused) {
                 usePowerUpButtonMobile.style.display = 'flex';
             } else {
                 usePowerUpButtonMobile.style.display = 'none';
             }
         }


        function animate() {
            window.animationFrameId = requestAnimationFrame(animate);
            
            if (isGameOver || !isGameRunning || gamePaused) {
                // Debug logging for early return
                // Debug logging removed for performance
                
                renderer.render(scene, camera);
                return;
            }
            
            // FPS counter
            fpsFrameCount++;
            const currentTime = performance.now();
            if (currentTime - fpsLastTime >= 1000) { // Update every second
                currentFPS = Math.round((fpsFrameCount * 1000) / (currentTime - fpsLastTime));
                fpsFrameCount = 0;
                fpsLastTime = currentTime;
                
                // FPS display removed from mission stats
                // const fpsElement = document.getElementById('stat-fps');
                // if (fpsElement) {
                //     fpsElement.textContent = `${currentFPS} FPS`;
                // }
            }

            // Ghost mode visual effects removed - no swirl/shield aura
            // Ghost mode still provides collision immunity but no visual effects

            // Update infinite city generation
            updateInfiniteCity();
            
            // Update permanent mountains to follow player
            updatePermanentMountains();
            
            // Update infinite road generation
            updateInfiniteRoad();
            
            // Animate neon lights for Times Square effect
            animateNeonLights();
            
            // BIOME EFFECTS: Aurora for Northern Lights (throttled ‚Äî was 10%/frame ‚âà6/sec, caused crawl)
            if (currentBiome === 'northernLights') {
                const now = Date.now();
                if (Math.random() < 0.02 && (!window._lastAuroraTime || now - window._lastAuroraTime > 800)) {
                    window._lastAuroraTime = now;
                    const auroraParticle = new THREE.Mesh(
                        new THREE.PlaneGeometry(50, 5, 1, 1),
                        new THREE.MeshBasicMaterial({
                            color: Math.random() > 0.5 ? 0x00ff88 : 0xff00ff, // Green or pink
                            transparent: true,
                            opacity: 0.3,
                            side: THREE.DoubleSide
                        })
                    );
                    auroraParticle.position.set(
                        (Math.random() - 0.5) * 100,
                        30 + Math.random() * 20,
                        playerMotorcycle.position.z - 100 - Math.random() * 200
                    );
                    auroraParticle.rotation.x = Math.PI / 2;
                    scene.add(auroraParticle);
                    setTimeout(() => {
                        scene.remove(auroraParticle);
                        auroraParticle.material.dispose();
                        auroraParticle.geometry.dispose();
                    }, 5000);
                }
            }
            
            // Memory check (internally throttled to ~every 300 frames)
            monitorMemoryLeaks();
            
            // Show leaderboard comparison messages periodically
            if (score > 0 && getAdjustedTime() - lastLeaderboardCheck > 15000) { // Every 15 seconds
                const comparisonMessage = leaderboard.getComparisonMessage(score);
                if (comparisonMessage) {
                    setMessage(comparisonMessage);
                    lastLeaderboardCheck = getAdjustedTime();
                }
            }

            // Snow ball obstacles (no fuse animation)

            // Engine glow removed - no shield/aura effect

            // Speed increase logic - only increase base speed up to SPEED_INCREASE_LIMIT_LEVEL
            if (level <= SPEED_INCREASE_LIMIT_LEVEL) {
                 moveSpeed = Math.min(baseMoveSpeed + (score * speedIncreaseRate), maxMoveSpeed);
            } else {
                 // Maintain max speed once limit level is reached
                 moveSpeed = maxMoveSpeed;
            }

            // Smooth speed calculation
            let targetSpeed = moveSpeed;
            if (isBoosting) targetSpeed *= 3;
            if (isMiniBoostActive) targetSpeed *= 1.25; // 25% speed increase
            if (isSlowTimeActive) targetSpeed *= slowTimeFactor;
            
            // Smooth speed transitions instead of instant changes
            currentMoveSpeed += (targetSpeed - currentMoveSpeed) * 0.2; // Smooth acceleration/deceleration
            
            // NEW: Trigger hyperspace effect when reaching max speed
            if (typeof currentMoveSpeed !== 'undefined' && currentMoveSpeed >= maxMoveSpeed && !hyperspaceActive) {
                triggerHyperspaceEffect();
                trackHyperspaceJump(); // Track hyperspace jumps
            }

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // SILKY SMOOTH MOTORCYCLE MOVEMENT SYSTEM - Fluid & Natural
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            if (agentController.isAgentMode) {
                agentController.clearFrameInput();
                visualizeAgentBrain(agentController);
            }
            let playerSteer = getPlayerManualSteerDirection();
            
            // Smooth input response - silky feel
            lastSteerInput += (playerSteer - lastSteerInput) * inputSmoothing; // Smooth input transition
            
            // Gentle momentum buildup for natural feel
            if (playerSteer !== 0) {
                steerMomentum += playerSteer * 0.008; // Slower, smoother acceleration
                steerMomentum = Math.max(-maxMomentum, Math.min(maxMomentum, steerMomentum)); // Controlled cap
            }
            
            // Smooth momentum decay - natural deceleration
            steerMomentum *= momentumDecay;
            
            // Smooth steering with subtle momentum
            targetSteerAngle = (lastSteerInput * maxSteerAngle) + (steerMomentum * maxSteerAngle * 0.4);
            
            // Silky smooth angle interpolation
            currentSteerAngle += (targetSteerAngle - currentSteerAngle) * steerInterpolationSpeed;
            
            // Smooth dynamic tilt based on speed and direction
            const tiltFactor = 1.0 + (currentMoveSpeed / baseMoveSpeed) * 0.2;
            const targetRotationY = currentSteerAngle * tiltFactor;
            const targetRotationZ = -currentSteerAngle * 0.15 * tiltFactor; // Smooth lean
            
            // Smooth rotation interpolation
            playerMotorcycle.rotation.y += (targetRotationY - playerMotorcycle.rotation.y) * 0.1;
            playerMotorcycle.rotation.z += (targetRotationZ - playerMotorcycle.rotation.z) * 0.1;
            
            // SILKY SMOOTH lateral movement - natural motorcycle feel
            const lateralSpeed = steerSpeed * 1.2; // Moderate lateral speed
            const targetLateralVelocity = (Math.sin(currentSteerAngle) * 0.4 + steerMomentum * 0.3) * lateralSpeed;
            lateralVelocity += (targetLateralVelocity - lateralVelocity) * 0.12; // Smooth pickup
            lateralVelocity *= lateralDamping; // Smooth deceleration
            
            // BIOME EFFECTS: Wind push (blizzard) and zero gravity (northern lights)
            if (currentBiome === 'blizzard' && windPush !== 0) {
                // Wind pushes player sideways randomly
                const windDirection = Math.sin(Date.now() * 0.001) * windPush;
                playerMotorcycle.position.x += windDirection;
            }
            
            if (currentBiome === 'northernLights' && zeroGravityActive) {
                // Zero gravity: player floats up slightly
                if (playerMotorcycle.position.y < 2.0) {
                    playerMotorcycle.position.y += 0.02;
                }
            }
            
            // Apply movement
            playerMotorcycle.position.x += lateralVelocity;

            // Soft edge handling - no jarring stops
            const motorcycleX = playerMotorcycle.position.x;
            const edgeSoftness = 0.5; // Soft edge buffer
            if (motorcycleX < -roadEdgeThreshold + edgeSoftness) {
                const pushBack = (-roadEdgeThreshold + edgeSoftness - motorcycleX) * 0.3;
                playerMotorcycle.position.x += pushBack;
                lateralVelocity *= 0.7;
            } else if (motorcycleX > roadEdgeThreshold - edgeSoftness) {
                const pushBack = (roadEdgeThreshold - edgeSoftness - motorcycleX) * 0.3;
                playerMotorcycle.position.x += pushBack;
                lateralVelocity *= 0.7;
            }
            
            // Clamp to absolute edge
            playerMotorcycle.position.x = Math.max(-roadEdgeThreshold, Math.min(roadEdgeThreshold, playerMotorcycle.position.x));

            // Smooth reset when not steering
            if (Math.abs(playerSteer) < 0.1) {
                steerMomentum *= 0.98; // Slower reset
                lateralVelocity *= 0.97; // Smooth deceleration
            }
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // PENGUIN FLIPPER ANIMATION - Adds life to the character!
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            let nearestCompetitorDist = Infinity;
            for (let ii = 0; ii < aiMotorcycles.length; ii++) {
                const d = playerMotorcycle.position.distanceTo(aiMotorcycles[ii].position);
                if (d < nearestCompetitorDist) nearestCompetitorDist = d;
            }
            animatePenguinFlippers(playerSteer, celebrationActive, nearestCompetitorDist);
            
            // DOPAMINE PULSE - Update penguin scale effect
            updatePenguinPulse();

            checkAgentJump();
            checkAgentBoost();
            checkAgentPowerUp();
            applyJumpPhysics();
            
            // Smooth forward speed interpolation for silky movement
            targetMoveSpeed = currentMoveSpeed;
            smoothedMoveSpeed += (targetMoveSpeed - smoothedMoveSpeed) * 0.15; // Smooth speed transitions
            playerMotorcycle.translateZ(-smoothedMoveSpeed);

            aiMotorcycles.forEach(aiBike => {
                 aiBike.userData.moveSpeed = baseMoveSpeed * (0.85 + Math.random() * 0.2); // AI bikes slightly slower than player for competitive racing
                 automateAIMotorcycle(aiBike);
            });

             if (level >= 2) {
                 for (let i = batGangs.length - 1; i >= 0; i--) {
                     const batGang = batGangs[i];
                     moveBatGang(batGang);
                     if (batGang.position.z > playerMotorcycle.position.z + 20) {
                         scene.remove(batGang);
                         disposeObject(batGang);
                         batGangs.splice(i, 1);
                     }
                 }
                 const currentBatGangSpawnRate = batGangSpawnRate / (level - 1);
                 if (batGangs.length < maxBatGangs && Math.random() < 1 / currentBatGangSpawnRate) {
                     const batLanes = [-4, 0, 4];
                     const laneX = batLanes[Math.floor(Math.random() * batLanes.length)] + (Math.random() - 0.5) * 1.5;
                     const randomZ = playerMotorcycle.position.z - 120 - Math.random() * 180; // Different Z band
                     const batGang = createBatGang();
                     batGang.position.set(laneX, 2, randomZ);
                     scene.add(batGang);
                     batGangs.push(batGang);
                 }
             }

            // BAT ALLEY SYSTEM (Levels 65-70) - 2 bats per level, spread on road
            if (level >= 65 && level <= 70) {
                const requiredBats = 2;
                if (batAlleyBats.length < requiredBats) {
                    const alleyLanes = [-4, 0, 4];
                    const laneX = alleyLanes[Math.floor(Math.random() * alleyLanes.length)] + (Math.random() - 0.5) * 1.5;
                    const randomZ = playerMotorcycle.position.z - 100 - Math.random() * 120;
                    const alleyBat = createAlleyBat();
                    alleyBat.position.set(laneX, 2, randomZ);
                    scene.add(alleyBat);
                    batAlleyBats.push(alleyBat);
                    
                    if (batAlleyBats.length === 1) {
                        setMessage(`ü¶á BAT ALLEY LEVEL ${level}! DODGE 2 BATS!`);
                    }
                }
                
                // Move alley bats
                batAlleyBats.forEach(bat => moveAlleyBat(bat));
            }

            // BOWLING BALL ALLEY SYSTEM (Levels 75-80) - 2 balls per level, spread on road
            if (level >= 75 && level <= 80) {
                const requiredBalls = 2;
                if (bowlingBallAlleyBalls.length < requiredBalls) {
                    const ballAlleyLanes = [-4, 0, 4];
                    const laneX = ballAlleyLanes[Math.floor(Math.random() * ballAlleyLanes.length)] + (Math.random() - 0.5) * 1.5;
                    const randomZ = playerMotorcycle.position.z - 90 - Math.random() * 130;
                    const alleyBall = createAlleyBowlingBall();
                    alleyBall.position.set(laneX, 1.0, randomZ);
                    scene.add(alleyBall);
                    bowlingBallAlleyBalls.push(alleyBall);
                    
                    if (bowlingBallAlleyBalls.length === 1) {
                        setMessage(`üé≥ BOWLING BALL ALLEY LEVEL ${level}! DODGE 2 BALLS!`);
                    }
                }
                
                // Move alley bowling balls
                bowlingBallAlleyBalls.forEach(ball => moveAlleyBowlingBall(ball));
            }

            // FINAL BAT SYSTEM (Level 85) - Special attack bat
            if (level === 85) {
                if (finalBats.length === 0) {
                    const finalBat = createFinalBat();
                    finalBat.position.set(0, 4, playerMotorcycle.position.z - 60);
                    scene.add(finalBat);
                    finalBats.push(finalBat);
                    setMessage("üíÄ FINAL BAT INCOMING! ONLY DISCO POWER CAN DEFEAT IT!");
                }
                
                // Move final bat
                finalBats.forEach(bat => moveFinalBat(bat));
            }

            // Move and check collisions for Dragon
            dragons.forEach(tieFighter => {
                moveDragon(tieFighter);
                
                // Periodic reminder that stronghold is still pursuing
                if (!tieFighter.userData.lastReminderTime) {
                    tieFighter.userData.lastReminderTime = Date.now();
                }
                
                const timeSinceLastReminder = Date.now() - tieFighter.userData.lastReminderTime;
                if (timeSinceLastReminder > 8000) { // Every 8 seconds
                    const distance = tieFighter.position.distanceTo(playerMotorcycle.position);
                    if (distance > 25) {
                        setMessage("üöÅ Criminal Stronghold still pursuing...");
                    } else if (distance > 15) {
                        setMessage("‚ö†Ô∏è Stronghold gaining ground!");
                    } else {
                        setMessage("üî• STRONGHOLD CLOSE BEHIND!");
                    }
                    tieFighter.userData.lastReminderTime = Date.now();
                }
            });
            
            // PEPE ENEMY (Level 40+) ‚Äî giant frog on road, HEAD-ON from opposite side, steals ALL coins (no death)
            if (level >= 40) {
                if (pepeEnemies.length === 0 && !level40PepeSpawned) {
                    level40PepeSpawned = true;
                    const pepe = createPepeEnemy();
                    const laneX = [-4, 0, 4][Math.floor(Math.random() * 3)];
                    // Spawn AHEAD of player (smaller Z) ‚Äî riding from opposite direction, head-on
                    pepe.position.set(laneX, 0, playerMotorcycle.position.z - 120);
                    scene.add(pepe);
                    pepeEnemies.push(pepe);
                    setMessage("üê∏ GIANT PEPE INCOMING HEAD-ON! He steals ALL your coins!");
                    setTimeout(() => setMessage("‚ö†Ô∏è Dodge or use DISCO ‚Äî he doesn't kill, just robs you!"), 2000);
                }
                
                for (let pi = pepeEnemies.length - 1; pi >= 0; pi--) {
                    const pepe = pepeEnemies[pi];
                    if (pepe.userData.isDead) continue;
                    const playerZ = playerMotorcycle.position.z;
                    const playerX = playerMotorcycle.position.x;
                    const distanceToPlayer = pepe.position.distanceTo(playerMotorcycle.position);
                    
                    // Laser-guided missile: smoothly home in on player, but MUCH slower for impact
                    const target = new THREE.Vector3(playerX, 0, playerZ);
                    const lerpFactor = 0.004; // Very slow approach ‚Äî gradual, readable
                    pepe.position.lerp(target, lerpFactor);
                    pepe.position.y = 0; // On road
                    
                    // COLLISION: Pepe steals ALL coins ‚Äî no death
                    const pepeCollisionDistance = pepe.userData.collisionRadius ?? 4;
                    if (distanceToPlayer < pepeCollisionDistance && !isInvincible && !isGhostActive && !isBlasterActive) {
                        const stolen = score;
                        score = 0;
                        updateScoreDisplay();
                        setMessage(stolen > 0 ? "üê∏ PEPE ROBBED YOU! All " + stolen + " coins gone!" : "üê∏ PEPE BUMPED YOU!");
                        triggerCameraShake(1.0, 400);
                        scene.remove(pepe);
                        pepeEnemies.splice(pi, 1);
                        level40PepeSpawned = false;
                        break;
                    }
                }
            }
            
            // NEW GALAXY ZONE SYSTEM (Levels 3-8)
                                    if (galaxyZoneActive && level >= 30 && level <= 49) {
                updateGalaxyZone();
            }

            // updateInfiniteRoad() already called at top of animate ‚Äî removed duplicate call (was 2x/frame)

            if (coins.length < maxCoins && shouldSpawnObject(coinSpawnRate, level)) {
                const isFlying = zeroGravityActive && currentBiome === 'northernLights';
                const randomX = isFlying ? (Math.random() - 0.5) * 4 : (Math.random() - 0.5) * (roadWidth - 1); // Narrow path (¬±2) when flying
                const randomZ = playerMotorcycle.position.z - 50 - Math.random() * 100;
                const coinY = isFlying ? 0.1 : 0.5; // On ground when flying
                const coin = createCoin();
                coin.position.set(randomX, coinY, randomZ);
                scene.add(coin);
                coins.push(coin);
            }

            const coinPickupFlying = zeroGravityActive && currentBiome === 'northernLights';
            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                coin.rotation.y += 0.05; // Make coins spin

                let collisionThreshold = 1.8; // Increased for easier coin pickup
                const distance = coinPickupFlying
                    ? Math.hypot(playerMotorcycle.position.x - coin.position.x, playerMotorcycle.position.z - coin.position.z)
                    : playerMotorcycle.position.distanceTo(coin.position);

                if (distance < collisionThreshold) {
                    const burstPosition = coin.position.clone(); // Store position before removing
                    
                    // REDUCED screen flash for regular coins - minimal to avoid shake feeling
                    // Removed intense flash - only subtle effect for gold coins
                    
                    scene.remove(coin);
                    returnToPool('coins', coin);
                    coins.splice(i, 1);
                    
                    // COMBO SYSTEM - Increase combo if collected within time window
                    const currentTime = Date.now();
                    if (currentTime - lastCoinCollectionTime < COMBO_RESET_TIME) {
                        coinCombo++;
                    } else {
                        coinCombo = 1; // Reset combo if too much time passed
                    }
                    lastCoinCollectionTime = currentTime;
                    
                    // Calculate coin value with combo multiplier (max 5x multiplier)
                    const comboMultiplier = Math.min(1 + (coinCombo * 0.1), 5); // 1x, 1.1x, 1.2x... up to 5x
                    const coinValue = Math.floor(1 * comboMultiplier);
                    score += coinValue;
                    coinsForPowerUp += coinValue;
                    
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // DOPAMINE FEEDBACK - FLOATING SCORE TEXT
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    if (coinCombo > 1 && coinValue > 1) {
                        // Show combo multiplier text
                        createFloatingScoreText(burstPosition, `+${coinValue}`, 'coin-combo');
                    } else {
                        createFloatingScoreText(burstPosition, '+1', 'coin-1');
                    }
                    
                    // Celebration text at combo milestones!
                    if (coinCombo === 3 || coinCombo === 5 || coinCombo === 7 || coinCombo === 10 || coinCombo === 15 || coinCombo === 20) {
                        setTimeout(() => {
                            const celebPos = burstPosition.clone();
                            celebPos.y += 1;
                            createFloatingScoreText(celebPos, getCelebrationMessage(coinCombo), 'celebration');
                            triggerCelebration(800); // Trigger flipper celebration!
                        }, 150);
                    }
                    
                    // Check for skin unlocks
                    checkAndUnlockSkins(score);
                    
                    // Update combo display
                    if (coinCombo > 1) {
                        comboDisplay.textContent = `${coinCombo}x COMBO! +${coinValue} coins`;
                        comboDisplay.classList.add('active');
                        comboDisplay.style.animation = 'none';
                        setTimeout(() => {
                            comboDisplay.style.animation = 'comboPulse 0.5s ease-out';
                        }, 10);
                    } else {
                        comboDisplay.classList.remove('active');
                    }
                    
                    // Reset combo timeout
                    if (comboTimeout) clearTimeout(comboTimeout);
                    comboTimeout = setTimeout(() => {
                        coinCombo = 0;
                        comboDisplay.classList.remove('active');
                    }, COMBO_RESET_TIME);
                    
                    // MAGICAL COIN SOUND - Pitch increases with combo (ENHANCED)
                    if (coinSynth) {
                        try {
                            const now = Tone.now();
                            const pitchBoost = Math.min(coinCombo * 0.15, 0.8);
                            coinSynth.triggerAttackRelease(['C6', 'E6'], '32n', now, 0.7 + pitchBoost);
                            coinSynth.triggerAttackRelease(['G6'], '32n', now + 0.04, 0.6 + pitchBoost);
                            coinSynth.triggerAttackRelease(['C7'], '32n', now + 0.08, 0.5 + pitchBoost);
                            if (coinCombo > 2) coinSynth.triggerAttackRelease(['E7'], '64n', now + 0.12, 0.4 + pitchBoost);
                        } catch (_) {}
                    }
                    
                    // Real coin pickup sound from Freesound
                    playCoinPickupSound();
                    
                    // ENHANCED EXPLOSION EFFECT - More particles for higher combos
                    createSilverCoinExplosion(burstPosition);
                    
                    // Show combo message for high combos
                    if (coinCombo >= 5) {
                        setMessage(`üî• ${coinCombo}x COMBO! INSANE!`);
                    } else if (coinCombo >= 3) {
                        setMessage(`‚ö° ${coinCombo}x COMBO!`);
                    }
                    
                    // No shake on coin pickup ‚Äî shake only on competitor collisions
                    
                    // Stronger haptic for higher combos
                    if (navigator.vibrate) {
                        const hapticDuration = Math.min(15 + (coinCombo * 2), 50);
                        navigator.vibrate(hapticDuration);
                    }
                    updateScoreDisplay();
                    createCoinBurst(burstPosition);
                    createMagicalSparkles(burstPosition); // Magical sparkle effect
                    createEtherTrail(burstPosition);
                    
                    // DOPAMINE PULSE - Make penguin briefly scale up on coin collection!
                    triggerPenguinPulse(coinCombo);
                    
                trackEtherCollection();

                    if (score >= levelThreshold && score > 0) {
                         const previousLevel = level;
                         const previousBiome = getCurrentBiome(level);
                         level++;
                         // Slower scaling: 3 + (level * 2.5) instead of level * 5
                         // This means: level 2 = 5.5, level 3 = 8, level 4 = 10.5, etc.
                         levelThreshold = Math.floor(3 + (level * 2.5));
                         levelDisplay.textContent = 'ICEBERG: ' + level;
                         
                         // BIOME SWITCHING - Check if entering new biome
                         const newBiome = getCurrentBiome(level);
                         if (newBiome !== previousBiome) {
                             applyBiome(newBiome);
                             const biomeMessages = {
                                 'sunsetTundra': 'üåÖ ENTERING SUNSET TUNDRA! Orange skies ahead!',
                                 'northernLights': 'üåå ENTERING NORTHERN LIGHTS ZONE! Zero gravity sections!',
                                 'blizzard': '‚ùÑÔ∏è ENTERING BLIZZARD CHAOS! Low visibility and wind!'
                             };
                             if (biomeMessages[newBiome]) {
                                 setMessage(biomeMessages[newBiome]);
                             }
                         }
                         
                         // Boss penguin every 10 levels in blizzard biome (75+)
                         if (newBiome === 'blizzard' && level % 10 === 0 && level >= 75) {
                             // Spawn boss penguin (placeholder - implement boss system)
                             setMessage(`üêß BOSS PENGUIN APPEARS AT LEVEL ${level}!`);
                         }
                         
                         // Reset manual boost counter when entering a new level bracket (every 10 levels)
                         const previousBracket = Math.floor((previousLevel - 1) / 10);
                         const currentBracket = Math.floor((level - 1) / 10);
                         if (currentBracket > previousBracket) {
                             manualBoostsUsed = 0;
                             blasterBoltsUsed = 0; // Reset blaster bolts too
                             const maxBoosts = currentBracket + 1;
                             const maxBlasters = Math.floor(level / 10);
                             if (maxBlasters > 0) {
                                 setMessage(`üéÜ Level ${level}! Manual boosts & blaster bolts reset! You now have ${maxBoosts} boost${maxBoosts > 1 ? 's' : ''} and ${maxBlasters} blaster bolt${maxBlasters > 1 ? 's' : ''} available!`);
                             } else {
                                 setMessage(`üéÜ Level ${level}! Manual boosts reset! You now have ${maxBoosts} boost${maxBoosts > 1 ? 's' : ''} available!`);
                             }
                             updateBoostButtonDisplay(); // Update button display
                             updateBlasterButtonDisplay(); // Update blaster button display
                         }
                         
                         // Apply extreme difficulty at level 60
                         if (level === EXTREME_DIFFICULTY_LEVEL) {
                             applyExtremeDifficulty();
                         }
                         
                         if (level === GRAND_PRIZE_LEVEL) {
                             gamePaused = true;
                             setMessage("üéâ CONGRATS! Keep going CYPHES"); // NEW MESSAGE
                             setTimeout(() => {
                                 gamePaused = false;
                                 setMessage("");
                             }, 5000); // Shortened to 5 seconds
                         } else {
                             showLevelUp(level);
                             
                             // NEW GALAXY ZONE ACTIVATION
                             if (level === 30) {
                                 galaxyZoneActive = true;
                                 setMessage("üèôÔ∏è ENTERING DOWNTOWN DISTRICT! Criminal vehicles incoming!");
                                 // Change scene atmosphere to AI Wars style - but keep background from biome
                                 const currentBiome = getCurrentBiome(level);
                                 scene.fog = new THREE.Fog(0x0a0a1a, 40, 250); // Adjusted fog distance
                                 // Don't change background - keep biome background
                                 renderer.setClearColor(scene.background.getHex());
                             }
                             if (level === 50 && galaxyZoneActive) {
                                galaxyZoneActive = false;
                                setMessage("üåü Exiting Downtown District... returning to normal streets.");
                                // Reset atmosphere - use current biome settings instead of hardcoded
                                const currentBiome = getCurrentBiome(level);
                                applyBiome(currentBiome); // This will set proper fog and background
                                 // Clear remaining galaxy ships
                                 galaxyShips.forEach(ship => {
                                     scene.remove(ship);
                                 });
                                 galaxyShips.length = 0;
                                 galaxyProjectiles.forEach(proj => {
                                     scene.remove(proj);
                                 });
                                 galaxyProjectiles.length = 0;
                             }
                             
                             if (level === BOOST_UNLOCK_LEVEL) { // Check against new BOOST_UNLOCK_LEVEL
                                 setMessage("Boost Unlocked!" + (isMobileDevice() ? "" : " Press Space or Boost Button."));
                                 boostButton.disabled = isBoosting || gamePaused;
                                 updateBoostButtonDisplay(); // Update button display
                             }
                             // Krypton Crystal Zone Messages
                             if (level === 20) {
                                 setTimeout(() => setMessage("üíé ENTERING KRYPTON CRYSTAL ZONE! Deadly crystalline obstacles ahead!"), 1000);
                             }
                             if (level === 26) {
                                 setTimeout(() => setMessage("‚ú® Exiting Krypton zone... clear roads ahead!"), 1000);
                             }
                             if (level === 55) {
                                 setTimeout(() => setMessage("üíé KRYPTON ZONE RETURNS! Advanced crystal formations detected!"), 1000);
                             }
                             if (level === 61) {
                                 setTimeout(() => setMessage("‚ú® Crystal zone cleared... open highway restored!"), 1000);
                             }
                             if (level === 90) {
                                 setTimeout(() => setMessage("üíé FINAL KRYPTON ZONE! Maximum crystal density ahead!"), 1000);
                             }
                             if (level === 101) {
                                 setTimeout(() => setMessage("‚ú® All crystal zones cleared! Pure racing ahead!"), 1000);
                             }
                             
                             if (level === 10 && !DRAGON_LEVELS.includes(10)) { // Check if it's not a tieFighter level to avoid double message
                                 currentRoadTextureIndex = 1;
                                 // Update all road segments with new shared material
                                 roadSegments.forEach(segment => {
                                     segment.material = sharedRoadMaterials[currentRoadTextureIndex];
                                 });
                                 setMessage("The road shifts... darkness deepens!");
                             }
                             if (level === 20 && !DRAGON_LEVELS.includes(20)) { // Check if it's not a tieFighter level
                                  currentRoadTextureIndex = 2;
                                  // Update all road segments with new shared material
                                  roadSegments.forEach(segment => {
                                      segment.material = sharedRoadMaterials[currentRoadTextureIndex];
                                  });
                                  setMessage("The abyss stares back!");
                             }
                                          // MORE MAYHEM: More competitors for chaos!
             const maxAIMotorcycles = level >= 10 ? INVARIANT_MAX_AI_AFTER_L10 : Math.min(baseAiBikes + Math.floor((level - 1) / 1.5), 12);
             if (aiMotorcycles.length < maxAIMotorcycles) {
                 const bikesToAdd = Math.min(maxAIMotorcycles - aiMotorcycles.length, 4); // Add max 4 at a time (reduced by 25% from 5)
                 for (let j = 0; j < bikesToAdd; j++) {
                     const { riderColor, bearType } = pickRiderForSpawn(j === 0); // Only 1 colored per batch
                     const newAiBikeParts = createMotorcycle(aiColors[aiMotorcycles.length % aiColors.length], riderColor, false, bearType);
                     const newAiBike = newAiBikeParts.motorcycle;
                     newAiBike.userData.bearType = bearType;
                     newAiBike.position.set((aiMotorcycles.length - (maxAIMotorcycles - 1) / 2) * 2.5, 0, playerMotorcycle.position.z - 15 - Math.random() * 40);
                     newAiBike.userData.targetX = newAiBike.position.x;
                     newAiBike.userData.targetTimer = 0;
                     newAiBike.userData.steerSpeed = bearType === 'pepe' ? 0.03 : 0.02;
                     const baseSpd = baseMoveSpeed * (0.85 + Math.random() * 0.2);
                     newAiBike.userData.moveSpeed = bearType === 'pepe' ? baseSpd * 1.5 : baseSpd;
                     newAiBike.userData.canMove = true;
                     scene.add(newAiBike);
                     aiMotorcycles.push(newAiBike);
                                  }
             }
             
             const currentTime = Date.now();
             const minCompetitors = level >= 10 ? Math.min(3, INVARIANT_MAX_AI_AFTER_L10) : 3;
             const maxCompetitors = level >= 10 ? INVARIANT_MAX_AI_AFTER_L10 : 6;
             const spawnLanes = [-4, 0, 4];
             
             // Time-based spawning: spawn new competitors every few seconds
             if (currentTime - lastCompetitorSpawnTime > competitorSpawnInterval) {
                 if (aiMotorcycles.length < maxCompetitors) {
                     const spawnCount = Math.min(2, maxCompetitors - aiMotorcycles.length); // Restore: up to 2 at a time
                     for (let k = 0; k < spawnCount; k++) {
                         const { riderColor, bearType } = pickRiderForSpawn(k === 0); // Only 1 colored per batch
                         const respawnAiBikeParts = createMotorcycle(aiColors[aiMotorcycles.length % aiColors.length], riderColor, false, bearType);
                         const respawnAiBike = respawnAiBikeParts.motorcycle;
                         respawnAiBike.userData.bearType = bearType;
                         // Spawn in different lanes, spread along road
                         const laneX = spawnLanes[Math.floor(Math.random() * spawnLanes.length)] + (Math.random() - 0.5) * 1.5;
                         const spawnBehind = Math.random() > 0.3;
                         respawnAiBike.position.set(
                             laneX, 
                             0, 
                             spawnBehind ? 
                                 playerMotorcycle.position.z - 40 - Math.random() * 80 : // Wider spread behind
                                 playerMotorcycle.position.z + 40 + Math.random() * 60   // Wider spread ahead
                         );
                         respawnAiBike.userData.targetX = respawnAiBike.position.x;
                         respawnAiBike.userData.targetTimer = 0;
                         respawnAiBike.userData.steerSpeed = bearType === 'pepe' ? 0.03 : 0.02;
                         const baseSpd = baseMoveSpeed * (0.85 + Math.random() * 0.3);
                         respawnAiBike.userData.moveSpeed = bearType === 'pepe' ? baseSpd * 1.5 : baseSpd;
                         respawnAiBike.userData.canMove = true;
                         scene.add(respawnAiBike);
                         aiMotorcycles.push(respawnAiBike);
                     }
                     lastCompetitorSpawnTime = currentTime;
                 }
             }
             
             // EMERGENCY RESPAWN: If too few competitors, immediately spawn more
             if (aiMotorcycles.length < minCompetitors) {
                 const emergencyCount = minCompetitors - aiMotorcycles.length;
                 for (let k = 0; k < emergencyCount; k++) {
                     const { riderColor, bearType } = pickRiderForSpawn(k === 0); // Only 1 colored per batch
                     const respawnAiBikeParts = createMotorcycle(aiColors[aiMotorcycles.length % aiColors.length], riderColor, false, bearType);
                     const respawnAiBike = respawnAiBikeParts.motorcycle;
                     respawnAiBike.userData.bearType = bearType;
                     const laneX = spawnLanes[Math.floor(Math.random() * spawnLanes.length)] + (Math.random() - 0.5) * 1.5;
                     respawnAiBike.position.set(
                         laneX, 
                         0, 
                         playerMotorcycle.position.z - 50 - Math.random() * 60
                     );
                     respawnAiBike.userData.targetX = respawnAiBike.position.x;
                     respawnAiBike.userData.targetTimer = 0;
                     respawnAiBike.userData.steerSpeed = bearType === 'pepe' ? 0.03 : 0.02;
                     const baseSpd = baseMoveSpeed * (0.85 + Math.random() * 0.25);
                     respawnAiBike.userData.moveSpeed = bearType === 'pepe' ? baseSpd * 1.5 : baseSpd;
                     respawnAiBike.userData.canMove = true;
                     scene.add(respawnAiBike);
                     aiMotorcycles.push(respawnAiBike);
                 }
             }
             
             // Only increase base speed up to the new limit level
                             if (level < SPEED_INCREASE_LIMIT_LEVEL) baseMoveSpeed += baseSpeedIncreasePerLevel;
                             if (level < GRAND_PRIZE_LEVEL) obstacleSpeedMultiplier += 0.2;

                             // Dragon spawning logic
                             if (DRAGON_LEVELS.includes(level) && dragons.length === 0) {
                                 const tieFighterType = level === 90 ? 2 : level === 60 ? 1 : 0;
                                 const tieFighter = createDragon(tieFighterType);
                                 
                                 // OPTIMAL POSITIONING: Close enough to be visible and threatening after cinematic
                                 // Position: Behind player, elevated, slightly to the side for dramatic effect
                                 const spawnDistance = tieFighterType === 2 ? 40 : tieFighterType === 1 ? 35 : 30; // Much closer
                                 const spawnHeight = tieFighterType === 2 ? 8 : tieFighterType === 1 ? 7 : 6; // Higher for bigger bosses
                                 const spawnOffset = (Math.random() - 0.5) * 8; // Slight side offset for variety
                                 
                                 tieFighter.position.set(spawnOffset, spawnHeight, playerMotorcycle.position.z - spawnDistance);
                                 scene.add(tieFighter);
                                 dragons.push(tieFighter);
                                 
                                 // More dramatic stronghold messages with Krypton hints
                                 if (tieFighterType === 2) {
                                     setMessage("üíÄ FINAL CRIMINAL STRONGHOLD DEPLOYED! MAXIMUM THREAT!");
                                     setTimeout(() => setMessage("üíé URGENT: Only Krypton can destroy it!"), 2000);
                                 } else if (tieFighterType === 1) {
                                     setMessage("üöÅ MAJOR CRIMINAL STRONGHOLD INCOMING! EVASIVE MANEUVERS!");
                                     setTimeout(() => setMessage("üí° Remember: Only Krypton can destroy strongholds!"), 2000);
                                 } else {
                                     setMessage("‚ö†Ô∏è CRIMINAL STRONGHOLD DEPLOYED! IT WILL HUNT YOU DOWN!");
                                     setTimeout(() => setMessage("üî¨ Tip: Collect Krypton to defeat it!"), 2000);
                                 }
                                 
                                 // Activate cinematic camera for tieFighter
                                 activateCinematicCamera('tieFighter', tieFighter);
                             }
                             
                         }
                    }
                } else if (coin.position.z > playerMotorcycle.position.z + 10) {
                    scene.remove(coin);
                    returnToPool('coins', coin);
                    coins.splice(i, 1);
                }
            }


            const dynamicMaxObstacles = getMaxObstaclesForLevel(level);
            const dynamicSpawnRate = getObstacleSpawnRate(level);
            const obstacleLanes = [-4, 0, 4];
            const now = Date.now();

            if (level >= 25 && obstacles.length < dynamicMaxObstacles) {
                if (now - lastObstacleClusterTime >= obstacleClusterCooldown && Math.random() < 1 / 320) {
                    const clusterSize = Math.min(2 + (Math.random() < 0.4 ? 1 : 0), dynamicMaxObstacles - obstacles.length);
                    lastObstacleClusterTime = now;
                    obstacleClusterCooldown = 3800 + Math.random() * 1400;
                    for (let c = 0; c < clusterSize; c++) {
                        const laneX = obstacleLanes[Math.floor(Math.random() * obstacleLanes.length)] + (Math.random() - 0.5) * 1.5;
                        const randomZ = playerMotorcycle.position.z - 80 - Math.random() * 120;
                        const obstacle = createObstacle();
                        obstacle.position.set(laneX, 0.5, randomZ);
                        scene.add(obstacle);
                        obstacles.push(obstacle);
                    }
                }
            } else if (obstacles.length < dynamicMaxObstacles && shouldSpawnObject(dynamicSpawnRate, level)) {
                const laneX = obstacleLanes[Math.floor(Math.random() * obstacleLanes.length)] + (Math.random() - 0.5) * 1.5;
                const randomZ = playerMotorcycle.position.z - 80 - Math.random() * 220;
                const obstacle = createObstacle();
                obstacle.position.set(laneX, 0.5, randomZ);
                scene.add(obstacle);
                obstacles.push(obstacle);
            }
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                if (level >= 20 && !obstacle.userData.isPlayerObstacle) {
                    const dx = playerMotorcycle.position.x - obstacle.position.x;
                    obstacle.position.x = Math.max(-6, Math.min(6, obstacle.position.x + Math.sign(dx) * 0.015));
                }
                if (obstacle.userData.isPlayerObstacle && obstacle.userData.rotationSpeed) {
                    obstacle.rotation.y += obstacle.userData.rotationSpeed;
                    obstacle.rotation.x += obstacle.userData.rotationSpeed * 0.5;
                    // Pulse the energy core
                    if (obstacle.children.length > 5) { // Has energy core
                        const core = obstacle.children[obstacle.children.length - 1];
                        const pulseFactor = 1 + Math.sin(Date.now() * 0.01) * 0.3;
                        core.scale.setScalar(pulseFactor);
                    }
                }
                
                const distance = playerMotorcycle.position.distanceTo(obstacle.position);
                const obstacleCollisionThreshold = 1.5;
                
                // Only regular obstacles (not player-dropped) can kill the player
                if (!obstacle.userData.isPlayerObstacle && !isInvincible && !isGhostActive && !isCinematicInvulnerable && !isBlasterActive && distance < obstacleCollisionThreshold) {
                    playCollisionSound('obstacle');
                    triggerCameraShake(2.0, 400); // Make impact feel heavy
                    gameOver(); return;
                } else if (obstacle.position.z > playerMotorcycle.position.z + 10) {
                    scene.remove(obstacle);
                    disposeObject(obstacle);
                    obstacles.splice(i, 1);
                }
            }

            // ICE GAPS REMOVED - No longer spawning ice gaps for better gameplay

            if (bowlingBallObstacles.length < maxBowlingBalls && shouldSpawnObject(bowlingBallSpawnRate, level)) {
                const ballLanes = [-4, 0, 4];
                const laneX = ballLanes[Math.floor(Math.random() * ballLanes.length)] + (Math.random() - 0.5) * 1.5;
                const randomZ = playerMotorcycle.position.z - 90 - Math.random() * 240; // Wider Z spread
                const bowlingBall = createBowlingBallObstacle();
                bowlingBall.position.set(laneX, 0.8, randomZ);
                scene.add(bowlingBall);
                bowlingBallObstacles.push(bowlingBall);
            }
            for (let i = bowlingBallObstacles.length - 1; i >= 0; i--) {
                const bowlingBall = bowlingBallObstacles[i];
                // Bowling balls stay stationary - player catches up to them
                // No movement - they're obstacles to be avoided
                if (bowlingBall.position.z > playerMotorcycle.position.z + 5) {
                    scene.remove(bowlingBall);
                    disposeObject(bowlingBall);
                    bowlingBallObstacles.splice(i, 1);
                }
            }

            if (itemBoxes.length < maxItemBoxes && shouldSpawnObject(itemBoxSpawnRate, level)) {
                const randomX = (Math.random() - 0.5) * (roadWidth - 2);
                const randomZ = playerMotorcycle.position.z - 100 - Math.random() * 200;
                const itemBox = createItemBox();
                itemBox.position.set(randomX, 0.5, randomZ);
                scene.add(itemBox);
                itemBoxes.push(itemBox);
            }
            for (let i = itemBoxes.length - 1; i >= 0; i--) {
                const rubyGem = itemBoxes[i];
                
                // STUNNING RUBY ANIMATION
                rubyGem.rotation.x += rubyGem.userData.rotationSpeed;
                rubyGem.rotation.y += rubyGem.userData.rotationSpeed * 1.5; // Faster Y rotation
                rubyGem.rotation.z += rubyGem.userData.rotationSpeed * 0.7;
                
                // PULSING ENERGY EFFECTS
                rubyGem.userData.pulsePhase += 0.05;
                const pulseFactor = 1 + Math.sin(rubyGem.userData.pulsePhase) * 0.2;
                
                // Pulse the inner core
                if (rubyGem.children[1]) { // Core
                    rubyGem.children[1].scale.setScalar(pulseFactor);
                }
                
                // Pulse the outer aura
                if (rubyGem.children[2]) { // Aura
                    const auraPulse = 1 + Math.sin(rubyGem.userData.pulsePhase * 1.3) * 0.15;
                    rubyGem.children[2].scale.setScalar(auraPulse);
                    rubyGem.children[2].material.opacity = 0.2 + Math.sin(rubyGem.userData.pulsePhase * 2) * 0.1;
                }
                
                const distance = playerMotorcycle.position.distanceTo(rubyGem.position);
                const itemBoxCollisionThreshold = 1.2;
                if (distance < itemBoxCollisionThreshold) {
                    scene.remove(rubyGem);
                    itemBoxes.splice(i, 1);
                    // Dramatic card pickup effects
                    triggerCameraShake(0.9, 320);
                    createCardPickupExplosion(rubyGem.position.clone());
                    createMagicalSparkles(rubyGem.position.clone());
                    playCardPickupSound();
                    activateRandomPowerUp();
                } else if (rubyGem.position.z > playerMotorcycle.position.z + 10) {
                    scene.remove(rubyGem);
                    itemBoxes.splice(i, 1);
                }
            }

            // Green Vials spawning and collection
            if (greenVials.length < maxGreenVials && shouldSpawnObject(greenVialSpawnRate, level)) {
                const randomX = (Math.random() - 0.5) * (roadWidth - 2);
                const randomZ = playerMotorcycle.position.z - 80 - Math.random() * 150;
                const greenVial = createGreenVial();
                greenVial.position.set(randomX, 0.5, randomZ);
                scene.add(greenVial);
                greenVials.push(greenVial);
                // Debug logging removed for performance
            }
            for (let i = greenVials.length - 1; i >= 0; i--) {
                const greenVial = greenVials[i];
                
                // Animate the green vial (rotation and pulsing)
                greenVial.rotation.y += greenVial.userData.rotationSpeed;
                greenVial.userData.pulsePhase += 0.08;
                const pulseScale = 1 + Math.sin(greenVial.userData.pulsePhase) * 0.1;
                greenVial.scale.set(pulseScale, pulseScale, pulseScale);
                
                const distance = playerMotorcycle.position.distanceTo(greenVial.position);
                const greenVialCollisionThreshold = 1.5; // Increased collision threshold
                if (distance < greenVialCollisionThreshold) {
                    // Debug logging removed for performance
                    scene.remove(greenVial);
                    greenVials.splice(i, 1);
                    triggerCameraShake(0.045, 60); // Hint-only (85% reduced) for green vial
                    consumeGreenVial();
                } else if (greenVial.position.z > playerMotorcycle.position.z + 10) {
                    scene.remove(greenVial);
                    greenVials.splice(i, 1);
                }
            }

            for (let i = activeProjectiles.length - 1; i >= 0; i--) {
                 const projectile = activeProjectiles[i];
                 // Projectile is now a group, move the group
                 projectile.position.add(projectile.userData.direction.clone().multiplyScalar(projectile.userData.speed));
                 
                 // DRAMATIC DISCO SPINNING AND PULSING EFFECTS WHILE TRAVELING
                 const time = Date.now() * 0.01;
                 const pulseIntensity = 1.0 + Math.sin(time * 3) * 0.5; // Fast intense cyan pulsing
                 const scalePulse = 1.0 + Math.sin(time * 2) * 0.4; // Scale pulsing for glow effect
                 
                 // Main disco spinning animation - FAST rotation like a real disco ball!
                 projectile.rotation.z += 0.4; // Super fast spinning
                 projectile.rotation.x += 0.1; // Slight wobble for realism
                 
                 projectile.children.forEach((child, index) => {
                     if (child.material && child.material.emissiveIntensity !== undefined) {
                         // Pulse emissive intensity for dramatic disco glow
                         const baseDiscoIntensity = index === 0 ? 8.0 : index === 1 ? 6.0 : index === 2 ? 12.0 : 10.0;
                         child.material.emissiveIntensity = baseDiscoIntensity * pulseIntensity;
                     }
                     // Individual component animations
                     if (index === 1) { // Outer ring
                         child.rotation.z += 0.2; // Counter-rotate outer ring
                         child.scale.setScalar(scalePulse * 1.1);
                     } else if (index > 2) { // Energy sparks
                         child.rotation.x += 0.15 * index; // Each spark rotates differently
                         child.rotation.y += 0.1 * index;
                     }
                 });

                 // DISCO projectiles now BOUNCE OFF dragons - only Krypton can destroy them!
                 let hitDragon = false; // Flag to check if tieFighter was hit
                 for (let k = dragons.length - 1; k >= 0; k--) {
                      const tieFighter = dragons[k];
                      const distanceToDragon = projectile.position.distanceTo(tieFighter.position);
                      const tieFighterCollisionThreshold = 4.0; // Adjust threshold for tieFighter size
                      if (distanceToDragon < tieFighterCollisionThreshold) {
                          setMessage("üí´ DISCO bounced off stronghold! Only Krypton can destroy it!");
                          // Create visual bounce effect
                          createExplosion(projectile.position.clone(), 0x00ffff); // Cyan bounce explosion
                          // Remove projectile but NOT the dragon
                          scene.remove(projectile); activeProjectiles.splice(i, 1);
                          hitDragon = true;
                          break; // Exit tieFighter loop after hit
                      }
                 }
                 if (hitDragon) continue; // If tieFighter was hit, move to the next projectile
                 
                 // DISCO kills PEPE ENEMY
                 let hitPepe = false;
                 for (let k = pepeEnemies.length - 1; k >= 0; k--) {
                     const pepe = pepeEnemies[k];
                     const distanceToPepe = projectile.position.distanceTo(pepe.position);
                     if (distanceToPepe < 5) { // Large collision for 3x pepe
                         setMessage("üê∏ PEPE DESTROYED BY DISCO! +250 COINS!");
                         score += 250;
                         updateScoreDisplay();
                         createTwistedMetalExplosion(pepe.position.clone());
                         playTwistedMetalCrashSound();
                         scene.remove(pepe);
                         pepeEnemies.splice(k, 1);
                         level40PepeSpawned = false;
                         scene.remove(projectile);
                         activeProjectiles.splice(i, 1);
                         triggerCameraShake(1.8, 500);
                         hitPepe = true;
                         break;
                     }
                 }
                 if (hitPepe) continue;

                 // Check collision with bat gangs
                 let hitBat = false; // Flag to check if bat gang was hit
                 for (let k = batGangs.length - 1; k >= 0; k--) {
                     const batGang = batGangs[k];
                     const distance = projectile.position.distanceTo(batGang.position);
                     const batCollisionThreshold = 2.0; // Slightly larger threshold for bat gangs
                     if (distance < batCollisionThreshold) {
                         setMessage(`Bat gang destroyed! ++100 EMC!`);
                                                    score += 100; // 100 points for destroying bat gang
                           updateScoreDisplay();
                         scene.remove(projectile); activeProjectiles.splice(i, 1);
                         scene.remove(batGang); batGangs.splice(k, 1);
                         createExplosion(batGang.position.clone(), 0xff8800); // Orange explosion for bat gang
                         triggerCameraShake(0.7, 350); // Strong shake for bat gang destruction
                         hitBat = true;
                         break; // Exit bat gang loop after hit
                     }
                 }
                 if (hitBat) continue; // If bat gang was hit, move to the next projectile

                 for (let j = aiMotorcycles.length - 1; j >= 0; j--) {
                     const aiBike = aiMotorcycles[j];
                     // Check distance between the projectile group's position and the AI bike
                     const distance = projectile.position.distanceTo(aiBike.position);
                     const projectileCollisionThreshold = 1.5;
                     if (distance < projectileCollisionThreshold) {
                         setMessage(`Hit an Imperial! Popn +20!`);
                         score += 20;
                         updateScoreDisplay();
                         scene.remove(projectile); activeProjectiles.splice(i, 1);
                         scene.remove(aiBike); aiMotorcycles.splice(j, 1);
                         createExplosion(aiBike.position.clone(), 0x00ff00); // Create green explosion at AI position
                         triggerCameraShake(0.6, 300); // Medium shake for enemy destruction
                         trackEnemyDefeat(); // Track enemy defeat
                         
                         // Activate cinematic camera when projectile knocks out AI
                         activateCinematicCamera('levelUp');
                         
                         break; // Exit inner loop after hit
                     }
                 }
                 if (projectile.position.z < playerMotorcycle.position.z - 200) {
                     scene.remove(projectile); activeProjectiles.splice(i, 1);
                 }
            }

            // Blaster Bolt collision detection
            if (isBlasterActive) {
                // Check collision with bat gangs
                for (let i = batGangs.length - 1; i >= 0; i--) {
                    const batGang = batGangs[i];
                    const distance = playerMotorcycle.position.distanceTo(batGang.position);
                    const blasterCollisionThreshold = 4.0; // Increased range since rider is the source
                    if (distance < blasterCollisionThreshold) {
                                                    setMessage(`Blaster Bolt destroyed bat gang! ++15 EMC!`);
                        score += 15;
                        updateScoreDisplay();
                        scene.remove(batGang);
                        batGangs.splice(i, 1);
                        createTSphereImpactExplosion(batGang.position.clone()); // DRAMATIC DISCO impact explosion
                        trackEnemyDefeat();
                    }
                }
                
                // Check collision with AI riders (colored bears = 3x/5x hunt bonus)
                for (let i = aiMotorcycles.length - 1; i >= 0; i--) {
                    const aiBike = aiMotorcycles[i];
                    const distance = playerMotorcycle.position.distanceTo(aiBike.position);
                    const blasterCollisionThreshold = 3.5; // Increased range since rider is the source
                    if (distance < blasterCollisionThreshold) {
                        const bearType = aiBike.userData.bearType || 'white';
                        const baseBlaster = 15;
                        const mult = bearType === 'red' ? 5 : (bearType === 'brown' || bearType === 'black' ? 3 : 1);
                        const blasterPoints = baseBlaster * mult;
                        score += blasterPoints;
                        updateScoreDisplay();
                        scene.remove(aiBike);
                        aiMotorcycles.splice(i, 1);
                        const huntLabel = bearType === 'red' ? 'RED BEAR' : (bearType === 'brown' ? 'BROWN BEAR' : (bearType === 'black' ? 'BLACK BEAR' : ''));
                        if (huntLabel) {
                            playColoredBearCrashSound();
                            createFloatingScoreText(aiBike.position.clone(), `+${blasterPoints} ${huntLabel} ${mult}x!`, mult === 5 ? 'coin-gold' : 'coin-combo');
                            setMessage(`${mult}x HUNT! +${blasterPoints} COINS ‚Äî ${huntLabel}!`);
                        } else {
                            setMessage(`Blaster Bolt destroyed Imperial! +${blasterPoints} EMC!`);
                        }
                        createTSphereImpactExplosion(aiBike.position.clone()); // DRAMATIC DISCO impact explosion
                        trackEnemyDefeat();
                    }
                }
                
                // Check collision with dragons/TIE fighters
                for (let i = dragons.length - 1; i >= 0; i--) {
                    const tieFighter = dragons[i];
                    const tieFighterHead = tieFighter.userData.segments[0];
                    const tieFighterHeadPosition = tieFighterHead.getWorldPosition(new THREE.Vector3());
                    const distance = playerMotorcycle.position.distanceTo(tieFighterHeadPosition);
                    const blasterCollisionThreshold = 5.0; // Increased range since rider is the source
                    if (distance < blasterCollisionThreshold) {
                                                    setMessage(`Blaster Bolt destroyed TIE Fighter! ++15 EMC!`);
                        score += 15;
                        updateScoreDisplay();
                        scene.remove(tieFighter);
                        dragons.splice(i, 1);
                        createTSphereImpactExplosion(tieFighter.position.clone()); // DRAMATIC DISCO impact explosion
                        trackEnemyDefeat();
                    }
                }
                
                // Check collision with Final Bat (Level 85) - DISCO power can defeat it
                for (let i = finalBats.length - 1; i >= 0; i--) {
                    const finalBat = finalBats[i];
                    const distance = playerMotorcycle.position.distanceTo(finalBat.position);
                    const blasterCollisionThreshold = 4.0;
                    if (distance < blasterCollisionThreshold) {
                        setMessage(`üíÄ ICE BLAST DESTROYED FINAL OBSTACLE! ++500 Coins!`);
                        score += 500; // Big reward for defeating final bat
                        updateScoreDisplay();
                        scene.remove(finalBat);
                        finalBats.splice(i, 1);
                        createTSphereImpactExplosion(finalBat.position.clone()); // DRAMATIC explosion
                        triggerCameraShake(3.0, 1500); // Strong shake for victory
                        trackEnemyDefeat();
                    }
                }
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                const distance = playerMotorcycle.position.distanceTo(obstacle.position);
                // Only regular obstacles (not player-dropped) can kill the player
                if (!obstacle.userData.isPlayerObstacle && !isInvincible && !isGhostActive && !isCinematicInvulnerable && !isBlasterActive && distance < 1.5) { gameOver(); return; }
            }
            for (let i = bowlingBallObstacles.length - 1; i >= 0; i--) {
                const bowlingBall = bowlingBallObstacles[i];
                const distance = playerMotorcycle.position.distanceTo(bowlingBall.position);
                if (!isInvincible && !isGhostActive && !isCinematicInvulnerable && !isBlasterActive && distance < 1.8) { 
                    triggerCameraShake(1.2, 500);
                    gameOver(); return; 
                }
            }
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // TWISTED METAL STYLE - Crash into competitors for points!
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            for (let i = aiMotorcycles.length - 1; i >= 0; i--) {
                const aiBike = aiMotorcycles[i];
                const distance = playerMotorcycle.position.distanceTo(aiBike.position);
                if (distance < 1.5) { // Slightly larger collision radius for satisfying crashes
                    // TWISTED METAL: Crash into competitors = DESTRUCTION + POINTS!
                    slapImpactUntil = Date.now() + 500; // Hold exaggerated slap pose longer for dramatic impact
                    const bearType = aiBike.userData.bearType || 'white';
                    const baseCrashPoints = 50;
                    const mult = bearType === 'red' ? 5 : (bearType === 'brown' || bearType === 'black' ? 3 : 1);
                    const crashPoints = baseCrashPoints * mult;
                    scene.remove(aiBike);
                    aiMotorcycles.splice(i, 1);
                    
                    score += crashPoints;
                    updateScoreDisplay();
                    
                    // DRAMATIC CRASH EXPLOSION
                    createTwistedMetalExplosion(aiBike.position.clone());
                    
                    const huntLabel = bearType === 'red' ? 'RED BEAR' : (bearType === 'brown' ? 'BROWN BEAR' : (bearType === 'black' ? 'BLACK BEAR' : ''));
                    if (huntLabel) {
                        playColoredBearCrashSound();
                    } else {
                        playTwistedMetalCrashSound();
                    }
                    
                    // HEAVY impact shake ‚Äî dramatic collision, much stronger than before
                    triggerCameraShake(2.2, 700);
                    
                    // Full-screen impact flash for dramatic hit
                    const impactFlash = document.createElement('div');
                    impactFlash.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(255,120,40,0.85);z-index:9999;pointer-events:none;';
                    document.body.appendChild(impactFlash);
                    setTimeout(() => { if (impactFlash.parentNode) impactFlash.parentNode.removeChild(impactFlash); }, 180);
                    
                    // Strong haptic feedback
                    if (navigator.vibrate) {
                        navigator.vibrate([200, 80, 200, 80, 250]);
                    }
                    
                    // Show hunt bonus in collision so main rider can hunt colored bears
                    if (huntLabel) {
                        createFloatingScoreText(aiBike.position.clone(), `+${crashPoints} ${huntLabel} ${mult}x!`, mult === 5 ? 'coin-gold' : 'coin-combo');
                        setMessage(`${mult}x HUNT! +${crashPoints} COINS ‚Äî ${huntLabel}!`);
                    } else {
                        setMessage(`üí• VEHICULAR DESTRUCTION! +${crashPoints} COINS!`);
                    }
                    trackEnemyDefeat();
                }
            }
             for (let i = bowlingBallObstacles.length - 1; i >= 0; i--) {
                 const bowlingBall = bowlingBallObstacles[i];
                 for (let j = aiMotorcycles.length - 1; j >= 0; j--) {
                     const aiBike = aiMotorcycles[j];
                     const distance = aiBike.position.distanceTo(bowlingBall.position);
                     if (distance < 1.8) {
                         scene.remove(bowlingBall); bowlingBallObstacles.splice(i, 1);
                         score = Math.max(-1, score - bowlingBallPenalty);
                         updateScoreDisplay();
                         setMessage(`An AI collected a bowling ball! Popn -${bowlingBallPenalty}!`);
                         break;
                     }
                 }
             }
             
             // Check AI collisions with player-dropped obstacles
             for (let i = obstacles.length - 1; i >= 0; i--) {
                 const obstacle = obstacles[i];
                 if (obstacle.userData.isPlayerObstacle) {
                     for (let j = aiMotorcycles.length - 1; j >= 0; j--) {
                         const aiBike = aiMotorcycles[j];
                         const distance = aiBike.position.distanceTo(obstacle.position);
                         if (distance < 1.5) {
                             scene.remove(obstacle); obstacles.splice(i, 1);
                             scene.remove(aiBike); aiMotorcycles.splice(j, 1);
                             // Debug logging removed for performance
                             score += 10; // Award 10 points
                             updateScoreDisplay();
                             setMessage(`Imperial hit your Krypton! +10 Photons!`);
                             createExplosion(aiBike.position.clone(), 0x00ff00); // Green explosion
                             triggerCameraShake(0.5, 250); // Shake for Krypton impact
                             trackEnemyDefeat(); // Track enemy defeat
                             break;
                         }
                     }
                     
                     // KRYPTON vs DRAGON COLLISION - THE ONLY WAY TO DEFEAT DRAGONS!
                     for (let k = dragons.length - 1; k >= 0; k--) {
                         const dragon = dragons[k];
                         const distanceToKrypton = dragon.position.distanceTo(obstacle.position);
                         if (distanceToKrypton < 5.0) { // Larger range for dramatic effect
                             // KRYPTON DESTROYS THE DRAGON!
                             scene.remove(obstacle); obstacles.splice(i, 1);
                             scene.remove(dragon); dragons.splice(k, 1);
                             
                             // MASSIVE EXPLOSION AND REWARDS
                             createTSphereImpactExplosion(dragon.position.clone()); // Huge explosion
                             triggerCameraShake(5.0, 3000); // Intense screen shake
                             
                             // HUGE POINT REWARD
                             score += 1000;
                             updateScoreDisplay();
                             
                             // EPIC MESSAGE SEQUENCE
                             setMessage("üíé KRYPTON DESTROYS THE STRONGHOLD!");
                             setTimeout(() => setMessage("üéÜ MASSIVE DESTRUCTION! +1000 EMC!"), 1000);
                             setTimeout(() => setMessage("üëë You are truly terrific!"), 2000);
                             
                             // DRAMATIC SOUND AND VISUAL EFFECTS
                             explosionSynth.triggerAttackRelease("8n");
                             powerUpActivateSynth.triggerAttackRelease('A3', '2n'); // Deep victory sound
                             
                             trackEnemyDefeat(); // Track the ultimate defeat
                             console.log("DRAGON DEFEATED BY KRYPTON!");
                             break;
                         }
                     }
                 }
             }
             if (level >= 2) { // Bat gangs still appear from level 2
                 for (let i = batGangs.length - 1; i >= 0; i--) {
                     const batGang = batGangs[i];
                     const distance = playerMotorcycle.position.distanceTo(batGang.position);
                     if (!isInvincible && !isGhostActive && !isCinematicInvulnerable && !isBlasterActive && distance < 2.5) { 
                        triggerCameraShake(0.9, 400);
                        gameOver(); return; 
                     }
                 }
             }
            // Check collision with Dragon
            for (let i = dragons.length - 1; i >= 0; i--) {
                 const tieFighter = dragons[i];
                 // Get the tieFighter's head segment (first segment) for more precise collision
                 const tieFighterHead = tieFighter.userData.segments[0];
                 const tieFighterHeadPosition = tieFighterHead.getWorldPosition(new THREE.Vector3());
                 const distanceToDragon = playerMotorcycle.position.distanceTo(tieFighterHeadPosition);
                 const tieFighterPlayerCollisionThreshold = 1.5; // Reduced from 4.0/6.0 to require actual contact
                 
                 if (!isInvincible && !isCinematicInvulnerable && !isBlasterActive && distanceToDragon < tieFighterPlayerCollisionThreshold) {
                     if (isGhostActive) {
                         // Ghost Mode now only protects, doesn't destroy dragons
                         setMessage("üëª Ghost Mode protected you from the stronghold!");
                         setMessage("üí° Hint: Only Krypton can destroy strongholds!");
                         // Push dragon away but don't destroy it
                         const pushDirection = new THREE.Vector3()
                             .subVectors(tieFighter.position, playerMotorcycle.position)
                             .normalize()
                             .multiplyScalar(10);
                         tieFighter.position.add(pushDirection);
                    } else {
                        triggerCameraShake(1.5, 600);
                        gameOver();
                        return;
                    }
                 }
            }

            // Check collision with Alley Bats (Levels 65-70)
            for (let i = batAlleyBats.length - 1; i >= 0; i--) {
                const alleyBat = batAlleyBats[i];
                const distance = playerMotorcycle.position.distanceTo(alleyBat.position);
                if (!isInvincible && !isGhostActive && !isCinematicInvulnerable && !isBlasterActive && distance < 2.0) {
                    triggerCameraShake(0.8, 300);
                    gameOver(); return;
                }
            }

            // Check collision with Alley Bowling Balls (Levels 75-80)
            for (let i = bowlingBallAlleyBalls.length - 1; i >= 0; i--) {
                const alleyBall = bowlingBallAlleyBalls[i];
                const distance = playerMotorcycle.position.distanceTo(alleyBall.position);
                if (!isInvincible && !isGhostActive && !isCinematicInvulnerable && !isBlasterActive && distance < 2.0) {
                    triggerCameraShake(1.0, 400);
                    gameOver(); return;
                }
            }

            // Check collision with Final Bat (Level 85) - Only DISCO power can defeat it
            for (let i = finalBats.length - 1; i >= 0; i--) {
                const finalBat = finalBats[i];
                const distance = playerMotorcycle.position.distanceTo(finalBat.position);
                
                // Collision with player = game over (VIBES protects during blast)
                if (!isInvincible && !isGhostActive && !isCinematicInvulnerable && !isBlasterActive && distance < 2.5) {
                    triggerCameraShake(1.5, 500);
                    gameOver(); return;
                }
            }


            // Update burst particles life and opacity
            for (let i = activeBursts.length - 1; i >= 0; i--) {
                const burstParticle = activeBursts[i];
                burstParticle.userData.life++;
                const progress = burstParticle.userData.life / burstParticle.userData.maxLife;

                // Handle different particle types
                if (burstParticle.userData.isVoidCore) {
                    // Void core pulsing effect
                    const pulseFactor = Math.sin(burstParticle.userData.life * 0.1) * 0.3 + 1;
                    burstParticle.scale.setScalar(pulseFactor);
                    burstParticle.material.opacity = 0.9 * (1 - progress);
                } else if (burstParticle.userData.isRing) {
                    // Expanding ring effect
                    const expandSpeed = burstParticle.userData.expandSpeed || 0.15;
                    burstParticle.scale.setScalar(1 + burstParticle.userData.life * expandSpeed);
                    burstParticle.material.opacity = 0.8 * (1 - progress);
                    burstParticle.rotation.z += 0.05;
                } else if (burstParticle.userData.rotationSpeed !== undefined) {
                    // Wormhole particles with spiral movement
                    if (burstParticle.userData.velocity) {
                        burstParticle.position.add(burstParticle.userData.velocity);
                    }
                    burstParticle.rotation.x += burstParticle.userData.rotationSpeed;
                    burstParticle.rotation.y += burstParticle.userData.rotationSpeed * 0.7;
                    
                    // Fade particles as they spiral inward
                    burstParticle.material.opacity = 0.8 * (1 - progress);
                    
                    // Slight scale reduction as they approach center
                    burstParticle.scale.setScalar(1 - progress * 0.3);
                } else if (burstParticle.userData.velocity) {
                    // Standard particles (coin bursts, explosions, etc.) - FIXED: check velocity exists
                    burstParticle.position.add(burstParticle.userData.velocity);
                    burstParticle.userData.velocity.multiplyScalar(0.98); // Add some drag for better effect
                    
                    // Keep particles visible longer, fade only near the end
                    burstParticle.material.opacity = progress < 0.7 ? 1.0 : 1.0 - ((progress - 0.7) / 0.3);
                    const scale = (1 - progress) * 1.5; // Start at 1.5 and shrink to 0
                    burstParticle.scale.set(scale, scale, scale);
                    
                    // Add slight rotation for more visual appeal
                    burstParticle.rotation.x += 0.1;
                    burstParticle.rotation.y += 0.1;
                    burstParticle.rotation.z += 0.1;
                }

                if (progress >= 1) {
                    scene.remove(burstParticle);
                    if (burstParticle.userData && burstParticle.userData.fromMaterialPool) {
                        returnToPool('particles', burstParticle);
                    } else if (burstParticle.userData.isExplosion || burstParticle.userData.isVoidCore || burstParticle.userData.rotationSpeed !== undefined || burstParticle.userData.isRing) {
                        if (burstParticle.material) burstParticle.material.dispose();
                        if (burstParticle.geometry && !burstParticle.userData?.sharedGeometry) burstParticle.geometry.dispose();
                    } else {
                        returnToPool('particles', burstParticle);
                    }
                    activeBursts.splice(i, 1);
                }
            }


            dialogueTimer++;
            if (dialogueTimer >= dialogueInterval) { showRandomDialogue(); dialogueTimer = 0; }
            lightningTimer++;
            if (lightningTimer >= lightningInterval) { createLightningStrike(); lightningTimer = 0; }

            // Add this line after other particle updates
            updateBoostParticles();
            
            updateDiscoGlow();
            if (typeof currentMoveSpeed !== 'undefined') {
                updateEngineSound();
                if (level < 10) {
                    if (typeof window._speedLineFrameCount === 'undefined') window._speedLineFrameCount = 0;
                    window._speedLineFrameCount++;
                    if (window._speedLineFrameCount % 5 === 0) createSpeedLines();
                }
            }
            
            // Update session stats
            if (isGameRunning && !isGameOver && !gamePaused) {
                updateSessionStats();
            }
            
            // Update EMC trails
            for (let i = etherTrails.length - 1; i >= 0; i--) {
                const trail = etherTrails[i];
                trail.position.add(trail.userData.velocity);
                trail.userData.life++;
                const progress = trail.userData.life / trail.userData.maxLife;
                trail.material.opacity = 0.7 * (1 - progress);
                
                if (progress >= 1) {
                    scene.remove(trail);
                    if (trail.geometry) trail.geometry.dispose();
                    if (trail.material) trail.material.dispose();
                    etherTrails.splice(i, 1);
                }
            }
            
            for (let i = speedLines.length - 1; i >= 0; i--) {
                const line = speedLines[i];
                line.position.z += line.userData.speed;
                if (line.position.z > playerMotorcycle.position.z + 20) {
                    scene.remove(line);
                    if (line.geometry) line.geometry.dispose();
                    if (line.material) line.material.dispose();
                    speedLines.splice(i, 1);
                }
            }

            updateMeteors();

            // Update all new systems
            updateWeather();
            // updateFloatingQuotes(); // Disabled to prevent errors
            updateCinematicCamera();
            
            if (level < 10 && isBoosting) {
                if (typeof window._trailFrameCount === 'undefined') window._trailFrameCount = 0;
                window._trailFrameCount++;
                if (window._trailFrameCount % 4 === 0 && Math.random() < 0.4) createTrailEffect(customization.currentTrail);
            }

            // Update camera only if not in cinematic mode
            if (!cinematicCamera.active) {
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // 80% MINECRAFT CAMERA - Player 40% smaller (camera pulled back)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // Pulled back to make player appear 40% smaller + 15% more separation
                const cameraHeight = 2.1; // Higher for better view
                const cameraDistance = 3.8; // 15% further back from rider (was 3.3, now 3.8)
                const cameraOffset = new THREE.Vector3(0, cameraHeight, cameraDistance);
                const rotatedOffset = cameraOffset.applyQuaternion(playerMotorcycle.quaternion);
                camera.position.copy(playerMotorcycle.position).add(rotatedOffset);
                
                // Look ahead for immersion
                const lookAheadDistance = 6; // Look further ahead
                const lookAhead = new THREE.Vector3(0, 0, -lookAheadDistance);
                const lookAheadRotated = lookAhead.applyQuaternion(playerMotorcycle.quaternion);
                const lookTarget = playerMotorcycle.position.clone().add(lookAheadRotated);
                lookTarget.y += 0.2; // Slight upward angle
                camera.lookAt(lookTarget);
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // MINECRAFT FOV - Standard field of view
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const minecraftFOV = 70; // Standard Minecraft FOV
                camera.fov = minecraftFOV;
                camera.updateProjectionMatrix();
                
                // Apply camera shake if active
                                  if (cameraShake.active) {
                      updateCameraShake();
                  }
                  
                  // Update lens flares every frame
                  updateLensFlares();
            }

            renderer.render(scene, camera);
        }

        function gameOver() {
            console.log("üéØ GAME OVER TRIGGERED - stopping all systems");
            console.log("üéØ gameOver() called at:", new Date().toISOString());
            console.trace("üéØ Game Over call stack:");
            isGameOver = true; 
            isGameRunning = false; 
            gamePaused = true;
            
            // Force stop animation loop
            if (window.animationFrameId) {
                cancelAnimationFrame(window.animationFrameId);
                window.animationFrameId = null;
            }
            
            // Stop all continuous audio when game ends
            stopAllEnhancedAudio();
            
            // Calculate final session stats
            sessionStats.sessionTime = getAdjustedTime() - sessionStats.startTime;
            
            if (jackpotTimer) {
                clearInterval(jackpotTimer);
                jackpotTimer = null;
            }
            if (cleanupPowerUpsInterval) { clearInterval(cleanupPowerUpsInterval); cleanupPowerUpsInterval = null; }
            if (cleanupSceneInterval) { clearInterval(cleanupSceneInterval); cleanupSceneInterval = null; }
            if (memoryMonitorInterval) { clearInterval(memoryMonitorInterval); memoryMonitorInterval = null; }
            if (aggressiveCleanupInterval) { clearInterval(aggressiveCleanupInterval); aggressiveCleanupInterval = null; }
            if (sceneObjectLimiterInterval) { clearInterval(sceneObjectLimiterInterval); sceneObjectLimiterInterval = null; }
            
            // Add SOL LOST when game ends (lose current jackpot amount)
            addSolLost(jackpotAmount);

            // boostSound.pause();
            // boostSound.currentTime = 0;
            
            setGameUIVisibility(false);
            gameCanvas.style.display = 'none';
            gameFooter.style.display = 'none';
            
                    // Populate the unified CYPHES STATS directly
        console.log("üî• About to populate CYPHES STATS...");
        populateMissionStats();
        console.log("üî• CYPHES STATS populated, checking display...");
            
            // Save mission to Firebase leaderboard
            if (window.saveMissionToLeaderboard && window.firebaseLeaderboardReady()) {
                const missionData = {
                    etherCollected: sessionStats.etherCollected,
                    enemiesDefeated: sessionStats.enemiesDefeated,
                    distanceTraveled: sessionStats.distanceTraveled,
                    maxSpeed: sessionStats.maxSpeed,
                    sessionTime: sessionStats.sessionTime,
                    hyperspaceJumps: sessionStats.hyperspaceJumps,
                    powerUpsUsed: sessionStats.powerUpsUsed,
                    finalScore: score,
                    levelReached: level
                };
                window.saveMissionToLeaderboard(missionData);
            }
            
            // Update global SWAG score for CYPHES liberation
            if (window.updateGlobalScore) {
                window.updateGlobalScore(score);
            }
            
            finalScoreDisplay.textContent = 'Final Coins: ' + score;
            finalLevelDisplay.textContent = 'ICEBERG Reached: ' + level;
            
            // Check if this score deserves the name input modal
            if (leaderboard.shouldShowNameInput(score)) {
                // Delay showing high score modal to let game over screen appear first
                setTimeout(() => {
                    showHighScoreModal(score, level);
                }, 1000);
            } else if (leaderboard.isHighScore(score)) {
                // Score made the leaderboard and we have the player's name
                // Save automatically with their stored name
                const playerData = {
                    name: playerName || 'Anonymous',
                    score: score,
                    level: level,
                    playtime: calculatePlaytime(),
                    enemiesDefeated: totalEnemiesDefeated,
                    discosFired: totalDiscoProjectiles
                };
                leaderboard.saveScore(playerData);
                
                const rank = leaderboard.getRank(score);
                if (playerName) {
                    setTimeout(() => {
                        if (rank === 1) {
                                        setMessage(`üèÜ NEW HIGH SCORE! ${playerName} is #1 with ${score} EMC!`);
        } else {
            setMessage(`üéØ Great run, ${playerName}! Rank #${rank} with ${score} EMC!`);
                        }
                    }, 1500);
                } else {
                    setTimeout(() => {
                        setMessage(`üéØ Rank #${rank} achieved! Check Hall of Fame to see standings.`);
                    }, 1500);
                }
            }
            
            console.log("üì∫ About to show game over screen...");
            gameOverScreen.style.display = 'flex';
            console.log("üì∫ Game over screen display set to 'flex'");
            dialogueBox.style.display = 'none';
            levelUpPopup.style.display = 'none';
            lightningFlashElement.style.display = 'none';
            crashPosition.copy(playerMotorcycle.position);
            if (crashNoise) { try { crashNoise.triggerAttackRelease("2n", Tone.now(), 0.5); } catch (_) {} }
        }

        function restartGame() {
            console.log("=== RESTART GAME FUNCTION CALLED ===");
            console.log("Current game state - isGameOver:", isGameOver, "isGameRunning:", isGameRunning);
            
            // CRITICAL: FIRST - Hide all screens and show game immediately
            const startScreenEl = document.getElementById('start-screen');
            const gameOverScreenEl = document.getElementById('game-over-screen');
            
            if (startScreenEl) {
                startScreenEl.style.display = 'none';
                startScreenEl.style.visibility = 'hidden';
            }
            if (gameOverScreenEl) {
                gameOverScreenEl.style.display = 'none';
            }
            
            // Show game canvas immediately
            gameCanvas.style.display = 'block';
            gameCanvas.style.visibility = 'visible';
            gameFooter.style.display = 'flex';
            
            // Force set states immediately to prevent conflicts
            console.log("Forcing game states...");
            
            // IMMEDIATE state clearing - no async operations
            isGameOver = false;
            isGameRunning = true; // Set to true immediately for proper restart
            gamePaused = false;
            
            // CRITICAL: Reset score and level FIRST to ensure proper restart
            score = 0; 
            scoreDisplay.textContent = 'Coins: ' + score;
            level = 1; 
            levelThreshold = 3; // Reduced from 5 for faster progression
            coinCombo = 0;
            lastCoinCollectionTime = 0;
            if (comboTimeout) clearTimeout(comboTimeout);
            if (comboDisplay) comboDisplay.classList.remove('active');
            brakesUsed = false;
            baseMoveSpeed = initialBaseMoveSpeed;
            moveSpeed = baseMoveSpeed;
            // Reset smooth movement variables
            targetMoveSpeed = baseMoveSpeed;
            smoothedMoveSpeed = baseMoveSpeed;
            currentMoveSpeed = baseMoveSpeed; 
            levelDisplay.textContent = 'ICEBERG: ' + level;
            console.log("üéÆ RESET TO LEVEL 1 - Score: " + score + ", Level: " + level);
            
            // Add brief immunity period to prevent immediate collision
            isInvincible = true;
            console.log("üõ°Ô∏è Restart immunity activated for 3 seconds");
            setTimeout(() => {
                isInvincible = false;
                console.log("üõ°Ô∏è Restart immunity ended");
            }, 3000); // 3 second immunity period
            
            // Force stop all animation loops
            if (window.animationFrameId) {
                cancelAnimationFrame(window.animationFrameId);
                window.animationFrameId = null;
            }
            
            // Clear crash effects immediately
            crashPosition.set(0, 0, 0);
            
            // Force reset all display states - ENSURE clean transition
            gameOverScreenEl.style.display = 'none';
            startScreenEl.style.display = 'none';
            gameCanvas.style.display = 'block';
            gameFooter.style.display = 'flex';
            
            // Make sure we DON'T show the start screen
            const startScreenElement = document.getElementById('start-screen');
            if (startScreenElement) startScreenElement.style.display = 'none';
            
            // Reset camera position BEFORE starting game to prevent collision screen
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);
            
            setGameUIVisibility(true);
            
            // Clear any pending timers that might interfere
            if (invincibilityTimer) { clearTimeout(invincibilityTimer); invincibilityTimer = null; }
            if (ghostTimer) { clearTimeout(ghostTimer); ghostTimer = null; }
            if (magnetTimer) { clearTimeout(magnetTimer); magnetTimer = null; }
            if (slowTimeTimer) { clearTimeout(slowTimeTimer); slowTimeTimer = null; }
            if (goldCoinSlowMoTimer) { clearTimeout(goldCoinSlowMoTimer); goldCoinSlowMoTimer = null; }
            if (miniBoostTimer) { clearTimeout(miniBoostTimer); miniBoostTimer = null; }
            resetSessionStats(); // Reset session statistics
            
            // Reset leaderboard tracking variables
            totalEnemiesDefeated = 0;
            totalDiscoProjectiles = 0;
            
            // Reset pause timing for new game
            pauseStartTime = 0;
            totalPausedTime = 0;
            sessionStartTime = Date.now(); // Use actual time for new session
            lastLeaderboardCheck = 0;
            
            // Clear any existing animation frame
            if (window.animationFrameId) {
                cancelAnimationFrame(window.animationFrameId);
                window.animationFrameId = null;
            }
            
            updateMobileControlVisibility(); updatePowerUpDisplay();

            isFirstLaunch = false;
            customization.currentTrail = 'default';
            updateSettingsDisplay();

            // boostSound.pause();
            // boostSound.currentTime = 0;

            // Score and level reset moved to beginning of function
            
            // Reset jackpot system on restart
            jackpotAmount = 1.06; // Reset to initial value
            if (jackpotTimer) clearInterval(jackpotTimer); // Clear existing timer
            updateJackpotDisplay(); // Update display immediately
            startJackpotTimer(); // Restart the timer
            
            // Ensure permanent mountains persist through restarts
            if (!permanentMountainsGroup || !scene.getObjectByName('permanentMountains')) {
                permanentMountainsGroup = new THREE.Group();
                permanentMountainsGroup.name = 'permanentMountains';
                scene.add(permanentMountainsGroup);
                createSnowMountains(); // Recreate if missing
            }
            
            // Reset SOL LOST on restart
            resetSolLost();

            coinsForPowerUp = 0; isInvincible = false;
            if (invincibilityTimer) clearTimeout(invincibilityTimer); invincibilityTimer = null;

            isGhostActive = false; if (ghostTimer) clearTimeout(ghostTimer); ghostTimer = null;
            ghostPulsePhase = 0; // Reset ghost pulse
            isBlasterActive = false; // Reset blaster state
            
            // CRITICAL: Reset ALL emissive to 0 - no swirl/shield aura
            if (playerMotorcycle) {
                playerMotorcycle.traverse(child => {
                    if (child.material && !child.isLight) {
                        child.material.emissiveIntensity = 0.0;
                        if (child.material.emissive) {
                            child.material.emissive.setHex(0x000000);
                        }
                    }
                });
            }
            if (playerRiderBody && playerRiderBody.material) {
                playerRiderBody.material.emissiveIntensity = 0.0;
                if (playerRiderBody.material.emissive) {
                    playerRiderBody.material.emissive.setHex(0x000000);
                }
            }
            if (playerRiderHead && playerRiderHead.material) {
                playerRiderHead.material.emissiveIntensity = 0.0;
                if (playerRiderHead.material.emissive) {
                    playerRiderHead.material.emissive.setHex(0x000000);
                }
            }
            
            // Restore original materials if game ended with shield on
            if (playerRiderBody && originalRiderMaterials.body) {
                playerRiderBody.material = originalRiderMaterials.body;
                if (playerRiderBody.material) {
                    playerRiderBody.material.emissiveIntensity = 0.0;
                    if (playerRiderBody.material.emissive) {
                        playerRiderBody.material.emissive.setHex(0x000000);
                    }
                }
            }
            if (playerRiderHead && originalRiderMaterials.head) {
                playerRiderHead.material = originalRiderMaterials.head;
                if (playerRiderHead.material) {
                    playerRiderHead.material.emissiveIntensity = 0.0;
                    if (playerRiderHead.material.emissive) {
                        playerRiderHead.material.emissive.setHex(0x000000);
                    }
                }
            }

            // CRITICAL: Force reset magnet/radioactive state FIRST
            isMagnetActive = false; 
            if (magnetTimer) {
                clearTimeout(magnetTimer); 
                magnetTimer = null;
            }
            
            // CRITICAL: Immediately reset any radioactive materials that might be stuck
            if (playerRiderBody && playerRiderBody.material) {
                // Check if material is the radioactive material (white color)
                if (playerRiderBody.material.color && playerRiderBody.material.color.getHex() === 0xffffff) {
                    // Force reset to original or default
                    if (originalRiderMaterials.body) {
                        playerRiderBody.material = originalRiderMaterials.body;
                    } else {
                        // ice.html default (white body)
                        playerRiderBody.material = new THREE.MeshStandardMaterial({
                            color: 0xf5f5f5,
                            metalness: 0.3,
                            roughness: 0.7,
                            emissive: 0x000000,
                            emissiveIntensity: 0.0
                        });
                    }
                }
                // Always ensure emissive is 0
                playerRiderBody.material.emissiveIntensity = 0.0;
                if (playerRiderBody.material.emissive) {
                    playerRiderBody.material.emissive.setHex(0x000000);
                }
            }
            if (playerRiderHead && playerRiderHead.material) {
                // Check if material is the radioactive material (white color)
                if (playerRiderHead.material.color && playerRiderHead.material.color.getHex() === 0xffffff) {
                    // Force reset to original or default
                    if (originalRiderMaterials.head) {
                        playerRiderHead.material = originalRiderMaterials.head;
                    } else {
                        // ice.html default (black head)
                        playerRiderHead.material = new THREE.MeshStandardMaterial({
                            color: 0x1a1a1a,
                            metalness: 0.3,
                            roughness: 0.7,
                            emissive: 0x000000,
                            emissiveIntensity: 0.0,
                            transparent: true,
                            opacity: 0.95
                        });
                    }
                }
                // Always ensure emissive is 0
                playerRiderHead.material.emissiveIntensity = 0.0;
                if (playerRiderHead.material.emissive) {
                    playerRiderHead.material.emissive.setHex(0x000000);
                }
            }
            
            isSlowTimeActive = false; if (slowTimeTimer) clearTimeout(slowTimeTimer); slowTimeTimer = null;
            if (goldCoinSlowMoTimer) { clearTimeout(goldCoinSlowMoTimer); goldCoinSlowMoTimer = null; }
            slowTimeFactor = 0.5;
            hasProjectile = false; hasObstacleDrop = false; hasSwapPosition = false;
            
            // CRITICAL: Reset rider materials to remove any permanent wrap/shield effect
            if (playerRiderBody && originalRiderMaterials.body) {
                playerRiderBody.material = originalRiderMaterials.body;
                if (playerRiderBody.material) {
                    playerRiderBody.material.emissiveIntensity = 0.0;
                    if (playerRiderBody.material.emissive) {
                        playerRiderBody.material.emissive.setHex(0x000000);
                    }
                }
            } else if (playerRiderBody && playerRiderBody.material) {
                // If no original material stored, just reset emissive
                playerRiderBody.material.emissiveIntensity = 0.0;
                if (playerRiderBody.material.emissive) {
                    playerRiderBody.material.emissive.setHex(0x000000);
                }
            }
            if (playerRiderHead && originalRiderMaterials.head) {
                playerRiderHead.material = originalRiderMaterials.head;
                if (playerRiderHead.material) {
                    playerRiderHead.material.emissiveIntensity = 0.0;
                    if (playerRiderHead.material.emissive) {
                        playerRiderHead.material.emissive.setHex(0x000000);
                    }
                }
            } else if (playerRiderHead && playerRiderHead.material) {
                // If no original material stored, just reset emissive
                playerRiderHead.material.emissiveIntensity = 0.0;
                if (playerRiderHead.material.emissive) {
                    playerRiderHead.material.emissive.setHex(0x000000);
                }
            }
            
            updatePowerUpDisplay();

            baseMoveSpeed = initialBaseMoveSpeed; moveSpeed = baseMoveSpeed; isBoosting = false;
            manualBoostsUsed = 0; // Reset manual boost counter
            isMiniBoostActive = false; // Reset boost
            if (miniBoostTimer) clearTimeout(miniBoostTimer); miniBoostTimer = null;
            updateBoostButtonDisplay(); // Update button display
            boostButton.disabled = isBoosting || gamePaused || level < BOOST_UNLOCK_LEVEL;

            // Properly dispose of all objects
            coins.forEach(coin => { scene.remove(coin); returnToPool('coins', coin); }); coins.length = 0;
            obstacles.forEach(obstacle => { scene.remove(obstacle); disposeObject(obstacle); }); obstacles.length = 0;
            bowlingBallObstacles.forEach(ball => { scene.remove(ball); disposeObject(ball); }); bowlingBallObstacles.length = 0;
            batGangs.forEach(gang => { scene.remove(gang); disposeObject(gang); }); batGangs.length = 0;
            powerUps.forEach(powerUp => { scene.remove(powerUp); disposeObject(powerUp); }); powerUps.length = 0;
            itemBoxes.forEach(itemBox => { scene.remove(itemBox); disposeObject(itemBox); }); itemBoxes.length = 0;
            greenVials.forEach(vial => { scene.remove(vial); disposeObject(vial); }); greenVials.length = 0;
            activeProjectiles.forEach(projectile => { scene.remove(projectile); disposeObject(projectile); }); activeProjectiles.length = 0;
            dragons.forEach(tieFighter => { scene.remove(tieFighter); disposeObject(tieFighter); }); dragons.length = 0;
            pepeEnemies.forEach(pepe => { scene.remove(pepe); disposeObject(pepe); }); pepeEnemies.length = 0;
            
            // NEW ALLEY SYSTEMS cleanup
            batAlleyBats.forEach(bat => { scene.remove(bat); disposeObject(bat); }); batAlleyBats.length = 0;
            bowlingBallAlleyBalls.forEach(ball => { scene.remove(ball); disposeObject(ball); }); bowlingBallAlleyBalls.length = 0;
            finalBats.forEach(bat => { scene.remove(bat); disposeObject(bat); }); finalBats.length = 0;
            activeBursts.forEach(burst => { scene.remove(burst); returnToPool('particles', burst); }); activeBursts.length = 0;
            
            // NEW GALAXY ZONE cleanup
            galaxyShips.forEach(ship => { scene.remove(ship); disposeObject(ship); }); galaxyShips.length = 0;
            galaxyProjectiles.forEach(proj => { scene.remove(proj); disposeObject(proj); }); galaxyProjectiles.length = 0;
            galaxyBombs.forEach(bomb => { scene.remove(bomb); disposeObject(bomb); }); galaxyBombs.length = 0;
            galaxyZoneActive = false;
            galaxyZoneTimer = 0;
            level40PepeSpawned = false;

             // Properly remove and recreate player motorcycle to ensure fresh state (ice.html look)
             scene.remove(playerMotorcycle);
             const ICE_BIKE_R = 0x000000, ICE_BODY_R = 0x000000, ICE_HELMET_R = 0xffb6c1;
             const playerMotorcycleParts = createMotorcycle(ICE_BIKE_R, ICE_BODY_R, true);
             const newPlayerMotorcycle = playerMotorcycleParts.motorcycle;
             playerRiderBody = playerMotorcycleParts.riderBody;
             playerRiderHead = playerMotorcycleParts.riderHead;
             if (playerRiderBody) {
                 playerRiderBody.material = new THREE.MeshStandardMaterial({
                     color: ICE_BODY_R, metalness: 0.3, roughness: 0.7, emissive: 0x000000, emissiveIntensity: 0.0
                 });
             }
             if (playerRiderHead) {
                 playerRiderHead.material = new THREE.MeshStandardMaterial({
                     color: ICE_HELMET_R, metalness: 0.3, roughness: 0.7, emissive: 0x000000, emissiveIntensity: 0.0,
                     transparent: true, opacity: 0.95
                 });
             }
             newPlayerMotorcycle.traverse((child) => {
                 if (child.isMesh && child.material && child !== playerRiderBody && child !== playerRiderHead) {
                     child.material = new THREE.MeshStandardMaterial({
                         color: ICE_BIKE_R, metalness: 0.0, roughness: 1.0, emissive: 0x000000, emissiveIntensity: 0.0
                     });
                 }
             });
             playerMotorcycle = newPlayerMotorcycle;
             playerMotorcycle.position.set(0, 0, 0);
             scene.add(playerMotorcycle);
             
             // Recreate AI motorcycles
             aiMotorcycles.forEach(aiBike => scene.remove(aiBike)); aiMotorcycles.length = 0;
             numAIMotorcycles = baseAiBikes; createInitialAIMotorcycles();
             lastCompetitorSpawnTime = Date.now();
             lastObstacleClusterTime = 0;
             obstacleClusterCooldown = 0;

            // Reset road segments to initial state
            currentRoadTextureIndex = 0;
            roadSegments.forEach(segment => {
                segment.material = sharedRoadMaterials[currentRoadTextureIndex];
            });
            lastSceneryChangeZ = playerMotorcycle.position.z;

            playerRandomSteerDirection = 0; playerRandomSteerTimer = 0;
            dialogueTimer = 0; lightningTimer = 0;
            lightningLight.intensity = 0; lightningFlashElement.style.display = 'none';
            obstacleSpeedMultiplier = 1.5;
            updateRiderAppearance(1); // Re-apply outfit (index main character when default)
            isJumping = false; jumpVelocity = 0;

            // Reset starfield to initial relative position (if a starfield object exists)
            if (typeof stars !== 'undefined' && stars) stars.position.set(0,0,0);

            // Properly dispose boost particles on restart (same 5 as AAA - prevent leak)
            boostParticles.forEach(particle => {
                scene.remove(particle);
                if (particle.material) particle.material.dispose();
            });
            boostParticles.length = 0;
            
            // NEW: Clean up enhancement effects
            etherTrails.forEach(trail => {
                scene.remove(trail);
                if (trail.geometry) trail.geometry.dispose();
                if (trail.material) trail.material.dispose();
            });
            etherTrails.length = 0;
            speedLines.forEach(line => {
                scene.remove(line);
                if (line.geometry) line.geometry.dispose();
                if (line.material) line.material.dispose();
            });
            speedLines.length = 0;
            meteors.forEach(meteor => {
                meteor.traverse((c) => { if (c.geometry) c.geometry.dispose(); if (c.material) c.material.dispose(); });
                scene.remove(meteor);
            });
            meteors.length = 0;
            hyperspaceActive = false;
            forcePowerActive = false;
            
            // Clean up audio systems properly
            stopAllEnhancedAudio(); // Use comprehensive cleanup function
            
                         // Restart enhanced audio systems after cleanup (only if enabled)
             setTimeout(() => {
                 if (isGameRunning && audioSystemEnabled) {
                     try {
                         startEngineSynth();
                         startAmbientMusic();
                     } catch(e) {
                         console.log("Enhanced audio restart after cleanup:", e);
                     }
                 }
             }, 100);
             
            // Particle system disabled - no background updates needed
             
            // Ensure complete UI reset
            document.getElementById('dialogue-box').textContent = '';
            document.getElementById('dialogue-box').style.display = 'none';
            
            // Finally confirm game running and start animation
            console.log("Confirming game running and starting animation loop...");
            isGameRunning = true;
            isGameOver = false;
            
            // Force render one clean frame to establish proper view
            renderer.render(scene, camera);
            
            // Clear any residual message displays
            const dialogueBox = document.getElementById('dialogue-box');
            if (dialogueBox) {
                dialogueBox.textContent = '';
                dialogueBox.style.display = 'none';
            }
            
            // Reset all visual elements to ensure clean start - STAY IN GAME
            const startScreenRestart = document.getElementById('start-screen');
            const gameOverScreenRestart = document.getElementById('game-over-screen');
            if (startScreenRestart) startScreenRestart.style.display = 'none';
            if (gameOverScreenRestart) gameOverScreenRestart.style.display = 'none';
            
            // Ensure game canvas is visible and properly sized - KEEP PLAYING
            gameCanvas.style.display = 'block';
            gameCanvas.style.visibility = 'visible';
            
            // Ensure UI stays visible for continued gameplay
            setGameUIVisibility(true);
            
            // Force a complete re-render to clear any residual graphics
            renderer.clear();
            renderer.render(scene, camera);
            
            if (cleanupPowerUpsInterval) clearInterval(cleanupPowerUpsInterval);
            if (cleanupSceneInterval) clearInterval(cleanupSceneInterval);
            if (memoryMonitorInterval) clearInterval(memoryMonitorInterval);
            if (aggressiveCleanupInterval) clearInterval(aggressiveCleanupInterval);
            if (sceneObjectLimiterInterval) clearInterval(sceneObjectLimiterInterval);
            
            cleanupPowerUpsInterval = setInterval(cleanupPowerUps, 8000);
            cleanupSceneInterval = setInterval(cleanupScene, 20000);
            memoryMonitorInterval = setInterval(monitorPerformance, 15000);
            aggressiveCleanupInterval = setInterval(aggressiveCleanup, 20000);
            sceneObjectLimiterInterval = setInterval(() => {
                if (!isGameRunning || gamePaused) return;
                const maxSceneObjects = 500;
                if (scene.children.length > maxSceneObjects) {
                    aggressiveCleanup();
                    if (scene.children.length > maxSceneObjects + 100) forceCleanup();
                }
            }, 10000);
            
            // Start animation immediately - DIRECT RESTART, NO HOME SCREEN
            console.log("Starting fresh animation loop immediately - staying in game...");
            
            // EXTRA SAFEGUARD: Verify states before starting animation
            if (isGameOver || !isGameRunning) {
                console.log("WARNING: Game states not properly set - forcing correct states");
                isGameOver = false;
                isGameRunning = true;
                gamePaused = false;
            }
            
            // CRITICAL: Only start animation if not already running
            if (!window.animationFrameId) {
                window.animationFrameId = requestAnimationFrame(animate);
            }
            
            // MULTIPLE SAFEGUARDS: Ensure start screen stays hidden after restart
            setTimeout(() => {
                const startScreenCheck = document.getElementById('start-screen');
                const gameOverScreenCheck = document.getElementById('game-over-screen');
                
                if (startScreenCheck && startScreenCheck.style.display !== 'none') {
                    console.log("WARNING: Start screen was visible after restart - forcing hide");
                    startScreenCheck.style.display = 'none';
                    startScreenCheck.style.visibility = 'hidden';
                }
                if (gameOverScreenCheck && gameOverScreenCheck.style.display !== 'none') {
                    console.log("WARNING: Game over screen was visible after restart - forcing hide");
                    gameOverScreenCheck.style.display = 'none';
                }
                
                // Ensure game UI is visible
                setGameUIVisibility(true);
                gameCanvas.style.display = 'block';
                gameCanvas.style.visibility = 'visible';
                gameFooter.style.display = 'flex';
                
                // Final state verification
                if (!isGameRunning || isGameOver) {
                    console.log("CRITICAL: Game states corrupted after restart - forcing fix");
                    isGameOver = false;
                    isGameRunning = true;
                    gamePaused = false;
                }
            }, 50);
            
            // Additional safeguard at 200ms
            setTimeout(() => {
                const startScreenFinal = document.getElementById('start-screen');
                if (startScreenFinal && startScreenFinal.style.display !== 'none') {
                    console.log("FINAL WARNING: Start screen still visible - ultimate force hide");
                    startScreenFinal.style.display = 'none';
                    startScreenFinal.style.visibility = 'hidden';
                }
            }, 200);
            
            console.log("=== RESTART COMPLETE - GAME SHOULD BE RUNNING ===");
        }



        function activateBoost(duration = 3000, isManualBoost = false, forceBoost = false) {
            // Calculate available manual boosts based on level (1 per every 10 levels)
            const maxManualBoosts = Math.floor((level - 1) / 10) + 1;
            
            // Check if manual boost is allowed
            if (isManualBoost && manualBoostsUsed >= maxManualBoosts) {
                setMessage(`‚ö° Manual boosts limited! ${manualBoostsUsed}/${maxManualBoosts} used. Next boost at level ${Math.ceil(level / 10) * 10 + 1}!`);
                return;
            }
            
            if (forceBoost || (!isBoosting && isGameRunning && !gamePaused && level >= BOOST_UNLOCK_LEVEL)) {
                isBoosting = true;
                boostButton.disabled = true;
                // boostSound.play().catch(e => console.error("Error playing boost sound:", e));
                
                // Increment manual boost counter if this is a manual boost
                if (isManualBoost) {
                    manualBoostsUsed++;
                    setMessage(`‚ö° Manual Boost ${manualBoostsUsed}/${maxManualBoosts} used!`);
                    updateBoostButtonDisplay(); // Update button display
                }
                
                // Boost light removed - no shield/aura effect
                
                setTimeout(() => {
                    isBoosting = false;
                    if (!gamePaused && level >= BOOST_UNLOCK_LEVEL) boostButton.disabled = false;
                    if (isFirstLaunch) {
                        isFirstLaunch = false;
                        customization.currentTrail = 'default';
                        updateSettingsDisplay();
                    }
                }, duration);
            }
        }

        boostButton.addEventListener('click', () => activateBoost(3000, true)); // Manual boost
        
        // Function to update boost button display with remaining boosts
        function updateBoostButtonDisplay() {
            if (level >= BOOST_UNLOCK_LEVEL) {
                const maxManualBoosts = Math.floor((level - 1) / 10) + 1;
                const remainingBoosts = maxManualBoosts - manualBoostsUsed;
                boostButton.textContent = `BLAST (${remainingBoosts}/${maxManualBoosts})`;
            } else {
                boostButton.textContent = 'BLAST';
            }
        }

        // Blaster Bolt system
        function activateBlasterBolt() {
            // Calculate available blaster bolts based on level (1 per every 10 levels)
            const maxBlasterBolts = Math.floor(level / 10);
            
            // Check if blaster bolt is available
            if (maxBlasterBolts === 0) {
                setMessage(`üéµ VIBES unlocks at level 10!`);
                return;
            }
            
            if (blasterBoltsUsed >= maxBlasterBolts) {
                setMessage(`üéµ VIBES limited! ${blasterBoltsUsed}/${maxBlasterBolts} used. Next at level ${Math.ceil((level + 1) / 10) * 10}!`);
                return;
            }
            
            if (!isBlasterActive && isGameRunning && !gamePaused) {
                isBlasterActive = true;
                blasterBoltsUsed++;
                blasterButton.disabled = true;
                
                setMessage(`üéµ VIBES ${blasterBoltsUsed}/${maxBlasterBolts} activated!`);
                updateBlasterButtonDisplay();
                
                // Create blue plasma ball from helmet
                createBlasterBolt();
                
                // Play sound effect
                if (audioSystemEnabled) {
                    projectileSynth.triggerAttackRelease("G4", "0.2");
                }
                
                setTimeout(() => {
                    deactivateBlasterBolt();
                }, blasterDuration);
            }
        }

        function createBlasterBolt() {
            // Store original rider materials before changing them
            if (playerRiderBody && playerRiderBody.material) {
                originalRiderMaterials.blasterBody = playerRiderBody.material.clone();
            }
            if (playerRiderHead && playerRiderHead.material) {
                originalRiderMaterials.blasterHead = playerRiderHead.material.clone();
            }
            
            // Create bright blue pulsating material for rider
            const blasterMaterial = new THREE.MeshStandardMaterial({
                color: 0x0066ff,
                emissive: 0x0033ff,
                emissiveIntensity: 2.0,
                metalness: 0.3,
                roughness: 0.2,
                transparent: true,
                opacity: 0.9
            });
            
            // Apply blue material to rider body and head
            if (playerRiderBody) {
                playerRiderBody.material = blasterMaterial.clone();
            }
            if (playerRiderHead) {
                playerRiderHead.material = blasterMaterial.clone();
            }
            
            // Add pulsing effect to rider (only when blaster is active)
            let pulseRiderId = null;
            const pulseRider = () => {
                if (isBlasterActive && playerRiderBody && playerRiderHead) {
                    const pulseIntensity = 2.0 + Math.sin(Date.now() * 0.015) * 1.0;
                    const pulseOpacity = 0.9 + Math.sin(Date.now() * 0.012) * 0.1;
                    
                    if (playerRiderBody.material.emissiveIntensity !== undefined) {
                        playerRiderBody.material.emissiveIntensity = pulseIntensity;
                        playerRiderBody.material.opacity = pulseOpacity;
                    }
                    if (playerRiderHead.material.emissiveIntensity !== undefined) {
                        playerRiderHead.material.emissiveIntensity = pulseIntensity;
                        playerRiderHead.material.opacity = pulseOpacity;
                    }
                    
                    pulseRiderId = requestAnimationFrame(pulseRider);
                } else {
                    // Reset emissive to 0 when blaster is not active
                    if (playerRiderBody && playerRiderBody.material) {
                        playerRiderBody.material.emissiveIntensity = 0.0;
                    }
                    if (playerRiderHead && playerRiderHead.material) {
                        playerRiderHead.material.emissiveIntensity = 0.0;
                    }
                }
            };
            pulseRider();
        }

        function deactivateBlasterBolt() {
            isBlasterActive = false;
            
            // CRITICAL: Reset all emissive to 0 - no glow
            if (playerRiderBody && playerRiderBody.material) {
                playerRiderBody.material.emissiveIntensity = 0.0;
                playerRiderBody.material.emissive.setHex(0x000000);
            }
            if (playerRiderHead && playerRiderHead.material) {
                playerRiderHead.material.emissiveIntensity = 0.0;
                playerRiderHead.material.emissive.setHex(0x000000);
            }
            
            // Restore original rider materials
            if (playerRiderBody && originalRiderMaterials.blasterBody) {
                playerRiderBody.material = originalRiderMaterials.blasterBody;
                originalRiderMaterials.blasterBody = null;
                // Ensure restored material also has no emissive
                if (playerRiderBody.material) {
                    playerRiderBody.material.emissiveIntensity = 0.0;
                    playerRiderBody.material.emissive.setHex(0x000000);
                }
            }
            if (playerRiderHead && originalRiderMaterials.blasterHead) {
                playerRiderHead.material = originalRiderMaterials.blasterHead;
                originalRiderMaterials.blasterHead = null;
                // Ensure restored material also has no emissive
                if (playerRiderHead.material) {
                    playerRiderHead.material.emissiveIntensity = 0.0;
                    playerRiderHead.material.emissive.setHex(0x000000);
                }
            }
            
            blasterButton.disabled = false;
            updateBlasterButtonDisplay();
        }

        function updateBlasterButtonDisplay() {
            const maxBlasterBolts = Math.floor(level / 10);
            if (maxBlasterBolts > 0) {
                const remainingBolts = maxBlasterBolts - blasterBoltsUsed;
                blasterButton.textContent = `VIBES (${remainingBolts}/${maxBlasterBolts})`;
                blasterButton.disabled = isBlasterActive || remainingBolts <= 0;
            } else {
                blasterButton.textContent = 'VIBES (Locked)';
                blasterButton.disabled = true;
            }
        }

        blasterButton.addEventListener('click', () => activateBlasterBolt());

        miniBoostButton.addEventListener('click', () => activateMiniBoost());

        // Start game immediately without countdown (match index3: resume audio first when in user-gesture stack)
        function startGameImmediately() {
            console.log("Starting game immediately...");
            // index3: resume AudioContext at top so WAGMI/intro-dismiss run in same gesture
            try {
                if (typeof Tone !== 'undefined' && Tone.context && Tone.context.state !== 'running') {
                    Tone.context.resume().then(function() { console.log("AudioContext resumed on game start"); }).catch(function(e) { console.log("AudioContext resume failed:", e); });
                }
                if (typeof Tone !== 'undefined' && Tone.start) Tone.start().catch(function(){});
            } catch (e) { console.log("Tone resume error:", e); }
            if (!isFirefox && typeof ensureGameAudio === 'function') ensureGameAudio();
            // Firefox: init audio only on first key/touch/click (never before gesture)
            function initAudioOnFirstInput() {
                if (typeof ensureGameAudio === 'function') ensureGameAudio();
                document.removeEventListener('keydown', initAudioOnFirstInput);
                document.removeEventListener('click', initAudioOnFirstInput);
                document.removeEventListener('touchstart', initAudioOnFirstInput);
            }
            document.addEventListener('keydown', initAudioOnFirstInput, { once: true });
            document.addEventListener('click', initAudioOnFirstInput, { once: true });
            document.addEventListener('touchstart', initAudioOnFirstInput, { once: true });

            // CRITICAL: Set isGameRunning FIRST before anything else
            isGameRunning = true;
            isGameOver = false;
            gamePaused = false;
            
            const startScreenEl = document.getElementById('start-screen');
            if (startScreenEl) startScreenEl.style.display = 'none';
            
            // Safety checks for functions that might not be ready
            if (typeof setGameUIVisibility === 'function') setGameUIVisibility(true);
            try { if (typeof window !== 'undefined' && window.customization) window.customization.currentTrail = 'fire'; } catch (_) {}
            if (typeof updateSettingsDisplay === 'function') updateSettingsDisplay();
            if (typeof updateMobileControlVisibility === 'function') updateMobileControlVisibility();
            // Give player a projectile at start
            hasProjectile = true;
            updatePowerUpDisplay();
            
            // Start the SOL jackpot timer
            startJackpotTimer();
            
            // Start background music
            startBackgroundMusic();
            
            // Initialize biome system (so first frame isn't white)
            applyBiome(getCurrentBiome(level));
            
            // Initialize SOL LOST display
            updateSolLostDisplay();
            
            // Initialize lens flares for neon lights
            createLensFlare(neonLight1, 80, 0xff0080); // Hot pink lens flare
            createLensFlare(neonLight2, 80, 0x00ff80); // Electric green lens flare
            createLensFlare(neonLight3, 75, 0x0080ff); // Electric blue lens flare
            createLensFlare(lightningLight, 120, 0xffffff); // Lightning lens flare
            
            // Ensure camera and player are positioned correctly
            camera.position.set(0, 5, playerMotorcycle.position.z + 10);
            camera.lookAt(playerMotorcycle.position);
            
            // Render first, then show the GAME canvas (use gameCanvas = renderer.domElement, not querySelector('canvas') which can be brain-viz)
            renderer.render(scene, camera);
            if (typeof gameCanvas !== 'undefined' && gameCanvas) {
                gameCanvas.style.display = 'block';
                gameCanvas.style.opacity = '1';
                gameCanvas.style.visibility = 'visible';
                gameCanvas.classList.add('game-ready');
            }
            console.log("Initial render completed - isGameRunning:", isGameRunning, "isGameOver:", isGameOver);
            
            // CRITICAL: Ensure animate loop is running (only if not already running)
            if (!window.animationFrameId) {
                // Cancel any existing frame first
                if (window.animationFrameId) {
                    cancelAnimationFrame(window.animationFrameId);
                }
                window.animationFrameId = requestAnimationFrame(animate);
            }
            
            // Audio systems start only when enabled by user (Press 'M' to enable)
            // Restart enhanced audio systems if enabled
            setTimeout(() => {
                if (audioSystemEnabled) {
                    try {
                        startEngineSynth();
                        startAmbientMusic();
                    } catch(e) {
                        console.log("Enhanced audio restart after game start:", e);
                    }
                }
            }, 100);
            
            resetSessionStats(); // Initialize session stats
            // Animation loop already running from page load
        }

        // BOOST system (25% speed boost, unlimited use)
        function activateMiniBoost() {
            if (!isGameRunning || gamePaused) return;
            
            // Clear any existing boost timer
            if (miniBoostTimer) {
                clearTimeout(miniBoostTimer);
            }
            
            if (!isMiniBoostActive) {
                isMiniBoostActive = true;
                setMessage("‚ö° BOOST! +25% Speed!");
                
                // Play a subtle sound effect
                if (audioSystemEnabled && coinSynth) {
                    try { coinSynth.triggerAttackRelease("C5", "0.1"); } catch (_) {}
                }
            }
            
            // Reset timer (extends boost if already active)
            miniBoostTimer = setTimeout(() => {
                isMiniBoostActive = false;
                setMessage("");
            }, 1500); // 1.5 second duration
        }

         if (isMobileDevice()) {
             steerLeftButton.addEventListener('touchstart', () => { if (!gamePaused && gameMode === 'manual') steerLeftButton.classList.add('active'); });
             steerLeftButton.addEventListener('touchend', () => { steerLeftButton.classList.remove('active'); });
             steerLeftButton.addEventListener('mousedown', () => { if (!gamePaused && gameMode === 'manual') steerLeftButton.classList.add('active'); });
             steerLeftButton.addEventListener('mouseup', () => { steerLeftButton.classList.remove('active'); });
             steerLeftButton.addEventListener('mouseleave', () => { steerLeftButton.classList.remove('active'); });
             steerRightButton.addEventListener('touchstart', () => { if (!gamePaused && gameMode === 'manual') steerRightButton.classList.add('active'); });
             steerRightButton.addEventListener('touchend', () => { steerRightButton.classList.remove('active'); });
             steerRightButton.addEventListener('mousedown', () => { if (!gamePaused && gameMode === 'manual') steerRightButton.classList.add('active'); });
             steerRightButton.addEventListener('mouseup', () => { steerRightButton.classList.remove('active'); });
             steerRightButton.addEventListener('mouseleave', () => { steerRightButton.classList.remove('active'); });
             usePowerUpButtonMobile.addEventListener('touchstart', () => { if (!gamePaused && gameMode === 'manual') usePowerUp(); });
             usePowerUpButtonMobile.addEventListener('mousedown', () => { if (!gamePaused && gameMode === 'manual') usePowerUp(); });
         }

        // Modal system
        function openModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.style.display = 'flex';
                // Close modal on outside click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        closeModal(modalId);
                    }
                });
            }
        }

        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // Menu button handlers
        document.getElementById('controls-btn').addEventListener('click', () => {
            openModal('controls-modal');
        });

        document.getElementById('difficulty-btn').addEventListener('click', () => {
            openModal('difficulty-modal');
        });

        document.getElementById('tips-btn').addEventListener('click', () => {
            openModal('tips-modal');
        });

        // Close button handlers
        document.querySelectorAll('.close-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const modalId = e.target.dataset.modal;
                closeModal(modalId);
            });
        });

        // Difficulty button handlers (updated for modal)
        document.querySelectorAll('.difficulty-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // Remove active class from all buttons
                document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                // Add active class to clicked button
                btn.classList.add('active');
                // Set difficulty
                gameDifficulty = btn.dataset.difficulty;
                // Update the display on the main screen
                document.getElementById('current-difficulty-display').textContent = difficultySettings[gameDifficulty].name;
                setMessage(`Difficulty set to: ${difficultySettings[gameDifficulty].name}`);
                // Close modal after selection
                setTimeout(() => closeModal('difficulty-modal'), 500);
            });
        });

        // ESC key to close modals
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                ['controls-modal', 'difficulty-modal', 'tips-modal', 'agent-mode-modal'].forEach(modalId => {
                    const modal = document.getElementById(modalId);
                    if (modal && modal.style.display === 'flex') {
                        closeModal(modalId);
                    }
                });
            }
        });
        
        wagmiButton.addEventListener('click', () => {
            if (window.dismissIntro) window.dismissIntro();
            try {
                if (typeof Tone !== 'undefined' && Tone.context) {
                    if (Tone.context.state !== 'running') {
                        Tone.context.resume().then(function() {
                            startGameImmediately();
                        }).catch(function() {
                            startGameImmediately();
                        });
                    } else {
                        startGameImmediately();
                    }
                } else {
                    startGameImmediately();
                }
            } catch (e) {
                startGameImmediately();
            }
        });

        planetXButton.addEventListener('click', () => {
            document.getElementById('agent-status').style.display = 'none';
            openModal('agent-mode-modal');
        });
        (function prefillAgentFromUrl() {
            const params = new URLSearchParams(window.location.search);
            const ws = params.get('agent_ws');
            if (ws && (ws.startsWith('ws://') || ws.startsWith('wss://'))) {
                const el = document.getElementById('agent-endpoint');
                if (el) el.value = ws;
            }
        })();
        function closeAgentModal() {
            const el = document.getElementById('agent-mode-modal');
            if (el) el.style.display = 'none';
        }
        async function registerAgent() {
            const agentId = (document.getElementById('agent-id') && document.getElementById('agent-id').value.trim()) || 'moltly-bot';
            const accessKey = document.getElementById('agent-key') && document.getElementById('agent-key').value;
            const endpoint = (document.getElementById('agent-endpoint') && document.getElementById('agent-endpoint').value.trim()) || 'ws://localhost:8080';
            if (!accessKey) { alert('Enter Access Key (register at POST http://localhost:8080/api/agents/register)'); return; }
            await agentController.connect(agentId, accessKey, endpoint);
        }

        // Multiple event listeners to ensure the button works
        restartButton.addEventListener('click', handleRestartClick);
        restartButton.addEventListener('touchstart', handleRestartClick);
        restartButton.addEventListener('mousedown', handleRestartClick);
        
        function handleRestartClick(e) {
            console.log("=== NEW MISSION BUTTON CLICKED ===");
            console.log("Event type:", e.type);
            
            e.preventDefault();
            e.stopPropagation();
            
            // Resume audio on user gesture (required for Firefox and mobile)
            if (typeof Tone !== 'undefined') {
                try {
                    if (Tone.start) Tone.start().catch(() => {});
                    else if (Tone.context && Tone.context.resume) Tone.context.resume().catch(() => {});
                } catch (err) {}
            }
            
            // Immediately hide all possible interfering screens
            const startScreen = document.getElementById('start-screen');
            const gameOverScreen = document.getElementById('game-over-screen');
            if (startScreen) {
                startScreen.style.display = 'none';
                startScreen.style.visibility = 'hidden';
            }
            if (gameOverScreen) {
                gameOverScreen.style.display = 'none';
            }
            
            // Defer restart to next tick so the handler returns immediately (prevents mobile freeze)
            try {
                setTimeout(() => {
                    try {
                        restartGame();
                        setTimeout(() => {
                            const startScreenCheck = document.getElementById('start-screen');
                            if (startScreenCheck && startScreenCheck.style.display !== 'none') {
                                startScreenCheck.style.display = 'none';
                                startScreenCheck.style.visibility = 'hidden';
                            }
                        }, 100);
                    } catch (err) {
                        console.error("Error during restart:", err);
                    }
                }, 0);
            } catch (error) {
                console.error("Error in New Mission handler:", error);
            }
        }


        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
             updateMobileControlVisibility();
        });




        // Add after the createStarfield function
        // Shared boost particle geometry and material to prevent memory leaks
        const sharedBoostGeometry = new THREE.OctahedronGeometry(0.13, 0);
        const sharedBoostMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff, // Electric cyan
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        });

        function createBoostParticle() {
            // Reuse shared geometry and material to prevent memory leaks
            const particle = new THREE.Mesh(sharedBoostGeometry, sharedBoostMaterial.clone());
            // Rotate to make diamond point forward
            particle.rotation.x = Math.PI / 4;
            particle.rotation.z = Math.PI / 4;
            // Add sparkle phase for animation
            particle.userData.sparklePhase = Math.random() * Math.PI * 2;
            // Add scale for dramatic effect
            particle.userData.initialScale = 0.8 + Math.random() * 0.4; // Random initial scale
            particle.scale.setScalar(particle.userData.initialScale);
            return particle;
        }

        function updateBoostParticles() {
            if (isBoosting) {
                // Reduce particle count for better performance (mobile-aware, same 5 as AAA)
                const maxBoostParticles = isMobile ? 25 : 40;
                const particlesToCreate = Math.min(isMobile ? 1 : 2, maxBoostParticles - boostParticles.length);
                
                // Create new particles only if under limit
                for (let i = 0; i < particlesToCreate; i++) {
                    const particle = createBoostParticle();
                    const offset = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.8, // Increased spread
                        (Math.random() - 0.5) * 0.8,
                        0.5
                    );
                    particle.position.copy(playerMotorcycle.position).add(offset);
                    particle.userData.life = 0;
                    particle.userData.maxLife = 20; // Reduced lifetime from 25 to 20
                    scene.add(particle);
                    boostParticles.push(particle);
                }
            }

            // Update existing particles
            for (let i = boostParticles.length - 1; i >= 0; i--) {
                const particle = boostParticles[i];
                particle.userData.life++;
                
                // More dramatic rotation
                particle.rotation.y += 0.15;
                particle.rotation.x += 0.05;
                
                // Enhanced sparkle effect
                particle.userData.sparklePhase += 0.25;
                const sparkle = Math.sin(particle.userData.sparklePhase) * 0.3 + 0.7; // More dramatic opacity variation
                particle.material.opacity = 0.6 * sparkle;
                
                // Electric blue color variation
                const blueIntensity = Math.sin(particle.userData.sparklePhase * 0.5) * 0.3 + 0.7;
                particle.material.color.setRGB(0, blueIntensity, blueIntensity);
                
                // Dramatic scaling effect
                const scale = particle.userData.initialScale * (1 - (particle.userData.life / particle.userData.maxLife));
                particle.scale.setScalar(scale);

                if (particle.userData.life >= particle.userData.maxLife) {
                    scene.remove(particle);
                    // Dispose of the cloned material to prevent memory leaks
                    particle.material.dispose();
                    boostParticles.splice(i, 1);
                }
            }
        }

        const meteors = [];
        function createMeteor() {
            const meteorGroup = new THREE.Group();
            const meteorGeometry = new THREE.ConeGeometry(0.2, 1, 8);
            const meteorMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending
            });
            const meteorBody = new THREE.Mesh(meteorGeometry, meteorMaterial);
            meteorBody.rotation.x = Math.PI / 2;
            meteorGroup.add(meteorBody);
            const trailGeometry = new THREE.BufferGeometry();
            const trailPoints = [];
            for (let i = 0; i < 10; i++) trailPoints.push(new THREE.Vector3(0, 0, i * 0.2));
            trailGeometry.setFromPoints(trailPoints);
            const trailMaterial = new THREE.LineBasicMaterial({
                color: 0x00ffff, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending
            });
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            trail.rotation.x = Math.PI / 2;
            meteorGroup.add(trail);
            meteorGroup.position.set((Math.random() - 0.5) * 100, 50 + Math.random() * 30, -100 - Math.random() * 50);
            meteorGroup.userData.velocity = new THREE.Vector3((Math.random() - 0.5) * 2, -2 - Math.random(), (Math.random() - 0.5) * 2);
            meteorGroup.userData.life = 0;
            meteorGroup.userData.maxLife = 100;
            return meteorGroup;
        }
        function updateMeteors() {
            if (level >= 10) {
                if (Math.random() < 0.05 && meteors.length < 10) {
                    const meteor = createMeteor();
                    scene.add(meteor);
                    meteors.push(meteor);
                }
                for (let i = meteors.length - 1; i >= 0; i--) {
                    const meteor = meteors[i];
                    meteor.userData.life++;
                    meteor.position.add(meteor.userData.velocity);
                    meteor.rotation.z += 0.1;
                    const progress = meteor.userData.life / meteor.userData.maxLife;
                    meteor.children.forEach(child => {
                        if (child.material) child.material.opacity = 0.8 * (1 - progress);
                    });
                    if (meteor.userData.life >= meteor.userData.maxLife ||
                        meteor.position.y < -50 || Math.abs(meteor.position.x) > 100 || Math.abs(meteor.position.z) > 100) {
                        meteor.traverse((c) => {
                            if (c.geometry) c.geometry.dispose();
                            if (c.material) c.material.dispose();
                        });
                        scene.remove(meteor);
                        meteors.splice(i, 1);
                    }
                }
            } else {
                meteors.forEach(meteor => {
                    meteor.traverse((c) => { if (c.geometry) c.geometry.dispose(); if (c.material) c.material.dispose(); });
                    scene.remove(meteor);
                });
                meteors.length = 0;
            }
        }

        // Add Solana wallet functionality
        let wallet = null;
        if (typeof window !== 'undefined') window.cyphesWallet = null;
        let connection = null;
        const WALLET_STORAGE_KEY = 'cyphes_wallet';

        async function initializeSolana() {
            try {
                // Initialize Solana connection (using public RPC with fallback)
                connection = new solanaWeb3.Connection(
                    'https://solana-api.projectserum.com',
                    'confirmed'
                );

                // Check if wallet exists in storage
                const storedWallet = localStorage.getItem(WALLET_STORAGE_KEY);
                if (storedWallet) {
                    const keypair = solanaWeb3.Keypair.fromSecretKey(
                        new Uint8Array(JSON.parse(storedWallet))
                    );
                    wallet = keypair;
                    if (typeof window !== 'undefined') window.cyphesWallet = wallet;
                } else {
                    // Create new wallet if none exists
                    wallet = solanaWeb3.Keypair.generate();
                    if (typeof window !== 'undefined') window.cyphesWallet = wallet;
                    // Store private key in localStorage
                    localStorage.setItem(
                        WALLET_STORAGE_KEY,
                        JSON.stringify(Array.from(wallet.secretKey))
                    );
                }

                // Update wallet display
                updateWalletDisplay();
            } catch (error) {
                console.error('Error initializing Solana:', error);
                document.getElementById('wallet-display').textContent = 'Wallet: Error initializing';
            }
        }

        async function updateWalletDisplay() {
            if (!wallet || !connection) return;

            try {
                const walletDisplay = document.getElementById('wallet-display');
                const walletBalance = document.getElementById('wallet-balance');

                // Display truncated wallet address as a clickable link (no underline, with (Solscan) label)
                const address = wallet.publicKey.toString();
                walletDisplay.innerHTML = `<a href="https://solscan.io/account/${address}" target="_blank" rel="noopener noreferrer" style="color: #00ff00; text-decoration: none;">Solana: ${address.slice(0, 4)}...${address.slice(-4)} <span style='font-size:0.95em;'>(Solscan)</span></a>`;

                // Get and display balance (with error handling)
                try {
                    const balance = await connection.getBalance(wallet.publicKey);
                    const solBalance = balance / solanaWeb3.LAMPORTS_PER_SOL;
                    walletBalance.textContent = `Balance: ${solBalance.toFixed(4)} SOL`;
                } catch (balanceError) {
                    console.log('Could not fetch SOL balance (RPC limit)');
                    walletBalance.textContent = `Balance: Check Solscan`;
                }

                // Update Solscan link
                const solscanLink = document.getElementById('solscan-link');
                solscanLink.href = `https://solscan.io/account/${address}`;
                solscanLink.textContent = 'View on Solscan';
            } catch (error) {
                console.error('Error updating wallet display:', error);
            }
        }

        // Update wallet display periodically (reduced frequency to avoid rate limits)
        setInterval(updateWalletDisplay, 30000); // Update every 30 seconds

        // Add these variables for jackpot functionality
        let jackpotAmount = 1.06; // Starting jackpot amount in SOL
        let jackpotUpdateInterval = 2000; // 2 seconds interval for jackpot update
        let jackpotTimer = null;
        const jackpotIncrement = 0.13; // Amount to increase jackpot by each interval
        const jackpotDisplay = document.getElementById('jackpot-amount');

        // Start jackpot timer
        function startJackpotTimer() {
            if (jackpotTimer) clearInterval(jackpotTimer);
            
            jackpotTimer = setInterval(() => {
                if (!isGameOver && isGameRunning && !gamePaused) {
                    jackpotAmount += jackpotIncrement;
                    updateJackpotDisplay();
                }
            }, jackpotUpdateInterval);
        }

        function updateJackpotDisplay() {
            if (jackpotDisplay) {
                jackpotDisplay.textContent = `Jackpot: ${jackpotAmount.toFixed(2)} SOL`;
                animateJackpot();
            }
        }

        function animateJackpot() {
            if (jackpotDisplay) {
                jackpotDisplay.classList.add('animated-pop');
                setTimeout(() => jackpotDisplay.classList.remove('animated-pop'), 300);
            }
        }

        // SOL LOST tracking functionality
        let totalSolLost = 0; // Track total SOL lost
        const solLostDisplay = document.getElementById('stat-sol-lost');
        
        // Function to add SOL lost (when player crashes/loses)
        function addSolLost(amount) {
            totalSolLost += amount;
            updateSolLostDisplay();
        }
        
        // Function to update SOL LOST display
        function updateSolLostDisplay() {
            if (solLostDisplay) {
                solLostDisplay.textContent = totalSolLost.toFixed(2);
            }
        }
        
        // Function to reset SOL LOST on game restart
        function resetSolLost() {
            totalSolLost = 0;
            updateSolLostDisplay();
        }

        // Initialize game when the page loads
        window.onload = async function () {
            await initializeSolana();
            createCityscape();
            createInitialAIMotorcycles();
            initializeWeather();
            initializeSpatialAudio();
            applySkinToMotorcycle(playerMotorcycle, customization.currentSkin);
            applyRiderOutfit(customization.currentOutfit);
            updateSettingsDisplay();
            boostButton.disabled = isBoosting || gamePaused || level < BOOST_UNLOCK_LEVEL;
            updateBoostButtonDisplay(); // Initialize button display
            blasterButton.disabled = isBlasterActive || Math.floor(level / 10) === 0;
            updateBlasterButtonDisplay(); // Initialize blaster button display
            miniBoostButton.disabled = false; // Boost is always available
            updateRiderAppearance(1);
            playerMotorcycle.position.set(0, 0, 0);
            renderer.render(scene, camera);
            setGameUIVisibility(false);
            gameCanvas.style.display = 'none';
            gameFooter.style.display = 'flex';
            // Keep landing screen (cinematic-intro) visible until user clicks Play Game (like planetx.html)
            // Do NOT hide startScreen here ‚Äì only dismissIntro() hides it when Play Game is clicked
            // Audio status display removed
            
            // DON'T start animation loop here - it will be started when user clicks Play Game (startGameImmediately)
            // animate() should only be called from startGameImmediately() or after intro dismissal
            
            console.log("Game initialization complete - isGameRunning:", isGameRunning, "isGameOver:", isGameOver);
        }



        function updateLevelDisplay() {
            levelDisplay.textContent = 'ICEBERG: ' + level;
        }

        // REBALANCED: Gentle difficulty increase at level 60 (no more spike)
        function applyExtremeDifficulty() {
            // GENTLE increase - not a dramatic spike
            obstacleSpeedMultiplier *= 1.1; // Was 1.5, now much gentler
            
            // Slight speed increase
            baseMoveSpeed *= 1.05; // Was 1.3, now barely noticeable
            moveSpeed = baseMoveSpeed;
            
            // NO LONGER reducing power-up durations - keep them fun!
            
            // NO LONGER dramatically increasing spawn rates
            // The dynamic difficulty system handles this gradually
            
            // Just show a message - no actual gameplay spike
            setMessage("‚ö° ICEBERG 60 - The adventure continues!");
            
            // Optional: Subtle AI improvement (much less aggressive)
            aiMotorcycles.forEach(aiBike => {
                aiBike.userData.steerSpeed *= 1.05; // Was 1.4
                aiBike.userData.moveSpeed *= 1.02; // Was 1.2
            });
        }



        document.getElementById('how-to-play-link').addEventListener('click', function(event) {
            event.preventDefault();
            toggleGameInstructions();
        });

        // --- JS: UI/UX POLISH ---
        // Animate score when it changes
        function animateScore() {
            scoreDisplay.classList.add('animated-pop');
            setTimeout(() => scoreDisplay.classList.remove('animated-pop'), 300);
        }
        // Animate power-up display
        function animatePowerUpDisplay(type) {
            powerUpDisplay.classList.add('animated-pulse');
            setTimeout(() => powerUpDisplay.classList.remove('animated-pulse'), 800);
            // Optionally shake on use
            if (type === 'use') {
                powerUpDisplay.classList.add('animated-shake');
                setTimeout(() => powerUpDisplay.classList.remove('animated-shake'), 300);
            }
        }
        // Button press feedback
        function addButtonPressFeedback(button) {
            button.addEventListener('mousedown', () => {
                button.style.transform = 'scale(0.92)';
            });
            button.addEventListener('mouseup', () => {
                button.style.transform = '';
            });
            button.addEventListener('mouseleave', () => {
                button.style.transform = '';
            });
            button.addEventListener('touchstart', () => {
                button.style.transform = 'scale(0.92)';
            });
            button.addEventListener('touchend', () => {
                button.style.transform = '';
            });
        }
        addButtonPressFeedback(boostButton);
        addButtonPressFeedback(blasterButton);
        addButtonPressFeedback(miniBoostButton);
        addButtonPressFeedback(usePowerUpButtonMobile);
                  // Animate score on update - function merged with optimized version above
        // Animate power-up display on activation/use
        function updatePowerUpDisplayAnimated() {
            updatePowerUpDisplay();
            animatePowerUpDisplay('activate');
        }
        // DUPLICATE FUNCTION REMOVED - usePowerUp is already defined earlier
        // Update all score/jackpot updates to use new functions
        // Replace all direct scoreDisplay.textContent and jackpotDisplay.textContent assignments with updateScoreDisplay() and updateJackpotDisplay() where appropriate.

        const weather = {
            current: 'clear',
            intensity: 0,
            stormTimer: 0,
            changeTimer: 0,
            changeInterval: 1800,
            snowGeometry: null,
            snowMaterial: null,
            snowMesh: null
        };

        // Mr. Terrific Quotes Display
        const starWarsQuotes = [
            "Fair Play prevails",
            "Technology serves justice",
            "Excellence through intellect",
            "T-Spheres activate",
            "Justice never sleeps",
            "Fair Play in all things",
            "Terrific technology deployed",
            "Intellect over brute force",
            "The terrific truth",
            "Science conquers all"
        ];
        const floatingQuotes = [];

        // Customization System
        const customization = {
            bikeTrails: ['default', 'rainbow', 'electric', 'force', 'fire'],
            currentTrail: 'fire',
            bikeSkins: ['default', 'chrome', 'neon', 'carbon', 'gold'],
            currentSkin: 'carbon',
            riderOutfits: ['index', 'penguin', 'rebel', 'jedi', 'force_user', 'pilot'],
            currentOutfit: 'index'
        };
        if (typeof window !== 'undefined') window.customization = customization;

        // Cinematic Camera System
        const cinematicCamera = {
            active: false,
            type: 'none', // 'levelUp', 'tieFighter', 'boost', 'crash'
            timer: 0,
            duration: 0,
            originalPosition: new THREE.Vector3(),
            targetPosition: new THREE.Vector3(),
            originalRotation: new THREE.Euler(),
            targetRotation: new THREE.Euler()
        };
        
        // Cinematic invulnerability flag
        let isCinematicInvulnerable = false;

        // Enhanced Audio System with 3D positioning
        const spatialAudio = {
            listener: null,
            coinSounds: [],
            engineSound: null,
            windSound: null,
            rainSound: null
        };

        // LOCAL LEADERBOARD SYSTEM
        const leaderboard = {
            maxEntries: 10,
            storageKey: 'CYPHES_leaderboard',
            
            // Save a new score to the leaderboard
            saveScore(playerData) {
                const scores = this.getScores();
                scores.push({
                    name: playerData.name || 'Anonymous',
                    score: playerData.score,
                    level: playerData.level,
                    timestamp: new Date().toISOString(),
                    playtime: playerData.playtime || '0s',
                    enemiesDefeated: playerData.enemiesDefeated || 0,
                    discosFired: playerData.discosFired || 0,
                    achievements: playerData.achievements || []
                });
                
                // Sort by score (highest first) and keep only top entries
                scores.sort((a, b) => b.score - a.score);
                const topScores = scores.slice(0, this.maxEntries);
                
                localStorage.setItem(this.storageKey, JSON.stringify(topScores));
                return topScores;
            },
            
            // Get all scores from localStorage
            getScores() {
                const stored = localStorage.getItem(this.storageKey);
                return stored ? JSON.parse(stored) : [];
            },
            
            // Check if current score qualifies for leaderboard
            isHighScore(score) {
                const scores = this.getScores();
                if (scores.length < this.maxEntries) return true;
                return score > scores[scores.length - 1].score;
            },
            
            // Check if this is truly a NEW high score (better than previous best)
            isNewHighScore(score) {
                const scores = this.getScores();
                if (scores.length === 0) return true; // First ever score
                return score > scores[0].score; // Beat the current #1 score
            },
            
            // Check if this qualifies for leaderboard AND we should show name input
            shouldShowNameInput(score) {
                const scores = this.getScores();
                
                // Don't show name input if player already provided their name
                if (playerName) return false;
                
                // Always show for first-time players (empty leaderboard)
                if (scores.length === 0) return true;
                
                // Show if leaderboard isn't full yet AND score qualifies
                if (scores.length < this.maxEntries && score > 0) return true;
                
                // Show only if this beats the lowest score on the board
                if (score > scores[scores.length - 1].score) return true;
                
                return false;
            },
            
            // Get player's rank for current score
            getRank(score) {
                const scores = this.getScores();
                let rank = 1;
                for (let i = 0; i < scores.length; i++) {
                    if (score > scores[i].score) break;
                    rank++;
                }
                return rank;
            },
            
            // Get motivational message based on current performance
            getComparisonMessage(currentScore) {
                const scores = this.getScores();
                if (scores.length === 0) return "First run! Set the bar high!";
                
                const topScore = scores[0];
                const rank = this.getRank(currentScore);
                
                if (currentScore > topScore.score) {
                    return `üî• NEW HIGH SCORE! Beating ${topScore.name}'s ${topScore.score}!`;
                } else if (rank <= 3) {
                    return `ü•â Top 3 run! Currently #${rank} on leaderboard!`;
                } else if (rank <= 5) {
                    return `‚≠ê Top 5 performance! Rank #${rank}!`;
                } else if (currentScore > topScore.score * 0.5) {
                    return `üí™ Solid run! ${Math.round((currentScore/topScore.score)*100)}% of top score!`;
                } else {
                    return `üéØ Aim for ${topScore.name}'s record: ${topScore.score} EMC!`;
                }
            },
            
            // Clear all scores (for testing/reset)
            clearScores() {
                localStorage.removeItem(this.storageKey);
            }
        };



        function showHighScoreModal(score, level) {
            // Automatically save score with "Player One" name
            const playerData = {
                name: playerName,
                score: score,
                level: level,
                playtime: calculatePlaytime(),
                enemiesDefeated: totalEnemiesDefeated,
                discosFired: totalDiscoProjectiles
            };
            
            leaderboard.saveScore(playerData);
            
            const rank = leaderboard.getRank(score);
            let rankMessage = `üéâ Score saved! You're rank #${rank}!`;
            
            if (rank === 1) {
                rankMessage = `üèÜ NEW HIGH SCORE! You're #1! üèÜ`;
            } else if (rank <= 3) {
                rankMessage = `üéâ Top 3! You're rank #${rank}! üéâ`;
            } else if (rank <= 5) {
                rankMessage = `‚≠ê Top 5! You're rank #${rank}! ‚≠ê`;
            }
            
            // Show a congratulatory message
            setMessage(rankMessage);
        }

        function calculatePlaytime() {
            const playtimeMs = getAdjustedTime() - sessionStartTime;
            const minutes = Math.floor(playtimeMs / 60000);
            const seconds = Math.floor((playtimeMs % 60000) / 1000);
            return `${minutes}m ${seconds}s`;
        }

        // Initialize 3D Audio - DISABLED to prevent errors
        function initializeSpatialAudio() {
            // Spatial audio disabled - THREE.AudioBuffer constructor issues
            // Can be re-enabled when audio system is properly configured
            console.log("Spatial audio initialization skipped to prevent errors");
        }

        // Customization Functions
        function applySkinToMotorcycle(motorcycle, skinType) {
            const skinConfigs = {
                default: { color: 0x0077ff, metalness: 0.8, roughness: 0.2, emissive: 0x003366 },
                chrome: { color: 0xcccccc, metalness: 1.0, roughness: 0.0, emissive: 0x444444 },
                neon: { color: 0x00ffff, metalness: 0.3, roughness: 0.7, emissive: 0x00ffff },
                carbon: { color: 0x222222, metalness: 0.9, roughness: 0.1, emissive: 0x111111 },
                gold: { color: 0xffd700, metalness: 0.8, roughness: 0.2, emissive: 0xffaa00 }
            };
            
            const config = skinConfigs[skinType] || skinConfigs.default;
            
            motorcycle.children.forEach(child => {
                if (child.material && child.geometry && child.geometry.type === "BoxGeometry") {
                    child.material = new THREE.MeshStandardMaterial({
                        color: config.color,
                        metalness: config.metalness,
                        roughness: config.roughness,
                        emissive: config.emissive,
                        emissiveIntensity: 0.5
                    });
                }
            });
        }

                 function createTrailEffect(trailType) {
             const trailConfigs = {
                 default: { colors: [0x0077ff], intensity: 0.5, size: 0.3 },
                 rainbow: { colors: [0xff0000, 0xff8800, 0xffff00, 0x00ff00, 0x0088ff, 0x8800ff], intensity: 0.8, size: 0.4 },
                 electric: { colors: [0x00ffff, 0xffffff], intensity: 1.0, size: 0.5 },
                 force: { colors: [0xff00ff, 0x8800ff], intensity: 0.9, size: 0.6 },
                 fire: { colors: [0xff4400, 0xff8800, 0xffff00], intensity: 0.7, size: 0.4 }
             };
             
             const config = trailConfigs[trailType] || trailConfigs.default;
             
             for (let i = 0; i < 3; i++) {
                 const trailGeometry = new THREE.SphereGeometry(config.size * 1.5, 8, 8); // 1.5x larger
                 const trailMaterial = new THREE.MeshBasicMaterial({
                     color: config.colors[i % config.colors.length],
                     transparent: true,
                     opacity: Math.min(1, config.intensity * 1.2),
                     blending: THREE.AdditiveBlending
                 });
                 
                 const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                 trail.position.set(
                     (Math.random() - 0.5) * 1.5,
                     Math.random() * 0.5,
                     1 + Math.random() * 2
                 );
                 trail.userData.life = 0;
                 trail.userData.maxLife = 30;
                 trail.userData.velocity = new THREE.Vector3(
                     (Math.random() - 0.5) * 0.1,
                     (Math.random() - 0.5) * 0.1,
                     0.5
                 );
                 playerMotorcycle.add(trail);
                 (function (t) {
                     setTimeout(function () {
                         if (t.parent) t.parent.remove(t);
                         if (t.geometry) t.geometry.dispose();
                         if (t.material) t.material.dispose();
                     }, 500);
                 })(trail);
             }
         }

         function applyRiderOutfit(outfitType) {
             const outfitConfigs = {
                 index: {
                     bodyColor: 0x000000,
                     headColor: 0xffb6c1,
                     bodyEmissive: 0x000000,
                     headEmissive: 0x000000,
                     bodyEmissiveIntensity: 0,
                     headEmissiveIntensity: 0,
                     headTransparent: true,
                     headOpacity: 0.95
                 },
                 rebel: { 
                     bodyColor: 0x000000, 
                     headColor: 0x004400, 
                     bodyEmissive: 0x000000, 
                     headEmissive: 0x00ff00,
                     bodyEmissiveIntensity: 0.1,
                     headEmissiveIntensity: 0.8,
                     headTransparent: true,
                     headOpacity: 0.7
                 },
                 jedi: { 
                     bodyColor: 0x8B4513, 
                     headColor: 0xFFE4B5, 
                     bodyEmissive: 0x654321, 
                     headEmissive: 0x00ff00,
                     bodyEmissiveIntensity: 0.2,
                     headEmissiveIntensity: 0.6,
                     headTransparent: false,
                     headOpacity: 1.0
                 },
                 futuristic: { 
                     bodyColor: 0x333333, 
                     headColor: 0x00ffff, 
                     bodyEmissive: 0x00ffff, 
                     headEmissive: 0x00ffff,
                     bodyEmissiveIntensity: 0.3,
                     headEmissiveIntensity: 0.2,
                     headTransparent: false,
                     headOpacity: 1.0
                 },
                 force: { 
                     bodyColor: 0x4400ff, 
                     headColor: 0xff00ff, 
                     bodyEmissive: 0xff00ff, 
                     headEmissive: 0xff00ff,
                     bodyEmissiveIntensity: 0.3,
                     headEmissiveIntensity: 0.2,
                     headTransparent: false,
                     headOpacity: 1.0
                 },
                 force_user: { 
                     bodyColor: 0x2F2F2F, 
                     headColor: 0xff3333, 
                     bodyEmissive: 0x1a1a1a, 
                     headEmissive: 0xff3333,
                     bodyEmissiveIntensity: 0.2,
                     headEmissiveIntensity: 0.6,
                     headTransparent: false,
                     headOpacity: 1.0
                 },
                pilot: { 
                    bodyColor: 0x654321, 
                    headColor: 0xffffff, 
                    bodyEmissive: 0xffaa00, 
                    headEmissive: 0xffaa00,
                    bodyEmissiveIntensity: 0.3,
                    headEmissiveIntensity: 0.2,
                    headTransparent: false,
                    headOpacity: 1.0
                },
                penguin: { 
                    bodyColor: 0xf5f5f5, 
                    headColor: 0x1a1a1a, 
                    bodyEmissive: 0x000000, 
                    headEmissive: 0x000000,
                    bodyEmissiveIntensity: 0,
                    headEmissiveIntensity: 0,
                    headTransparent: false,
                    headOpacity: 1.0,
                    bodyRoughness: 0.8,
                    bodyMetalness: 0,
                    headRoughness: 0.7,
                    headMetalness: 0
                }
            };
            
            const config = outfitConfigs[outfitType] || outfitConfigs.index;
            const bodyMetal = config.bodyMetalness !== undefined ? config.bodyMetalness : 0.3;
            const bodyRough = config.bodyRoughness !== undefined ? config.bodyRoughness : 0.7;
            const headMetal = config.headMetalness !== undefined ? config.headMetalness : 0.1;
            const headRough = config.headRoughness !== undefined ? config.headRoughness : 0.1;
             
             if (playerRiderBody) {
                 playerRiderBody.material = new THREE.MeshStandardMaterial({
                     color: config.bodyColor,
                     metalness: bodyMetal,
                     roughness: bodyRough,
                     emissive: config.bodyEmissive,
                     emissiveIntensity: config.bodyEmissiveIntensity
                 });
             }
             
             if (playerRiderHead) {
                 playerRiderHead.material = new THREE.MeshStandardMaterial({
                     color: config.headColor,
                     metalness: headMetal,
                     roughness: headRough,
                     emissive: config.headEmissive,
                     emissiveIntensity: config.headEmissiveIntensity,
                     transparent: config.headTransparent,
                     opacity: config.headOpacity
                 });
             }
         }

         // Settings Menu Functions
         function toggleSettingsMenu() {
             const settingsMenu = document.getElementById('settings-menu');
             const isVisible = settingsMenu.style.display === 'block';
             
             if (isVisible) {
                 // Closing settings menu
                 settingsMenu.style.display = 'none';
                 // Resume game if it was running
                 if (isGameRunning && !isGameOver && gamePaused) {
                     gamePaused = false;
                     document.getElementById('pause-overlay').style.display = 'none';
                     // Don't call animate() - loop should already be running
                 }
             } else {
                 // Opening settings menu
                 settingsMenu.style.display = 'block';
                 updateSettingsDisplay();
                 // Auto-pause game if it's running
                 if (isGameRunning && !isGameOver && !gamePaused) {
                     gamePaused = true;
                     document.getElementById('pause-overlay').style.display = 'flex';
                 }
             }
         }

         function toggleGameInstructions() {
             const instructionsDiv = document.getElementById('game-instructions');
             const settingsMenu = document.getElementById('settings-menu');
             const isVisible = instructionsDiv.style.display === 'block';
 
             if (isVisible) {
                 // If instructions are visible, just hide them. Don't close the whole menu.
                 instructionsDiv.style.display = 'none';
             } else {
                 // If instructions are hidden, make sure the settings menu is open first, then show them.
                 settingsMenu.style.display = 'block';
                 instructionsDiv.style.display = 'block';
             }
         }

         function updateSettingsDisplay() {
             // Avoid TDZ: waitForGame can call this before customization is initialized (Firefox strict ordering)
             const c = (typeof window !== 'undefined' && window.customization);
             if (!c) return;
             // Safely update customization displays only if elements exist
             const currentSkin = document.getElementById('current-skin');
             const currentTrail = document.getElementById('current-trail');
             const currentOutfit = document.getElementById('current-outfit');
             const miniSkin = document.getElementById('mini-skin');
             const miniTrail = document.getElementById('mini-trail');
             const miniOutfit = document.getElementById('mini-outfit');
             
             if (currentSkin) currentSkin.textContent = capitalizeFirst(c.currentSkin);
             if (currentTrail) currentTrail.textContent = capitalizeFirst(c.currentTrail);
             if (currentOutfit) currentOutfit.textContent = capitalizeFirst(c.currentOutfit);
             if (miniSkin) miniSkin.textContent = capitalizeFirst(c.currentSkin);
             if (miniTrail) miniTrail.textContent = capitalizeFirst(c.currentTrail);
             if (miniOutfit) miniOutfit.textContent = capitalizeFirst(c.currentOutfit);
             
             // Update penguin skin display
             const currentPenguinSkinDisplay = document.getElementById('current-penguin-skin');
             if (currentPenguinSkinDisplay && penguinSkins[currentPenguinSkin]) {
                 currentPenguinSkinDisplay.textContent = penguinSkins[currentPenguinSkin].name;
             }
             
             // Populate penguin skin grid
             updatePenguinSkinGrid();
         }
         
         function updatePenguinSkinGrid() {
             const grid = document.getElementById('penguin-skin-grid');
             if (!grid) return;
             
             grid.innerHTML = '';
             
             Object.keys(penguinSkins).forEach(skinId => {
                 const skin = penguinSkins[skinId];
                 const skinBtn = document.createElement('div');
                 skinBtn.style.cssText = `
                     padding: 10px;
                     background: ${skin.unlocked ? (skinId === currentPenguinSkin ? 'rgba(0,255,255,0.3)' : 'rgba(0,100,150,0.2)') : 'rgba(50,50,50,0.5)'};
                     border: 2px solid ${skin.unlocked ? (skinId === currentPenguinSkin ? '#00ffff' : '#006688') : '#444'};
                     border-radius: 8px;
                     cursor: ${skin.unlocked ? 'pointer' : 'not-allowed'};
                     transition: all 0.2s ease;
                     text-align: center;
                 `;
                 
                 const emoji = skinId === 'emperor' ? 'üêß' : skinId === 'rockhopper' ? 'üêß' : skinId === 'fairy' ? 'üê¶' : 'üëë';
                 const lockStatus = skin.unlocked ? (skinId === currentPenguinSkin ? '‚úì SELECTED' : 'Click to select') : `üîí Score ${skin.unlockScore.toLocaleString()}`;
                 
                 skinBtn.innerHTML = `
                     <div style="font-size: 1.8em; margin-bottom: 5px;">${emoji}</div>
                     <div style="color: ${skin.unlocked ? '#fff' : '#888'}; font-size: 0.9em; font-weight: bold;">${skin.name}</div>
                     <div style="color: ${skin.unlocked ? (skinId === currentPenguinSkin ? '#00ffff' : '#aaa') : '#666'}; font-size: 0.7em; margin-top: 3px;">${lockStatus}</div>
                 `;
                 
                 if (skin.unlocked) {
                     skinBtn.addEventListener('click', () => {
                         selectPenguinSkin(skinId);
                     });
                     skinBtn.addEventListener('mouseover', () => {
                         if (skinId !== currentPenguinSkin) {
                             skinBtn.style.background = 'rgba(0,200,255,0.2)';
                             skinBtn.style.borderColor = '#00aaff';
                         }
                     });
                     skinBtn.addEventListener('mouseout', () => {
                         skinBtn.style.background = skinId === currentPenguinSkin ? 'rgba(0,255,255,0.3)' : 'rgba(0,100,150,0.2)';
                         skinBtn.style.borderColor = skinId === currentPenguinSkin ? '#00ffff' : '#006688';
                     });
                 }
                 
                 grid.appendChild(skinBtn);
             });
         }
         
         function selectPenguinSkin(skinId) {
             if (applyPenguinSkin(skinId)) {
                 updateSettingsDisplay();
                 setMessage(`üêß Selected: ${penguinSkins[skinId].name}! Applies on next game.`);
                 
                 // Play selection sound
                 if (typeof Tone !== 'undefined') {
                     const selectSynth = new Tone.Synth().toDestination();
                     selectSynth.volume.value = -10;
                     selectSynth.triggerAttackRelease('C5', '16n');
                 }
             }
         }

         function capitalizeFirst(str) {
             return str.charAt(0).toUpperCase() + str.slice(1);
         }

         function changeBikeSkin(direction) {
             const currentIndex = customization.bikeSkins.indexOf(customization.currentSkin);
             let newIndex;
             
             if (direction === 'next') {
                 newIndex = (currentIndex + 1) % customization.bikeSkins.length;
             } else {
                 newIndex = (currentIndex - 1 + customization.bikeSkins.length) % customization.bikeSkins.length;
             }
             
             customization.currentSkin = customization.bikeSkins[newIndex];
             applySkinToMotorcycle(playerMotorcycle, customization.currentSkin);
             updateSettingsDisplay();
             setMessage(`Bike skin: ${capitalizeFirst(customization.currentSkin)}`);
         }

         function changeTrailEffect(direction) {
             const currentIndex = customization.bikeTrails.indexOf(customization.currentTrail);
             let newIndex;
             
             if (direction === 'next') {
                 newIndex = (currentIndex + 1) % customization.bikeTrails.length;
             } else {
                 newIndex = (currentIndex - 1 + customization.bikeTrails.length) % customization.bikeTrails.length;
             }
             
             customization.currentTrail = customization.bikeTrails[newIndex];
             updateSettingsDisplay();
             setMessage(`Trail effect: ${capitalizeFirst(customization.currentTrail)}`);
         }

         function changeRiderOutfit(direction) {
             const currentIndex = customization.riderOutfits.indexOf(customization.currentOutfit);
             let newIndex;
             
             if (direction === 'next') {
                 newIndex = (currentIndex + 1) % customization.riderOutfits.length;
             } else {
                 newIndex = (currentIndex - 1 + customization.riderOutfits.length) % customization.riderOutfits.length;
             }
             
             customization.currentOutfit = customization.riderOutfits[newIndex];
             applyRiderOutfit(customization.currentOutfit);
             updateSettingsDisplay();
             setMessage(`Rider outfit: ${capitalizeFirst(customization.currentOutfit)}`);
         }

         function consumeGreenVial() {
             console.log("GOLD COIN COLLECTED!");
             
             // EPIC GOLD COIN SOUND - 3X MORE DRAMATIC! (Always play)
             const now = Tone.now();
             // Triple layered fanfare
             goldCoinSynth.triggerAttackRelease(['C5', 'E5', 'G5'], '8n', now, 1.0);
             goldCoinSynth.triggerAttackRelease(['C6', 'E6', 'G6'], '8n', now + 0.15, 0.9);
             goldCoinSynth.triggerAttackRelease(['C7'], '4n', now + 0.3, 0.8);
             epicPowerUpSynth.triggerAttackRelease('C3', '8n', now, 0.7);
             // Additional layers for 3x effect
             goldCoinSynth.triggerAttackRelease(['G5', 'B5', 'D6'], '8n', now + 0.5, 0.6);
             epicPowerUpSynth.triggerAttackRelease('C2', '4n', now + 0.6, 0.5);
             
             // Real coin pickup sound from Freesound
             playCoinPickupSound();
             
             // BIG SCORE BONUS
             score += 100; // 100 coins for gold!
             updateScoreDisplay();
             
             // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
             // GOLD COIN DOPAMINE - MEGA FLOATING TEXT
             // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
             createFloatingScoreText(playerMotorcycle.position.clone(), '+100', 'coin-gold');
             setTimeout(() => {
                 const celebPos = playerMotorcycle.position.clone();
                 celebPos.y += 1.5;
                 createFloatingScoreText(celebPos, '‚≠ê JACKPOT! ‚≠ê', 'celebration');
             }, 200);
             triggerCelebration(1500); // Long celebration for gold!
             
             // Check for skin unlocks
             checkAndUnlockSkins(score);
             
             // SPEED BOOST POWER-UP
             const originalSpeed = baseMoveSpeed;
             baseMoveSpeed *= 1.5; // 50% speed boost on top of already fast speed!
             
             setMessage(`‚≠ê GOLD COIN! +100 + SPEED BOOST! ‚≠ê`);
             
             // Reset speed after 5 seconds
             setTimeout(() => {
                 baseMoveSpeed = originalSpeed;
                 setMessage("Speed boost ended");
             }, 5000);
             
             // No shake on gold coin ‚Äî shake only on competitor collisions
             
             updatePowerUpDisplay();
             
             // MASSIVE visual explosion - 3X MORE DRAMATIC
             createGoldCoinExplosion(playerMotorcycle.position.clone());
             createSparkleVialBurst(playerMotorcycle.position.clone());
             
             // Additional screen effects for 3x satisfaction
             const screenRipple = document.createElement('div');
             screenRipple.style.cssText = 'position:fixed;top:50%;left:50%;width:0;height:0;border:3px solid rgba(255,215,0,0.8);border-radius:50%;transform:translate(-50%,-50%);z-index:998;pointer-events:none;animation:rippleExpand 1s ease-out forwards;';
             document.body.appendChild(screenRipple);
             setTimeout(() => screenRipple.remove(), 1000);
         }

         function createSparkleVialBurst(position) {
             const burstCount = 25; // More sparkles!
             for (let i = 0; i < burstCount; i++) {
                 const sparkleGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                 const goldColors = [0xffd700, 0xffff00, 0xffffff, 0xffaa00];
                 const sparkleMaterial = new THREE.MeshBasicMaterial({
                     color: goldColors[Math.floor(Math.random() * goldColors.length)],
                     transparent: true,
                     opacity: 1.0
                 });
                 const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
                 sparkle.position.copy(position);
                 sparkle.position.y += 1;
                 
                 // More dramatic velocity
                 const velocity = new THREE.Vector3(
                     (Math.random() - 0.5) * 0.8,
                     Math.random() * 0.5 + 0.2,
                     (Math.random() - 0.5) * 0.8
                 );
                 sparkle.userData.velocity = velocity;
                 sparkle.userData.life = 0;
                 sparkle.userData.maxLife = 80;
                 
                 scene.add(sparkle);
                 activeBursts.push(sparkle);
             }
         }

         // Pause/Resume Functions
         function togglePause() {
             if (!isGameRunning || isGameOver) return;
             
             gamePaused = !gamePaused;
             const pauseOverlay = document.getElementById('pause-overlay');
             
             if (gamePaused) {
                 // Record when pause started
                 pauseStartTime = Date.now();
                 // Cancel the current animation frame to truly pause
                 if (window.animationFrameId) {
                     cancelAnimationFrame(window.animationFrameId);
                     window.animationFrameId = null;
                 }
                 pauseOverlay.style.display = 'flex';
                 pauseOverlay.style.animation = 'pausePulse 2s infinite';
                 // Stop continuous audio when paused
                 stopAllEnhancedAudio();
             } else {
                 // Calculate how long we were paused and add to total
                 const pauseDuration = Date.now() - pauseStartTime;
                 totalPausedTime += pauseDuration;
                 
                 pauseOverlay.style.display = 'none';
                 // Resume the game loop and restart audio (only if enabled)
                 if (audioSystemEnabled) {
                     try {
                         startEngineSynth();
                         startAmbientMusic();
                     } catch(e) {
                         console.log("Audio restart after pause:", e);
                     }
                 }
                 // Only restart animation if it's not already running
                 if (!window.animationFrameId) {
                     animate();
                 }
             }
         }
         
         // NEW VISUAL & AUDIO ENHANCEMENT FUNCTIONS
         
         // 1. WORMHOLE HYPERSPACE EFFECT (Dark and mysterious)
         function triggerHyperspaceEffect() {
             if (hyperspaceActive) return;
             hyperspaceActive = true;
             
             // Dark wormhole effect with swirling distortion
             const wormholeOverlay = document.createElement('div');
             wormholeOverlay.style.position = 'fixed';
             wormholeOverlay.style.top = '0';
             wormholeOverlay.style.left = '0';
             wormholeOverlay.style.width = '100%';
             wormholeOverlay.style.height = '100%';
             wormholeOverlay.style.background = 'radial-gradient(ellipse at center, rgba(20,0,40,0.9) 0%, rgba(60,20,80,0.7) 30%, rgba(100,50,150,0.5) 60%, rgba(0,0,0,0.8) 100%)';
             wormholeOverlay.style.pointerEvents = 'none';
             wormholeOverlay.style.zIndex = '1000';
             wormholeOverlay.style.animation = 'wormholeSwirl 1.2s ease-in-out';
             document.body.appendChild(wormholeOverlay);
             
             // Add CSS animation for wormhole swirling effect
             if (!document.getElementById('wormhole-styles')) {
                 const wormholeStyles = document.createElement('style');
                 wormholeStyles.id = 'wormhole-styles';
                 wormholeStyles.textContent = `
                     @keyframes wormholeSwirl {
                         0% { 
                             transform: rotate(0deg) scale(0.1); 
                             opacity: 0;
                         }
                         30% { 
                             transform: rotate(180deg) scale(1.2); 
                             opacity: 0.9;
                         }
                         70% { 
                             transform: rotate(360deg) scale(1.0); 
                             opacity: 0.7;
                         }
                         100% { 
                             transform: rotate(540deg) scale(0.8); 
                             opacity: 0;
                         }
                     }
                 `;
                 document.head.appendChild(wormholeStyles);
             }
             
             // Create dark energy particles swirling inward
             for (let i = 0; i < 40; i++) {
                 const particle = new THREE.Mesh(
                     new THREE.SphereGeometry(0.008 + Math.random() * 0.012, 4, 4),
                     new THREE.MeshBasicMaterial({ 
                         color: Math.random() > 0.7 ? 0x8844ff : 0x442288,
                         transparent: true, 
                         opacity: 0.8
                         // Removed emissive, metalness, roughness, emissiveIntensity - not valid for MeshBasicMaterial
                     })
                 );
                 
                 // Arrange particles in spiral pattern
                 const angle = (i / 40) * Math.PI * 4;
                 const radius = 15 + Math.random() * 10;
                 particle.position.set(
                     Math.cos(angle) * radius,
                     Math.sin(angle) * radius * 0.3,
                     playerMotorcycle.position.z - 5 - Math.random() * 15
                 );
                 
                 // Spiral inward velocity
                 particle.userData.velocity = new THREE.Vector3(
                     -Math.cos(angle) * 0.3,
                     -Math.sin(angle) * 0.1,
                     -2
                 );
                 particle.userData.life = 0;
                 particle.userData.maxLife = 50;
                 particle.userData.rotationSpeed = (Math.random() - 0.5) * 0.2;
                 scene.add(particle);
                 activeBursts.push(particle);
             }
             
             // Create central dark void effect
             const voidCore = new THREE.Mesh(
                 new THREE.SphereGeometry(2, 16, 16),
                 new THREE.MeshBasicMaterial({ 
                     color: 0x000000,
                     transparent: true,
                     opacity: 0.9,
                     side: THREE.DoubleSide
                 })
             );
             voidCore.position.set(0, 0, playerMotorcycle.position.z - 10);
             voidCore.userData.life = 0;
             voidCore.userData.maxLife = 60;
             voidCore.userData.isVoidCore = true;
             scene.add(voidCore);
             activeBursts.push(voidCore);
             

             
             setTimeout(() => {
                 wormholeOverlay.remove();
                 hyperspaceActive = false;
             }, 1200);
         }
         
                     // 2. EMC COLLECTION TRAILS
            function createEtherTrail(position) {
             for (let i = 0; i < 8; i++) {
                 const trail = new THREE.Mesh(
                     new THREE.SphereGeometry(0.03, 6, 6),
                     new THREE.MeshBasicMaterial({ 
                         color: 0xffff00, 
                         transparent: true, 
                         opacity: 0.7
                         // Removed emissive, metalness, roughness, emissiveIntensity - not valid for MeshBasicMaterial
                     })
                 );
                 trail.position.copy(position);
                 trail.position.add(new THREE.Vector3(
                     (Math.random() - 0.5) * 0.5,
                     (Math.random() - 0.5) * 0.5,
                     Math.random() * 2
                 ));
                 trail.userData.velocity = new THREE.Vector3(0, 0, 1);
                 trail.userData.life = 0;
                 trail.userData.maxLife = 40;
                 scene.add(trail);
                 etherTrails.push(trail);
             }
         }
         
         // 3. MR. TERRIFIC'S DISCO GLOW - DISABLED to remove swirl/shield aura
         function updateDiscoGlow() {
             // DISABLED - no glow effects
             // All glow/aura effects have been removed
             return;
         }
         
         // 4. DYNAMIC SPEED LINES - ENHANCED FOR DOPAMINE
         function createSpeedLines() {
             if (typeof currentMoveSpeed === 'undefined') return; // Safety check
             
             // Calculate speed intensity (0 to 1 scale based on current vs max speed)
             const speedIntensity = Math.min(currentMoveSpeed / maxMoveSpeed, 1);
             const isFastEnough = speedIntensity > 0.3; // Only show lines above 30% speed
             
             if (!isFastEnough) return; // No speed lines at slow speeds
             
             const baseLineCount = Math.min(2, Math.floor(speedIntensity * 4));
             const lineCount = isBoosting ? baseLineCount + 1 : baseLineCount;
             const maxLines = 16;
             
             for (let i = 0; i < lineCount && speedLines.length < maxLines; i++) {
                 // Line length and thickness scales with speed
                 const lineLength = 3 + speedIntensity * 7; // 3-10 units long
                 const lineThickness = 0.01 + speedIntensity * 0.02; // Thicker at high speed
                 
                 // Color shifts from blue to white/cyan at high speeds
                 const colorIntensity = Math.floor(speedIntensity * 255);
                 const lineColor = new THREE.Color(
                     0.1 + speedIntensity * 0.9, // R: 0.1 to 1.0
                     0.5 + speedIntensity * 0.5, // G: 0.5 to 1.0  
                     1.0 // B: always 1.0
                 );
                 
                 const line = new THREE.Mesh(
                     new THREE.CylinderGeometry(lineThickness, lineThickness, lineLength, 4),
                     new THREE.MeshBasicMaterial({ 
                         color: lineColor,
                         transparent: true, 
                         opacity: 0.2 + speedIntensity * 0.5 // More visible at high speed (0.2-0.7)
                     })
                 );
                 
                 // Position lines around the player's view
                 const spread = 25 + speedIntensity * 15; // Wider spread at high speed
                 line.position.set(
                     (Math.random() - 0.5) * spread,
                     (Math.random() - 0.5) * 12 + 3, // Slightly higher, around eye level
                     playerMotorcycle.position.z - 15 - Math.random() * 40
                 );
                 line.rotation.x = Math.PI / 2; // Make lines horizontal (pointing forward)
                 
                 // Speed of lines passing by (faster at higher speeds)
                 line.userData.speed = currentMoveSpeed * 1.5 + Math.random() * 3;
                 line.userData.intensity = speedIntensity; // Store for later updates
                 
                 scene.add(line);
                 speedLines.push(line);
             }
             
         }
         
         // 5. ENGINE SOUND SCALING
         function updateEngineSound() {
             if (audioSystemEnabled && engineSynth && engineSynth.state === 'started' && typeof currentMoveSpeed !== 'undefined' && isGameRunning && !isGameOver) {
                 try {
                     const baseFreq = 60;
                     const speedMultiplier = currentMoveSpeed / initialBaseMoveSpeed;
                     const newFreq = Math.max(40, Math.min(120, baseFreq + (speedMultiplier * 40))); // Clamp frequency
                     
                     // Safety checks for engineSynth properties
                     if (engineSynth && engineSynth.frequency && engineSynth.frequency.value !== undefined) {
                         engineSynth.frequency.value = newFreq;
                     }
                     
                     const volume = isBoosting ? -15 : -20;
                     if (engineSynth && engineSynth.volume && engineSynth.volume.value !== undefined) {
                         engineSynth.volume.value = volume;
                     }
                 } catch(e) {
                     console.log("Engine sound update error:", e);
                 }
             }
         }
         
         // 6. AMBIENT STAR WARS MUSIC
         function startAmbientMusic() {
             if (!ambientMusicActive && audioSystemEnabled) {
                 ambientMusicActive = true;
                 // Create a simple Star Wars-like ambient melody
                 const melody = ['C4', 'G4', 'F4', 'E4', 'D4', 'C5', 'G4'];
                 let noteIndex = 0;
                 
                 // Clear any existing interval first
                 if (ambientMusicInterval) {
                     clearInterval(ambientMusicInterval);
                 }
                 
                 ambientMusicInterval = setInterval(() => {
                     if (ambientMusicActive && audioSystemEnabled && isGameRunning && !isGameOver) {
                         ambientSynth.triggerAttackRelease(melody[noteIndex], '2n');
                         noteIndex = (noteIndex + 1) % melody.length;
                     }
                 }, 4000); // Play a note every 4 seconds
             }
         }
         
         // Stop ambient music properly
         function stopAmbientMusic() {
             ambientMusicActive = false;
             if (ambientMusicInterval) {
                 clearInterval(ambientMusicInterval);
                 ambientMusicInterval = null;
             }
         }
         
                 // Stop all enhanced audio systems
        function stopAllEnhancedAudio() {
            // Stop engine synth
            if (engineSynth && engineSynth.state === 'started') {
                try {
                    engineSynth.stop();
                } catch(e) {
                    console.log("Engine synth stop error:", e);
                }
            }
            
            // Stop boost sound if it's playing
            // if (boostSound && boostSound.state === 'started') {
            //     try {
            //         boostSound.stop();
            //     } catch(e) {
            //         console.log("Boost sound stop error:", e);
            //     }
            // }
            
            // Stop ambient music
            stopAmbientMusic();
        }
        
        // Safe engine synth start (prevents multiple starts)
        function startEngineSynth() {
            if (audioSystemEnabled && engineSynth && engineSynth.state !== 'started') {
                try {
                    engineSynth.start();
                } catch(e) {
                    console.log("Engine synth start error:", e);
                }
            }
        }
        
        // Toggle audio system on/off
        function toggleAudioSystem() {
            audioSystemEnabled = !audioSystemEnabled;
            
            if (audioSystemEnabled) {
                console.log("üéµ AUDIO SYSTEM ENABLED - Sound ON");
                setMessage("üéµ Audio System: ON (Press 'M' to disable)");
                
                // Start enhanced audio systems if game is running
                if (isGameRunning && !isGameOver && !gamePaused) {
                    try {
                        startEngineSynth();
                        startAmbientMusic();
                    } catch(e) {
                        console.log("Audio system start error:", e);
                    }
                }
            } else {
                console.log("üîá AUDIO SYSTEM DISABLED - Sound OFF");
                // Audio message removed
                stopAllEnhancedAudio();
            }
            
            // Update audio status display
            updateAudioStatusDisplay();
        }

        // Toggle headlight on/off with H key (player uses bikeFloodlight only; bikeHeadlight is null)
        function toggleHeadlight() {
            if (!bikeFloodlight) return;
            
            headlightActive = !headlightActive;
            
            if (headlightActive) {
                // Activate powerful floodlight beam
                bikeFloodlight.intensity = 8.0; // Very bright floodlight
                bikeFloodlight.distance = 100; // Long range beam
                bikeFloodlight.angle = Math.PI / 4; // Wide beam angle
                bikeFloodlight.penumbra = 0.1; // Sharp beam edges
                bikeFloodlight.decay = 1; // Less falloff for longer reach
                if (bikeHeadlight) { bikeHeadlight.intensity = 2.0; bikeHeadlight.distance = 30; }
                console.log("üî¶ FLOODLIGHT BEAM ACTIVATED - Powerful road illumination");
                setMessage("üî¶ Floodlight: ON - Road illuminated ahead!");
            } else {
                bikeFloodlight.intensity = 0; // Turn off floodlight completely
                if (bikeHeadlight) { bikeHeadlight.intensity = 0.8; bikeHeadlight.distance = 15; }
                console.log("üí° Floodlight: OFF - Normal lighting restored");
                setMessage("üí° Floodlight: OFF");
            }
        }
        
        // Stop all audio function
        function stopAllEnhancedAudio() {
            // Stop engine synth
            if (engineSynth && engineSynth.state === 'started') {
                try {
                    engineSynth.stop();
                } catch(e) {
                    console.log("Engine synth stop error:", e);
                }
            }
            
            // Stop boost sound if it's playing
            // if (boostSound && boostSound.state === 'started') {
            //     try {
            //         boostSound.stop();
            //     } catch(e) {
            //         console.log("Boost sound stop error:", e);
            //     }
            // }
            
            // Stop ambient music
            stopAmbientMusic();
        }
        
                 // Audio status display removed - no longer needed
         function updateAudioStatusDisplay() {
             // Audio status display removed - no longer needed
         }
         
         // SESSION STATS FUNCTIONS
         function resetSessionStats() {
             sessionStats.distanceTraveled = 0;
             sessionStats.enemiesDefeated = 0;
             sessionStats.etherCollected = 0;
             sessionStats.startTime = Date.now();
             sessionStats.sessionTime = 0;
             sessionStats.maxSpeed = 0;
             sessionStats.hyperspaceJumps = 0;
             sessionStats.powerUpsUsed = 0;
         }
         
         function updateSessionStats() {
             // Update distance traveled (based on move speed)
             if (typeof currentMoveSpeed !== 'undefined') {
                 sessionStats.distanceTraveled += currentMoveSpeed * 0.1; // Scale factor for realistic units
                 sessionStats.maxSpeed = Math.max(sessionStats.maxSpeed, currentMoveSpeed);
             }
         }
         
         function trackEnemyDefeat() {
             sessionStats.enemiesDefeated++;
             totalEnemiesDefeated++; // Track for leaderboard
         }
         
         function trackEtherCollection() {
             sessionStats.etherCollected++;
         }
         
         function trackHyperspaceJump() {
             sessionStats.hyperspaceJumps++;
         }
         
         function trackPowerUpUsed() {
             sessionStats.powerUpsUsed++;
         }
         
         function formatTime(milliseconds) {
             const minutes = Math.floor(milliseconds / 60000);
             const seconds = Math.floor((milliseconds % 60000) / 1000);
             return `${minutes}:${seconds.toString().padStart(2, '0')}`;
         }
         
         function formatDistance(distance) {
             return `${Math.floor(distance)} parsecs`;
         }
         
         function populateMissionStats() {
             console.log("üî• populateMissionStats() called - CYPHES STATS");
             
             // Only populate Total $SWAG Earned - all other per-session stats removed
             const statTotalSwag = document.getElementById('stat-total-swag');
             
             console.log("üî• Found total SWAG element:", !!statTotalSwag);
             
             // Update total $SWAG across all sessions
             const currentTotalSwag = parseInt(localStorage.getItem('cyphes_total_swag') || '0');
             const newTotalSwag = currentTotalSwag + score;
             localStorage.setItem('cyphes_total_swag', newTotalSwag.toString());
             if (statTotalSwag) statTotalSwag.textContent = newTotalSwag.toLocaleString();
             
             // Update lifetime display in footer
             const lifetimeSwagValue = document.getElementById('lifetime-swag-value');
             if (lifetimeSwagValue) lifetimeSwagValue.textContent = newTotalSwag.toLocaleString();
             
             // üîó Update Firebase for airdrop eligibility
             if (typeof window.updatePlayerTotalSwag === 'function') {
                 window.updatePlayerTotalSwag(score);
             } else {
                 console.log('üîó Firebase update function not ready yet');
             }
             
            console.log("üî• Total $SWAG updated:", newTotalSwag);
            
            // SOL LOST display removed - replaced with CHAT link
            
            // Update global progress bar immediately
            if (typeof updateProgressBar === 'function') {
                updateProgressBar();
            } else {
                console.log("üìä updateProgressBar not available yet, will update later");
            }
            
            console.log('üî• CYPHES STATS populated successfully');
         }
         
         // 7. ENHANCED COLLISION SOUNDS
         function playCollisionSound(type = 'normal') {
             if (!audioSystemEnabled) return; // No sound if audio disabled
             
             switch(type) {
                 case 'obstacle':
                     // Bass thump on obstacle hit
                     const bassThump = document.getElementById('bass-thump-sound');
                     if (bassThump) {
                         bassThump.currentTime = 0;
                         bassThump.volume = 0.7;
                         bassThump.play().catch(e => console.log("Bass thump play failed:", e));
                     }
                     if (crashNoise) { try { crashNoise.triggerAttackRelease("16n", Tone.now(), 0.8); } catch (_) {} }
                     break;
                 case 'enemy':
                     if (explosionSynth) { try { explosionSynth.triggerAttackRelease("8n", Tone.now(), 0.6); } catch (_) {} }
                     break;
                 case 'powerup':
                     if (forceSynth) { try { forceSynth.triggerAttackRelease('E5', '8n'); } catch (_) {} }
                     break;
                 default:
                     if (crashNoise) { try { crashNoise.triggerAttackRelease("32n", Tone.now(), 0.5); } catch (_) {} }
             }
         }
         if (typeof window !== 'undefined') window.playCollisionSound = playCollisionSound;
         
         // Coin pickup sound from Freesound
         function playCoinPickupSound() {
             if (!audioSystemEnabled) return;
             const coinSound = document.getElementById('coin-pickup-sound');
             if (coinSound) {
                 coinSound.currentTime = 0;
                 coinSound.volume = 0.5;
                 coinSound.play().catch(e => console.log("Coin sound play failed:", e));
             }
         }
         
         // Background music control
         let backgroundMusicPlaying = false;
         function startBackgroundMusic() {
             if (!audioSystemEnabled || backgroundMusicPlaying) return;
             const bgMusic = document.getElementById('background-music');
             if (bgMusic) {
                 bgMusic.volume = 0.3;
                 bgMusic.play().catch(e => console.log("Background music play failed:", e));
                 backgroundMusicPlaying = true;
             }
         }
         function stopBackgroundMusic() {
             const bgMusic = document.getElementById('background-music');
             if (bgMusic) {
                 bgMusic.pause();
                 bgMusic.currentTime = 0;
                 backgroundMusicPlaying = false;
             }
         }

         function handleScreenTap(event) {
             // Don't pause if clicking on UI elements
             const target = event.target;
             if (target.tagName === 'BUTTON' || 
                 target.closest('#settings-menu') || 
                 target.closest('.overlay') ||
                 target.closest('.game-footer') ||
                 target.closest('#boost-button') ||
                 target.closest('#blaster-button') ||
                 target.closest('#use-power-up-button-mobile') ||
                 target.closest('.mobile-controls')) {
                 return;
             }
             
             // Don't pause if settings menu is open
             const settingsMenu = document.getElementById('settings-menu');
             if (settingsMenu.style.display === 'block') {
                 return;
             }
             
             // Mobile: tap center area to pause (avoid interfering with swipe steering)
             if (isMobileDevice()) {
                 const touchX = event.touches ? event.touches[0].clientX : event.clientX;
                 const touchY = event.touches ? event.touches[0].clientY : event.clientY;
                 const centerX = window.innerWidth / 2;
                 const centerY = window.innerHeight / 2;
                 const tapRadius = 80; // Tap within 80px of center to pause
                 
                 const distFromCenter = Math.sqrt(Math.pow(touchX - centerX, 2) + Math.pow(touchY - centerY, 2));
                 
                 // Only pause if tapping near center of screen
                 if (distFromCenter > tapRadius) {
                     return;
                 }
             }
             
             // Only toggle pause during active gameplay
             if (isGameRunning && !isGameOver) {
                 togglePause();
             }
         }

        // Cinematic Camera System
        function activateCinematicCamera(type, target = null) {
            cinematicCamera.active = true;
            cinematicCamera.type = type;
            cinematicCamera.timer = 0;
            
            // Enable cinematic invulnerability
            isCinematicInvulnerable = true;
            setMessage("üé¨ Cinematic Mode - You are invulnerable!");
            
            // Cinematic glow removed - no swirl/shield aura
            // Player appearance unchanged during cinematics
            
            // Store current camera position/rotation
            cinematicCamera.originalPosition.copy(camera.position);
            cinematicCamera.originalRotation.copy(camera.rotation);
            
            switch (type) {
                case 'levelUp':
                    cinematicCamera.duration = 180; // 3 seconds
                    cinematicCamera.targetPosition.set(
                        playerMotorcycle.position.x,
                        playerMotorcycle.position.y + 8,
                        playerMotorcycle.position.z - 5
                    );
                    break;
                    
                case 'tieFighter':
                    cinematicCamera.duration = 360; // 6 seconds for more drama
                    if (target) {
                        // Start with a wide sweeping angle
                        cinematicCamera.targetPosition.set(
                            target.position.x + 15,
                            target.position.y + 12,
                            target.position.z + 20
                        );
                        // Add camera shake for dramatic effect
                        triggerCameraShake(2.0, 2000);
                        // Enhance all dragon segments for dramatic effect
                        target.userData.segments.forEach(segment => {
                            if(segment.material.emissive) {
                                segment.material.emissiveIntensity = 4.0; // Maximum glow
                            }
                        });
                    }
                    break;
                    
                case 'boost':
                    cinematicCamera.duration = 120; // 2 seconds
                    cinematicCamera.targetPosition.set(
                        playerMotorcycle.position.x,
                        playerMotorcycle.position.y + 2,
                        playerMotorcycle.position.z + 8
                    );
                    break;
                    
                case 'crash':
                    cinematicCamera.duration = 150; // 2.5 seconds
                    cinematicCamera.targetPosition.set(
                        playerMotorcycle.position.x + 5,
                        playerMotorcycle.position.y + 3,
                        playerMotorcycle.position.z + 2
                    );
                    break;
            }
        }

        function updateCinematicCamera() {
            if (!cinematicCamera.active) return;
            
            cinematicCamera.timer++;
            const progress = cinematicCamera.timer / cinematicCamera.duration;
            
            if (progress >= 1) {
                // End cinematic camera
                cinematicCamera.active = false;
                // Disable cinematic invulnerability when normal view is restored
                isCinematicInvulnerable = false;
                
                // Reset emissive intensity to zero - no glow
                if (playerMotorcycle) {
                    playerMotorcycle.traverse(child => {
                        if (child.material && !child.isLight) {
                            child.material.emissiveIntensity = 0.0; // No glow
                        }
                    });
                }

                if (cinematicCamera.type === 'tieFighter') {
                    // After cinematic ends, position stronghold for optimal visibility
                    if (dragons.length > 0) {
                        const stronghold = dragons[0];
                        // Position slightly behind and above player for dramatic effect
                        stronghold.position.set(
                            playerMotorcycle.position.x + (Math.random() - 0.5) * 6, // Slight side offset
                            playerMotorcycle.position.y + 6, // Above player
                            playerMotorcycle.position.z - 25 // Close behind for immediate threat
                        );
                        setMessage("üéØ Stronghold locked onto your position!");
                    }
                    
                    // Give boost on level 10 for dramatic chase
                    if (level === 10) {
                        activateBoost(3000, false);
                    }
                }
                
                return;
            }
            
            // Smooth interpolation
            const easeProgress = 1 - Math.pow(1 - progress, 3); // Ease out cubic
            
            switch (cinematicCamera.type) {
                case 'levelUp':
                    // Spiral around player
                    const radius = 8;
                    const angle = progress * Math.PI * 2;
                    camera.position.set(
                        playerMotorcycle.position.x + Math.cos(angle) * radius,
                        playerMotorcycle.position.y + 5 + Math.sin(progress * Math.PI) * 3,
                        playerMotorcycle.position.z + Math.sin(angle) * radius
                    );
                    camera.lookAt(playerMotorcycle.position);
                    break;
                    
                case 'tieFighter':
                    // DRAMATIC SWEEPING CINEMATIC
                    if (dragons.length > 0) {
                        const dragon = dragons[0];
                        const phase = progress * Math.PI * 2; // Full rotation over duration
                        
                        // Sweeping circular motion around the dragon
                        const radius = 25 - (progress * 10); // Start far, move closer
                        const height = 15 - (progress * 5); // Start high, descend
                        
                        camera.position.set(
                            dragon.position.x + Math.cos(phase) * radius,
                            dragon.position.y + height + Math.sin(progress * Math.PI) * 3,
                            dragon.position.z + Math.sin(phase) * radius
                        );
                        
                        // Always look at the dragon for maximum drama
                        camera.lookAt(dragon.position);
                        
                        // Add dramatic lighting flashes
                        if (Math.random() < 0.1) {
                            createLightningStrike();
                        }
                    }
                    break;
                    
                case 'boost':
                    // Close follow cam
                    const offset = new THREE.Vector3(0, 2, 8);
                    const targetPos = playerMotorcycle.position.clone().add(offset);
                    camera.position.lerp(targetPos, 0.1);
                    camera.lookAt(playerMotorcycle.position);
                    break;
                    
                case 'crash':
                    // Slow motion effect
                    camera.position.lerp(cinematicCamera.targetPosition, 0.03);
                    camera.lookAt(playerMotorcycle.position);
                    break;
            }
        }
        
        // CAMERA SHAKE SYSTEM FUNCTIONS
        function triggerCameraShake(intensity, duration) {
            cameraShake.active = true;
            cameraShake.intensity = intensity;
            cameraShake.duration = duration;
            cameraShake.timer = 0;
        }
        
        function updateCameraShake() {
            if (!cameraShake.active) return;
            
            cameraShake.timer += 16; // Assuming 60fps (16ms per frame)
            const progress = cameraShake.timer / cameraShake.duration;
            
            if (progress >= 1.0) {
                // End camera shake
                cameraShake.active = false;
                cameraShake.offsetX = 0;
                cameraShake.offsetY = 0;
                cameraShake.offsetZ = 0;
                return;
            }
            
            // Calculate shake intensity with decay over time
            const currentIntensity = cameraShake.intensity * (1.0 - progress);
            
            // Generate random shake offsets
            cameraShake.offsetX = (Math.random() - 0.5) * currentIntensity;
            cameraShake.offsetY = (Math.random() - 0.5) * currentIntensity;
            cameraShake.offsetZ = (Math.random() - 0.5) * currentIntensity * 0.5; // Less Z movement
            
            // Apply shake to camera position
            camera.position.x += cameraShake.offsetX;
            camera.position.y += cameraShake.offsetY;
            camera.position.z += cameraShake.offsetZ;
        }

        function initializeWeather() {
            const snowCount = 400;
            const snowPositions = new Float32Array(snowCount * 3);
            const snowVelocities = new Float32Array(snowCount * 3);
            const snowDrift = new Float32Array(snowCount);
            const snowSwirl = new Float32Array(snowCount);
            for (let i = 0; i < snowCount; i++) {
                const i3 = i * 3;
                snowPositions[i3] = (Math.random() - 0.5) * 200;
                snowPositions[i3 + 1] = Math.random() * 120 + 20;
                snowPositions[i3 + 2] = (Math.random() - 0.5) * 200;
                snowVelocities[i3] = (Math.random() - 0.5) * 0.4;
                snowVelocities[i3 + 1] = -0.15 - Math.random() * 0.2;
                snowVelocities[i3 + 2] = (Math.random() - 0.5) * 0.3;
                snowDrift[i] = (Math.random() - 0.5) * 2;
                snowSwirl[i] = Math.random() * Math.PI * 2;
            }
            weather.snowGeometry = new THREE.BufferGeometry();
            weather.snowGeometry.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
            weather.snowGeometry.userData.velocities = snowVelocities;
            weather.snowGeometry.userData.drift = snowDrift;
            weather.snowGeometry.userData.swirl = snowSwirl;
            weather.snowMaterial = new THREE.PointsMaterial({
                color: 0xfefefe,
                size: 0.35,
                transparent: true,
                opacity: 0
            });
            weather.snowMesh = new THREE.Points(weather.snowGeometry, weather.snowMaterial);
            scene.add(weather.snowMesh);
        }

        function updateWeather() {
            if (!isGameRunning) return;

            if (level < 5 || level > 25) {
                weather.current = 'clear';
                weather.intensity = Math.max(0, weather.intensity - 0.02);
                if (weather.snowMaterial) weather.snowMaterial.opacity = weather.intensity * (level >= 10 ? 0.5 : 0.85);
                return;
            }

            weather.changeTimer++;
            if (weather.changeTimer >= weather.changeInterval) {
                const weatherTypes = ['clear', 'snow'];
                const oldWeather = weather.current;
                weather.current = weatherTypes[Math.floor(Math.random() * weatherTypes.length)];
                weather.changeTimer = 0;
                if (weather.current !== oldWeather && weather.current === 'snow') {
                    setMessage('Snowfall drifting in‚Ä¶');
                }
            }

            switch (weather.current) {
                case 'clear':
                    weather.intensity = Math.max(0, weather.intensity - 0.01);
                    break;
                case 'snow':
                    const snowCap = level >= 10 ? 0.35 : 0.85;
                    weather.intensity = Math.min(snowCap, weather.intensity + 0.015);
                    updateSnow();
                    break;
            }

            if (weather.snowMaterial) weather.snowMaterial.opacity = weather.intensity * (level >= 10 ? 0.5 : 0.85);
        }

        function updateSnow() {
            if (!weather.snowMesh) return;
            const positions = weather.snowGeometry.attributes.position.array;
            const velocities = weather.snowGeometry.userData.velocities;
            const drift = weather.snowGeometry.userData.drift;
            const swirl = weather.snowGeometry.userData.swirl;
            const t = Date.now() * 0.001;
            const playerZ = playerMotorcycle ? playerMotorcycle.position.z : 0;

            for (let i = 0; i < positions.length; i += 3) {
                const ii = i / 3;
                const s = weather.intensity;
                const dx = Math.sin(t + swirl[ii]) * drift[ii] * 0.08 * s;
                positions[i] += (velocities[i] + dx) * s;
                positions[i + 1] += velocities[i + 1] * s;
                positions[i + 2] += velocities[i + 2] * s;

                if (positions[i + 1] < -15) {
                    positions[i] = (Math.random() - 0.5) * 200;
                    positions[i + 1] = 100 + Math.random() * 40;
                    positions[i + 2] = (Math.random() - 0.5) * 200;
                }
            }
            weather.snowGeometry.attributes.position.needsUpdate = true;
            weather.snowMesh.position.z = playerZ;
        }

        // Star Wars Quotes Visualization
        function createFloatingQuote() {
            const quote = starWarsQuotes[Math.floor(Math.random() * starWarsQuotes.length)];
            
            // Create canvas for equation text
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            
            // Style the text
            context.fillStyle = 'rgba(0, 255, 255, 0.8)';
            context.font = 'bold 48px "Times New Roman", serif';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // Add glow effect
            context.shadowColor = '#00ffff';
            context.shadowBlur = 10;
            context.fillText(quote, 256, 64);
            
            // Create texture and material
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            
            // Create mesh
            const geometry = new THREE.PlaneGeometry(8, 2);
            const mesh = new THREE.Mesh(geometry, material);
            
            // Position randomly around the track
            mesh.position.set(
                (Math.random() - 0.5) * 30,
                5 + Math.random() * 10,
                playerMotorcycle.position.z - 50 - Math.random() * 100
            );
            
            // Add rotation for dynamic movement
            mesh.userData.rotationSpeed = (Math.random() - 0.5) * 0.02;
            mesh.userData.floatSpeed = 0.01 + Math.random() * 0.02;
            mesh.userData.life = 0;
            mesh.userData.maxLife = 600; // 10 seconds at 60fps
            
            scene.add(mesh);
            floatingQuotes.push(mesh);
        }

        function updateFloatingQuotes() {
            // Spawn new equations periodically
            if (Math.random() < 0.008 && floatingQuotes.length < 8) {
                createFloatingQuote();
            }
            
            // Update existing equations
            for (let i = floatingQuotes.length - 1; i >= 0; i--) {
                const quote = floatingQuotes[i];
                quote.userData.life++;
                
                // Floating motion
                quote.position.y += Math.sin(quote.userData.life * quote.userData.floatSpeed) * 0.02;
                quote.rotation.y += quote.userData.rotationSpeed;
                
                // Fade out over time
                const progress = quote.userData.life / quote.userData.maxLife;
                quote.material.opacity = 0.8 * (1 - progress);
                
                if (quote.userData.life >= quote.userData.maxLife) {
                    scene.remove(quote);
                    if (quote.geometry) quote.geometry.dispose();
                    if (quote.material) quote.material.dispose();
                    floatingQuotes.splice(i, 1);
                } else if (quote.position.z > playerMotorcycle.position.z + 50) {
                    scene.remove(quote);
                    if (quote.geometry) quote.geometry.dispose();
                    if (quote.material) quote.material.dispose();
                    floatingQuotes.splice(i, 1);
                }
            }
        }

        // --- Particle Animation Script DISABLED ---
        // Particle system removed for cleaner CYPHES aesthetic
        let particleAnimationActive = false;
        let particlesArray;
        // Particle object properties - DISABLED
        class Particle {
            constructor() { return; }
            draw() { return; }
            update() { return; }
        }
        function initParticles() {
            // Particle system disabled
            return;
        }
        function animateParticles() {
            // Particle system disabled
            return;
        }
        function showParticleBackground() {
            // Particle system disabled for cleaner CYPHES look
        }
        function hideParticleBackground() {
            // Particle system disabled for cleaner CYPHES look
        }
        // Particle resize handler disabled
        // function updateParticleBackgroundVisibility disabled
        // All particle background logic disabled for CYPHES
    </script>
    <!-- Firebase SDK and Leaderboard System -->
    <script type="module">
        // Firebase 9 Configuration
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js';
        import { getAuth, signInAnonymously, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js';
        import { getFirestore, doc, setDoc, getDoc, collection, addDoc, query, orderBy, limit, getDocs, serverTimestamp, where, runTransaction, onSnapshot } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js';

        // Firebase configuration (using same config as CYPHES)
        const firebaseConfig = {
            apiKey: "AIzaSyDnITGzY1QdlEEDAoVXAZic8DzdQgq4Z0s",
            authDomain: "cyphes2.firebaseapp.com",
            projectId: "cyphes2",
            storageBucket: "cyphes2.firebasestorage.app",
            messagingSenderId: "961771381097",
            appId: "1:961771381097:web:f787ff1da4a05edac9ddf8"
        };

        // Global Firebase variables
        let app, auth, db, currentUser = null;
        let firebaseReady = false;
        let leaderboardPlayerName = '';
        let currentLeaderboardCategory = 'ether';
        let personalBests = {};
        let isNewRecord = false;
        
        // Global CYPHES state
        let globalSwagTarget = 1000000000; // 1 billion EMC to liberate CYPHES
        let currentGlobalSwag = 0;
        let globalStateRef = null;

        // Initialize Firebase
        async function initializeFirebase() {
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                
                console.log('üî• Firebase Connected!');
                
                await initializeAuth();
            } catch (error) {
                console.error('Firebase initialization failed:', error);
                console.log('‚ùå Running in Offline Mode');
            }
        }

        // Initialize Authentication
        async function initializeAuth() {
            try {
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        currentUser = user;
                        firebaseReady = true;
                        leaderboardPlayerName = generatePlayerName();
                        loadPersonalBests();
                        
                        // Initialize global state tracking
                        globalStateRef = doc(db, 'global', 'state');
                        setupGlobalStateListener();
                        
                        // Link Solana wallet to player profile
                        linkSolanaWalletToPlayer();
                    }
                });
                
                await signInAnonymously(auth);
            } catch (error) {
                console.error('Auth failed:', error);
            }
        }

        // Link Solana wallet to Firebase player profile (uses window.cyphesWallet from main script)
        async function linkSolanaWalletToPlayer() {
            const wallet = (typeof window !== 'undefined' && window.cyphesWallet) || null;
            if (!firebaseReady || !currentUser || !db || !wallet) {
                setTimeout(linkSolanaWalletToPlayer, 1000); // Retry in 1 second
                return;
            }

            try {
                // Get current total $SWAG from localStorage
                const lifetimeTotalSwag = parseInt(localStorage.getItem('cyphes_total_swag') || '0');
                
                await setDoc(doc(db, 'cyphes_players', currentUser.uid), {
                    playerName: leaderboardPlayerName,
                    solanaWallet: wallet.publicKey.toString(),
                    totalSwagEarned: lifetimeTotalSwag,
                    walletLinkedAt: serverTimestamp(),
                    lastPlayed: serverTimestamp()
                }, { merge: true });
                
                console.log('üîó Solana wallet linked to player profile for airdrops!');
            } catch (error) {
                console.error('Failed to link Solana wallet:', error);
            }
        }

        // Update player's total $SWAG for airdrop eligibility
        async function updatePlayerTotalSwag(sessionSwag) {
            if (!firebaseReady || !currentUser || !db) return;

            try {
                const lifetimeTotalSwag = parseInt(localStorage.getItem('cyphes_total_swag') || '0');
                
                await setDoc(doc(db, 'cyphes_players', currentUser.uid), {
                    totalSwagEarned: lifetimeTotalSwag,
                    lastSwagUpdate: serverTimestamp(),
                    lastSessionSwag: sessionSwag
                }, { merge: true });
                
                console.log(`üí∞ Player total $SWAG updated: ${lifetimeTotalSwag.toLocaleString()}`);
            } catch (error) {
                console.error('Failed to update player total $SWAG:', error);
            }
        }

        // Generate unique player name
        function generatePlayerName() {
            const prefixes = ['Agent', 'Cyber', 'Quantum', 'Neon', 'Alpha', 'Shadow', 'Phoenix', 'Titan'];
            const suffixes = ['Strike', 'Force', 'Hunter', 'Rider', 'Core', 'Blade', 'Storm', 'Prime'];
            const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
            const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
            const number = Math.floor(Math.random() * 1000);
            return `${prefix}${suffix}${number}`;
        }

        // Save mission result to leaderboard
        async function saveMissionToLeaderboard(missionData) {
            if (!firebaseReady || !currentUser || !db) {
                console.log('Firebase not ready, cannot save mission');
                return;
            }

            try {
                // Check for personal bests
                const newRecords = [];
                
                if (!personalBests.ether || missionData.etherCollected > personalBests.ether) {
                    personalBests.ether = missionData.etherCollected;
                    newRecords.push('ether');
                    await saveLeaderboardEntry('ether', missionData.etherCollected, missionData);
                }
                
                if (!personalBests.enemies || missionData.enemiesDefeated > personalBests.enemies) {
                    personalBests.enemies = missionData.enemiesDefeated;
                    newRecords.push('enemies');
                    await saveLeaderboardEntry('enemies', missionData.enemiesDefeated, missionData);
                }
                
                if (!personalBests.distance || missionData.distanceTraveled > personalBests.distance) {
                    personalBests.distance = missionData.distanceTraveled;
                    newRecords.push('distance');
                    await saveLeaderboardEntry('distance', missionData.distanceTraveled, missionData);
                }
                
                if (!personalBests.speed || missionData.maxSpeed > personalBests.speed) {
                    personalBests.speed = missionData.maxSpeed;
                    newRecords.push('speed');
                    await saveLeaderboardEntry('speed', missionData.maxSpeed, missionData);
                }
                
                if (!personalBests.time || missionData.sessionTime > personalBests.time) {
                    personalBests.time = missionData.sessionTime;
                    newRecords.push('time');
                    await saveLeaderboardEntry('time', missionData.sessionTime, missionData);
                }

                // Save personal bests and link Solana wallet for airdrops
                await setDoc(doc(db, 'cyphes_players', currentUser.uid), {
                    playerName: leaderboardPlayerName,
                    personalBests: personalBests,
                    solanaWallet: wallet ? wallet.publicKey.toString() : null,
                    totalSwagEarned: (personalBests.ether || 0), // Total $SWAG for airdrop calculation
                    lastPlayed: serverTimestamp()
                }, { merge: true });

                if (newRecords.length > 0) {
                    isNewRecord = true;
                    console.log('New personal records set in:', newRecords);
                }

            } catch (error) {
                console.error('Failed to save mission to leaderboard:', error);
            }
        }

        // Save individual leaderboard entry
        async function saveLeaderboardEntry(category, score, missionData) {
            try {
                await addDoc(collection(db, 'cyphes_leaderboard'), {
                    playerId: currentUser.uid,
                    playerName: leaderboardPlayerName,
                    category: category,
                    score: score,
                    missionData: missionData,
                    timestamp: serverTimestamp()
                });
            } catch (error) {
                console.error(`Failed to save ${category} leaderboard entry:`, error);
            }
        }

        // Load personal bests
        async function loadPersonalBests() {
            if (!firebaseReady || !currentUser || !db) return;

            try {
                const docRef = doc(db, 'cyphes_players', currentUser.uid);
                const docSnap = await getDoc(docRef);
                
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    personalBests = data.personalBests || {};
                    if (data.playerName) {
                        leaderboardPlayerName = data.playerName;
                    }
                }
            } catch (error) {
                console.error('Failed to load personal bests:', error);
            }
        }

        // Load leaderboard for specific category
        async function loadLeaderboard(category) {
            if (!firebaseReady || !db) {
                return [];
            }

            try {
                const q = query(
                    collection(db, 'cyphes_leaderboard'),
                    where('category', '==', category),
                    orderBy('score', 'desc'),
                    limit(10)
                );
                
                const querySnapshot = await getDocs(q);
                const leaderboard = [];
                
                querySnapshot.forEach((doc) => {
                    leaderboard.push({
                        id: doc.id,
                        ...doc.data()
                    });
                });
                
                return leaderboard;
            } catch (error) {
                console.error('Failed to load leaderboard:', error);
                return [];
            }
        }



        // Update global SWAG score atomically
        async function updateGlobalScore(playerScore) {
            if (!firebaseReady || !db || !globalStateRef) {
                console.log('Firebase not ready for global update');
                return;
            }
            
            try {
                await runTransaction(db, async (transaction) => {
                    const globalStateDoc = await transaction.get(globalStateRef);
                    if (!globalStateDoc.exists()) {
                        transaction.set(globalStateRef, { 
                            totalSwag: playerScore,
                            lastUpdated: serverTimestamp(),
                            totalPlayers: 1 
                        });
                    } else {
                        const currentData = globalStateDoc.data();
                        const newTotalSwag = (currentData.totalSwag || 0) + playerScore;
                        transaction.update(globalStateRef, { 
                            totalSwag: newTotalSwag,
                            lastUpdated: serverTimestamp(),
                            totalPlayers: (currentData.totalPlayers || 0) + 1
                        });
                    }
                });
                console.log('Global $SWAG score updated successfully!');
            } catch (e) {
                console.error('Error updating global score: ', e);
            }
        }

        // Setup real-time listener for global state
        function setupGlobalStateListener() {
            if (!firebaseReady || !db || !globalStateRef) return;
            
            onSnapshot(globalStateRef, (doc) => {
                if (doc.exists()) {
                    const data = doc.data();
                    currentGlobalSwag = data.totalSwag || 0;
                    updateProgressBar();
                } else {
                    currentGlobalSwag = 0;
                    updateProgressBar();
                }
            }, (error) => {
                console.error('Error listening to global state:', error);
            });
        }

        // Update progress bar display (CYPHES STATS only)
        function updateProgressBar() {
            const progressPercent = Math.min((currentGlobalSwag / globalSwagTarget) * 100, 100);
            const progressFill = document.getElementById('mission-progress-fill');
            const progressText = document.getElementById('mission-progress-text');
            
            if (progressFill) {
                progressFill.style.width = progressPercent + '%';
            }
            
            if (progressText) {
                const formattedCurrent = currentGlobalSwag.toLocaleString();
                const formattedTarget = globalSwagTarget.toLocaleString();
                progressText.textContent = `Global: ${formattedCurrent} / ${formattedTarget} EMC`;
                
                // Change color when approaching target
                if (progressPercent >= 90) {
                    progressText.style.color = '#00ff00';
                    progressText.innerHTML = `Global: ${formattedCurrent} / ${formattedTarget} EMC<br/>üéâ LIBERATION IMMINENT! üéâ`;
                } else if (progressPercent >= 75) {
                    progressText.style.color = '#ffff00';
                } else {
                    progressText.style.color = '#ffffff';
                }
            }
        }

        // Format time helper function
        function formatTime(milliseconds) {
            const minutes = Math.floor(milliseconds / 60000);
            const seconds = Math.floor((milliseconds % 60000) / 1000);
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        // Initialize total $SWAG display
        function initializeTotalSwagDisplay() {
            const totalSwag = parseInt(localStorage.getItem('cyphes_total_swag') || '0');
            const statTotalSwag = document.getElementById('stat-total-swag');
            const lifetimeSwagValue = document.getElementById('lifetime-swag-value');
            
            if (statTotalSwag) {
                statTotalSwag.textContent = totalSwag.toLocaleString();
            }
            if (lifetimeSwagValue) {
                lifetimeSwagValue.textContent = totalSwag.toLocaleString();
            }
            console.log("üî• Loaded total $SWAG:", totalSwag);
        }

        // Event Listeners
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize Firebase
            initializeFirebase();
            
            // Initialize total $SWAG display
            initializeTotalSwagDisplay();
        });

        // Make functions available globally
        window.saveMissionToLeaderboard = saveMissionToLeaderboard;
        window.firebaseLeaderboardReady = () => firebaseReady;
        window.updateGlobalScore = updateGlobalScore;
        window.updatePlayerTotalSwag = updatePlayerTotalSwag;
        window.updateProgressBar = updateProgressBar;
    </script>

</body>
</html>

